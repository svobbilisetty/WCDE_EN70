<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2007, 2011 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<library>
	<!---
		This class defines a grid column that shows object property values as simple text data.
		When a cell in the column changes to edit mode, then the cell will be
		replaced by an input text editor. wcfGridText instances may only be declared as immediate
		children of instances of {@link wcfObjectGrid}.
		
		This column is {@link wcfGridColumn#findable findable} and implements the required method to highlight
		and unhighlight its cells. 
		
		The following example demonstrates the declaration of an instance of wcfGridText.
		The column will display the values of instances of the property named "object_identifier" found
		in the object instances	that are resolved using the object path "ObjectGroup/ObjectIdentifier".
		
		@START_CODE
		<GridText
			name="identifier"
			objectPath="ObjectGroup/ObjectGroupIdentifier"
			propertyName="object_identifier"
			required="true"
			editable="true"
			text="${resourceBundle.identifyObject}"
			width="90"/>
		@END_CODE
		
	-->
	<class name="wcfGridText" extends="wcfGridColumn" findable="true">
		<!---
			@keywords private
			Use {@link wcfGridTextViewer} to create cell viewer instances.
		-->
		<attribute name="cellViewerClass" value="wcfGridTextViewer"/>
		<!---
			@keywords private
			Use {@link wcfGridTextEditor} to create cell editor instances.
		-->
		<attribute name="cellEditorClass" value="wcfGridTextEditor"/>		
		<!---
			@keywords private
			Use "wcfColumnTextEditor" to create Column Editor editor.
		-->
		<attribute name="columnEditorClass" value="wcfColumnTextEditor"/>
		
		<!---
			@keywords private
			This method is called by find and replace when it finds the searched for text in a cell in this column
			to apply the visual treatment to said cell.		
			@param cell wcfGridCell The cell that contains the match.
			@param number index The index of the match in the cell.
			@param number length The length of the match in the cell. 
		-->
		<method name="highlightWordInCell" args="cell,index,length">
			<![CDATA[
			if (cell["editor"]) {				
				cell.editor.highlightWord(index, length);				
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method is called by find and replace when it wants to undo the visual treatment it did for find and 
			replace.			
			@param cell wcfGridCell The cell to remove the formatting from.			
		-->
		<method name="unhighlightCell" args="cell">
			<![CDATA[
			if (cell["editor"]) {				
				cell.editor.unhighlight();			
			}
			]]>
		</method>	
	</class>
	
	<!---
		Use this class to show simple text data in a grid cell. Use this class instead of wcfGridText if you
		need to display text for some rows and something else for other rows.
	-->
	<class name="wcfGridTextCellDescriptor" extends="wcfGridCellDescriptor">
		<!---
			@keywords private
			Use {@link wcfGridTextViewer} to create cell viewer instances.
		-->
		<attribute name="cellViewerClass" value="wcfGridTextViewer"/>
		<!---
			@keywords private
			Use {@link wcfGridTextEditor} to create cell editor instances.
		-->
		<attribute name="cellEditorClass" value="wcfGridTextEditor"/>		
	</class>
	
	<!---
		@keywords final
		This class defines a grid column that shows object property values as rich text data.
		When a cell in the column changes to edit mode a rich text editor dialog will be displayed.
		wcfGridRichText instances may only be declared as immediate children of instances
		of {@link wcfObjectGrid}. Find and replace will work on columns of this type.
		
		The following example demonstrates the declaration of an instance of wcfGridRichText.
		The column will display the values of instances of the property named "long_description" found
		in the object instances	that are resolved using the object path "ObjectGroup/ObjectGroupDescription".

		@START_CODE
		<GridRichText
			name="lDesc"
			objectPath="ObjectGroup/ObjectGroupDescription"
			propertyName="long_description"
			required="true"
			editable="true"
			text="${resourceBundle.longDescription}"
			width="200"/>
		@END_CODE
	-->
	<class name="wcfGridRichText" extends="wcfGridColumn" findable="true" tagsRemoved="true">
		<!---
			@keywords private
			Use {@link wcfGridRichTextViewer} to create cell viewer instances.
		-->
		<attribute name="cellViewerClass" value="wcfGridRichTextViewer"/>
		<!---
			@keywords private
			Use {@link wcfGridRichTextEditor} to create cell editor instances.
		-->
		<attribute name="cellEditorClass" value="wcfGridRichTextEditor"/>
		<!---
			@keywords private
			Use "wcfColumnRichTextEditor" to create Column Editor editor.
		-->
		<attribute name="columnEditorClass" value="wcfColumnRichTextEditor"/>
		<!---
			@keywords private
			This method is called by find and replace when it finds the searched for text in a cell in this column
			to apply the visual treatment to said cell.		
			@param cell wcfGridCell The cell that contains the match.
			@param number index The index of the match in the cell.
			@param number length The length of the match in the cell. 
		-->
		<method name="highlightWordInCell" args="cell,index,length">
			<![CDATA[		
			if (cell["editor"]) {				
				cell.editor.highlightWord(index, length);				
			}
			]]>
		</method>
		<!---
			@keywords private
			This method is called by find and replace when it wants to undo the visual treatment it did for find and 
			replace.			
			@param cell wcfGridCell The cell to remove the formatting from.			
		-->		
		<method name="unhighlightCell" args="cell">
			<![CDATA[
			if (cell["editor"]) {				
				cell.editor.unhighlight();			
			}
			]]>
		</method>	
	</class>
	
	<!---
		@keywords final
		This class defines a grid column that shows the display name for each row object.
		Object display names are derived from the object property declared using the
		"displayNameProperty" attribute in the object's {@link wcfObjectDefinition}.

		If the "showLongDisplayName" attribute is set to "true", the "longDisplayNameProperty"
		attribute in the object's {@link wcfObjectDefinition} will be used for display.
		
		Cells in this column cannot be changed to edit mode. wcfGridDisplayName instances can only be
		declared as immediate children of instances of {@link wcfObjectGrid}.
		
		The following example demonstrates the declaration of an instance of wcfGridDisplayName.
		The column will show the display names for the parent objects of the row objects.
		
		@START_CODE
		<GridDisplayName
			name="campaign"
			parentObject="true"
			text="${resourceBundle.campaign}"
			width="150"/>
		@END_CODE
	-->
	<class name="wcfGridDisplayName" extends="wcfGridColumn" editable="false">
		<!---
			@keywords private
		 	Use "wcfGridDisplayNameViewer" to create cell viewer instances.
		-->
		<attribute name="cellViewerClass" value="wcfGridDisplayNameViewer"/>
		<!---
			Set this attribute to "true" to show the display name for the row object's parent object. The default is
			"false" which indicates that the display name should be taken directly from the row object.
		-->
		<attribute name="parentObject" type="boolean" value="false"/>
		<!---
			Qualifies the search for the parent object to those primary objects with the
			specified object type or object group.  Used only when the <code>parentObject="true"</code>.
		-->
		<attribute name="parentType" type="string" value="${null}" />

		<!---
			Set this attribute to "true" to display the <code>longDisplayNameProperty</code> for each row object.
			The default is "false" which indicates that the <code>displayNameProperty</code> name will be shown.
		-->
		<attribute name="showLongDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "true" to display the object definition <code>displayName</code> for each row object.
			The default is "false".
		-->
		<attribute name="showObjectDefinitionDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "false" to indicate that the referenced object should not be resolved before
			calculating the display name.
			The default is "true".
		-->
		<attribute name="resolveReferencedObject" type="boolean" value="true"/>

		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				parentObject: this.parentObject,
				parentType: this.parentType,
				showLongDisplayName: this.showLongDisplayName,
				showObjectDefinitionDisplayName: this.showObjectDefinitionDisplayName,
				resolveReferencedObject: this.resolveReferencedObject
			};
			]]>
		</method>
		
		<!---
			@keywords private
			Get the column filter display value.
			@param wcfModelObject o: the model object instance
		-->
		<method name="getColumnFilterDisplayValue" args="o">
			<![CDATA[
			var displayValue = null;
			if (o && o.objectDefinition) {
				if (this.resolveReferencedObject) {
					o = o.getReferencedObject();
				}
				if (this.parentObject) {
					o = o.getParentPrimaryObject(this.parentType);
				}
				if (o) {
					if (this.showObjectDefinitionDisplayName) {
						displayValue = o.objectDefinition.displayName;
					}
					else {
						displayValue = o.objectDisplayName;
					}
				}
			}
			return displayValue;
			]]>
		</method>
		
		<!---
			@keywords private
			Register a delegate to be executed when the resolved value changes
			for the specified model object.
			@param wcfModelObject o: the model object
			@param lz.Delegate del: the delegate
		-->
		<method name="registerDelegate" args="o, del">
			<![CDATA[
			if (o && o.objectDefinition) {
				if (this.resolveReferencedObject) {
					o = o.getReferencedObject();
				}
				if (this.parentObject) {
					o = o.getParentPrimaryObject(this.parentType);
				}
				if (o) {
					if (this.showObjectDefinitionDisplayName) {
						del.register(o.objectDefinition, "ondisplayName");
					}
					else {
						del.register(o, "onobjectDisplayName");
					}
				}
			}
			]]>
		</method>
		
	</class>

	<!---
		@keywords final
		Use this class to show the object display name in a grid cell. Use this class instead of
		wcfGridDisplayName if you need to show display names for some rows and something else for
		other rows.
	-->
	<class name="wcfGridDisplayNameCellDescriptor" extends="wcfGridCellDescriptor">
		<!---
			@keywords private
		 	Use "wcfGridDisplayNameViewer" to create cell viewer instances.
		-->
		<attribute name="cellViewerClass" value="wcfGridDisplayNameViewer"/>
		<!---
			Set this attribute to "true" to show the display name for the row object's parent object. The default is
			"false" which indicates that the display name should be taken directly from the row object.
		-->
		<attribute name="parentObject" type="boolean" value="false"/>
		<!---
			Qualifies the search for the parent object to those primary objects with the
			specified object type or object group.  Used only when the <code>parentObject="true"</code>.
		-->
		<attribute name="parentType" type="string" value="${null}" />

		<!---
			Set this attribute to "true" to display the <code>longDisplayNameProperty</code> for each row object.
			The default is "false" which indicates that the <code>displayNameProperty</code> name will be shown.
		-->
		<attribute name="showLongDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "true" to display the object definition <code>displayName</code> for each row object.
			The default is "false".
		-->
		<attribute name="showObjectDefinitionDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "false" to indicate that the referenced object should not be resolved before
			calculating the display name.
			The default is "true".
		-->
		<attribute name="resolveReferencedObject" type="boolean" value="true"/>

		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				parentObject: this.parentObject,
				parentType: this.parentType,
				showLongDisplayName: this.showLongDisplayName,
				showObjectDefinitionDisplayName: this.showObjectDefinitionDisplayName,
				resolveReferencedObject: this.resolveReferencedObject
			};
			]]>
		</method>
		
		<!---
			@keywords private
			Get the column filter display value.
			@param wcfModelObject o: the model object instance
		-->
		<method name="getColumnFilterDisplayValue" args="o">
			<![CDATA[
			var displayValue = null;
			if (o && o.objectDefinition) {
				if (this.resolveReferencedObject) {
					o = o.getReferencedObject();
				}
				if (this.parentObject) {
					o = o.getParentPrimaryObject(this.parentType);
				}
				if (o) {
					if (this.showObjectDefinitionDisplayName) {
						displayValue = o.objectDefinition.displayName;
					}
					else {
						displayValue = o.objectDisplayName;
					}
				}
			}
			return displayValue;
			]]>
		</method>
	</class>

	<!---
		@keywords final
		This class defines a grid column that shows object type icons for each row object.
		The icon resource is derived from the "icon" attribute of the
		row object's {@link wcfObjectDefinition}.
		Cells in this column cannot be changed to edit mode. wcfGridIconTypeImage instances may only be
		declared as immediate children of instances of {@link wcfObjectGrid}.
		
		The following example demonstrates the declaration of an instance of wcfGridIconTypeImage.
		
		@START_CODE
		<GridIconTypeImage
			text="${resourceBundle.catalogGroupType_ColumnHeader}"
			visible="true"
			required="true"
			width="60"/>
		@END_CODE
	-->
	<class name="wcfGridIconTypeImage" extends="wcfGridColumn" editable="false" alignment="center">
		<!---
			@keywords private
			Use "wcfGridTypeImageViewer" to create instances of this column's viewer.
		-->
		<attribute name="cellViewerClass" value="wcfGridTypeImageViewer"/>
		
		<!---
			@keywords private
			Get the column filter display value.
			@param wcfModelObject o: the model object instance
		-->
		<method name="getColumnFilterDisplayValue" args="o">
			<![CDATA[
			if (o) {
				return o.getReferencedObject().objectDefinition.displayName;
			}
			else {
				return null;
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Register a delegate to be executed when the resolved value changes
			for the specified model object.
			@param wcfModelObject o: the model object
			@param lz.Delegate del: the delegate
		-->
		<method name="registerDelegate" args="o, del">
			<![CDATA[
			]]>
		</method>
		
	</class>
	
	<!---
		@keywords private
		
		Text box viewer class for internal use by {@link wcfGridText} to display a property value text and will be
		displayed while the grid is in view mode.
		
		Extends openlaszlo's {@OLlink text}.
	-->
	<class name="wcfGridTextViewer" extends="text" resize="true" multiline="true" fgcolor="${this.textColor}" fontstyle="${this.textStyle}" >
		<!--- {@link wcfModelProperty} instance associated with this viewer. -->
		<attribute name="property" value="null" setter="setProperty(property)"/>
		<!---
			Indicates that the text should interpreted as HTML.
		-->
		<attribute name="html" value="false" type="boolean"/>

		<!---
			@keywords private
			text color
		-->
		<attribute name="textColor" value="0x0" type="color"/>
		<!---
			@keywords private
			text style
		-->
		<attribute name="textStyle" type="string" value="plain"/>				
		
		<!--- @keywords private -->
		<handler name="onfocus" >
			<![CDATA[
		 	if(!this["indicator"]){
			    new lz.wcfFocusIndicator(this, {
			    	name: "indicator",
			    	focusableView: this,
			    	indicatorView: this
				});
			}
			if ($as3) {
				// assign keyboard control
				LFCApplication.stage.focus = this.tsprite.textfield;
				this.setSelection(0);
			} else {
				if (this.getSelectionPosition() == -1) {
					this.setSelection(0);
				}
			}
			]]>
		</handler>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this["updateValueDel"]) {
				this.updateValueDel.unregisterAll();
				delete this.updateValueDel;
			}
			super.destroy();
			]]>
		</method>
		
		<!---
			Set the {@link wcfModelProperty} to be associated with this text box. Listeners are created to
			watch the property value. If the property changes at anytime, the updateValue method will be called.
			@param wcfModelProperty newProperty: New Property associated with this text box
		-->
		<method name="setProperty" args="newProperty">
			<![CDATA[
			if (typeof(this["property"]) == "undefined" || newProperty != this["property"]) {
				if (typeof(this.updateValueDel) == "undefined") {
					this.updateValueDel = new lz.Delegate(this, "updateValue");
				}
				this.updateValueDel.unregisterAll();
				this.property = newProperty;
				if (this["property"]) {
					this.updateValueDel.register(this.property, "onvalue");
					this.updateValue();
				}
			}
			]]>
		</method>

		<!---
			Update and refresh wcfGridTextViewer value with a new {@link wcfModelProperty} value.			
		-->
		<method name="updateValue" args="e=null">
			<![CDATA[
			var newText = this.parent.column.getCellText(this.property.o, this.property);
			
			if (!html) {
				newText = this.escapeText(newText);
			}
			else {
				newText = wcfRichTextEditorUtil.removeTags(newText);
			}
			if (this.text != newText) {
				this.setAttribute("text", newText);
			}
			]]>
		</method>
		
		<layout name="viewerLayout">
			<!--- @keywords private -->
			<method name="init">
				<![CDATA[
				super.init();
				this.updateDelegate.register(parent.immediateparent, "onavailableWidth");
				this.updateDelegate.register(parent, "ontext");
				]]>
			</method>
			
			<!---
				@keywords private
				Update the cell layout.
			-->
			<method name="update" args="e=null">
				<![CDATA[
				if (!this.locked) {
					this.lock();
					var newWidth = parent.getTextWidth() + 1;
					var availableWidth = parent.immediateparent.availableWidth;
					if (availableWidth < 75) {
						availableWidth = 75;
					}
					if (newWidth > availableWidth) {
						newWidth = availableWidth;
					}
					if (parent.width != newWidth) {
						parent.setAttribute("width", newWidth);
					}
			        this.locked = false;
				}
				]]>
			</method>
		</layout>
	</class>
	
	<!---
		@keywords private
		
		This class overrides the <code>updateValue</code> method in the {@link wcfTextViewer} class.
	-->
	<class name="wcfGridStoreNameViewer" extends="wcfGridTextViewer">
		<!---	
			@keywords private
		-->
		<attribute name="storeId" type="string" value=""/>
				
		<!---
			@keywords private
			Updates and refreshes the storeId with a new {@link wcfModelProperty} value.
		-->
		<method name="updateValue" args="e=null">
			<![CDATA[
			var storeId = this.property.value;
			if (storeId != this.storeId) {
				this.storeId = storeId;
				this.updateStoreName();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates and refreshes the text value by resolving the store name with a new storeId.
		-->
		<method name="updateStoreName" args="e=null">
			<![CDATA[
			if (typeof(this.updateStoreNameDel) == "undefined") {
				this.updateStoreNameDel = new lz.Delegate(this, "updateStoreName");
			}
			this.updateStoreNameDel.unregisterAll();
			if(this.storeId == ''){
				this.setAttribute('text', '');
			}else{
				var store = wcfStoreUtil.storeMap[this.storeId];
				if(store != null){
					this.setAttribute('text', store.displayName);
				}else{
					this.updateStoreNameDel.register(wcfStoreUtil,"storeLoaded");
				}
			}
			]]>
		</method>

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this["updateStoreNameDel"]) {
				this.updateStoreNameDel.unregisterAll();
				delete this.updateStoreNameDel;
			}
			super.destroy();
			]]>
		</method>
	</class>
	
	<!---
		@keywords final
		This class defines a grid column that shows the store name for each row object.
		The store name for an object is the name of the store that matches the store ID found
		in the object property named "objectStoreId".
		Cells in this column cannot be changed to edit mode. wcfGridStoreName instances can only be
		declared as immediate children of instances of {@link wcfObjectGrid}.
		
		The following example demonstrates the declaration of an instance of wcfGridStoreName.
		
		@START_CODE
		<GridStoreName name="storeName"/>
		@END_CODE
	-->
	<class name="wcfGridStoreName" extends="wcfGridColumn" editable="false" enableFilter="true" propertyName="objectStoreId" text="${foundationResources.objectProperties_storeName.string}" width="150">
		<!---
			@keywords private
		 	Use "wcfGridDisplayNameViewer" to create cell viewer instances.
		-->
		<attribute name="cellViewerClass" value="wcfGridStoreNameViewer"/>
		<!---
		When this value is <code>false</code>, this column is only visible when working in an extended site and not
		in any other store model types. When this value is <code>true</code>, this column is always visible regardless
		of store model type.
	  -->
	  <attribute name="alwaysVisible" type="boolean" value="false"/>

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			if(!this.alwaysVisible) {
			      wcfDefinitionLoader.getDefinition("wcfAssetInfoStoreTypesCondition", this);
		  }
			super.init();
			]]>
		</method>
		<!---
			@keywords private
			Get the column filter display value.
			@param wcfModelObject o: the model object instance
		-->
		<method name="getColumnFilterDisplayValue" args="o">
			<![CDATA[
			var storeId = super.getColumnFilterDisplayValue(o);
			if (wcfStoreUtil.storeMap[storeId]) {
				return wcfStoreUtil.storeMap[storeId].displayName;
			}else{
				return null;
			}
			]]>
		</method>
	</class>

	<!---
		@keywords private
		
		Rich text box viewer class for internal use by {@link wcfGridRichText} to display a property value text and will be
		displayed while the grid is in view mode. The text will be displayed as html.
		
		Extends openlaszlo's {@link wcfGridTextViewer}.
	-->
	<class name="wcfGridRichTextViewer" extends="wcfGridTextViewer" html="true"/>
	
	<!---
		@keywords private
		
		Object display name viewer for a grid cell.
	-->
	<class name="wcfGridDisplayNameViewer" extends="wcfGridTextViewer">
		<!---
			Set this attribute to "true" to display the <code>longDisplayNameProperty</code> for each  object.
			The default is "false" which indicates that the <code>displayNameProperty</code> name will be shown.
		-->
		<attribute name="showLongDisplayName" type="boolean" value="false"/>
		<!---
			Use the parent object to resolve the display name.
		-->
		<attribute name="parentObject" type="string" value=""/>
		<!---
			Specify the object type or object group of the parent object that will be used to resolve the display name.
		-->
		<attribute name="parentType" type="string" value="" />
		<!---
			Set this attribute to "true" to display the object definition <code>displayName</code> for each row object.
			The default is "false".
		-->
		<attribute name="showObjectDefinitionDisplayName" type="boolean" value="false"/>
		<!---
			Set this attribute to "false" to indicate that the referenced object should not be resolved before
			calculating the display name.
			The default is "true".
		-->
		<attribute name="resolveReferencedObject" type="boolean" value="true"/>
		<!---
			The model object instance.
		-->
		<attribute name="o" value="null" setter="this.setModelObject(o)"/>		

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this["updateDisplayNameDel"]) {
				this.updateDisplayNameDel.unregisterAll();
				delete this.updateDisplayNameDel;
			}
			super.destroy();
			]]>
		</method>
		
		<!---
			Set the new model object.
			@param wcfModelObject newObject: the new object
		-->
		<method name="setModelObject" args="newObject">
			<![CDATA[
			if (typeof(this["o"]) == "undefined" || this.o != newObject) {
				this.o = newObject;
				this.updateDisplayName();
			}
			]]>
		</method>
		
		<!---
			Update the display text.
		-->
		<method name="updateDisplayName" args="e=null">
			<![CDATA[
			if (!this["updateDisplayNameDel"]) {
				this.updateDisplayNameDel = new lz.Delegate(this, "updateDisplayName");
			}
			var newDisplayName = "";
			var newTextColor = this.parent.style.textcolor;
			var newTextStyle = "plain";
			this.updateDisplayNameDel.unregisterAll();
			if (this.o != null && this.o.objectDefinition != null) {
				var resolvedObject = this.o;
				if (this.resolveReferencedObject) {
					resolvedObject = this.o.getReferencedObject();
				}
				if (this.parentObject) {
					resolvedObject = resolvedObject.getParentPrimaryObject(this.parentType, this.updateDisplayNameDel);
				}
				if (resolvedObject) {
					if (this.showObjectDefinitionDisplayName) {
						newDisplayName = resolvedObject.objectDefinition.displayName;
						this.updateDisplayNameDel.register(resolvedObject.objectDefinition, "ondisplayName");
					}
					else {
						if (this.showLongDisplayName) {
							if (resolvedObject.objectLongDisplayName != null) {
								newDisplayName = resolvedObject.objectLongDisplayName;
							}
							this.updateDisplayNameDel.register(resolvedObject, "onobjectLongDisplayName");
						}
						else {
							if (resolvedObject.objectDisplayName != null) {
								newDisplayName = resolvedObject.objectDisplayName;
							}
							this.updateDisplayNameDel.register(resolvedObject, "onobjectDisplayName");
						}
					}
					var style = resolvedObject.displayNameStyle;
					if (style != null) {
						newTextColor = style.color;
						if (style.bold && style.italic) {
							newTextStyle = "bolditalic";
						}
						else if (style.bold) {
							newTextStyle = "bold";
						}
						else if (style.italic) {
							newTextStyle = "italic";
						}
					}
				}
			}
			newDisplayName = this.escapeText(newDisplayName);
			if (this.text != newDisplayName) {
				this.setAttribute("text", newDisplayName);
			}
			if (this.textColor != newTextColor) {
				this.setAttribute("textColor", newTextColor);
			}
			if (this.textStyle != newTextStyle) {
				this.setAttribute("textStyle", newTextStyle);
			}
			]]>
		</method>
		
		<method name="setProperty" args="newProperty"/>
		<method name="updateValue" args="e=null"/>
	</class>
	
	<!---
		@keywords private
		
		Object type icon viewer for a grid cell.
	-->
	<class name="wcfGridTypeImageViewer">
		<!---
			Icon resource name.
		-->
		<attribute name="icon" value="null"/>
		<!---
			Model object instance.
		-->
		<attribute name="o" value="null" setter="this.setModelObject(o)"/>		

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			super.init();
			this.updateTooltip();
			]]>
		</method>

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this["updateTooltipDel"]) {
				this.updateTooltipDel.unregisterAll();
				delete this.updateTooltipDel;
			}
			super.destroy();
			]]>
		</method>

		<!---
			Set the model object instance for this viewer.
			@param wcfModelObject newObject: the new model object instance
		-->
		<method name="setModelObject" args="newObject">
			<![CDATA[
			if (typeof(this["o"]) == "undefined" || this.o != newObject) {
				this.o = newObject;
				if (this.o) {
					this.setAttribute("icon", this.o.getIcon());
				}
				this.updateTooltip();
			}
			]]>
		</method>

		<!---
			Updates the tooltip text.
		-->
		<method name="updateTooltip" args="e=null">
			<![CDATA[
			if (this["display"]) {
				if (typeof(this.updateTooltipDel) == "undefined") {
					this.updateTooltipDel = new lz.Delegate(this, "updateTooltip");
				}
				this.updateTooltipDel.unregisterAll();
				var tooltipText = null;
				if (this.o) {
					tooltipText = this.o.getTypeDisplayName(this.updateTooltipDel);
				}
				this.display.tip.setAttribute("text", tooltipText);
				this.display.tip.setAttribute("enabled", tooltipText != null);
			}
			]]>
		</method>

		<image name="display" stretches="both" clickable="true" resource="${classroot.icon}">
			<wcfTooltip name="tip"/>

			<handler name="onclick">
				<![CDATA[
				if(parent.parent.parent["onclick"]){
					parent.parent.parent.onclick.sendEvent();
				}
				]]>
			</handler>

			<handler name="ondblclick">
				<![CDATA[
				if(parent.parent.parent["ondblclick"]){
					parent.parent.parent.ondblclick.sendEvent();
				}
				]]>
			</handler>
		</image>
	</class>
	
	<!---
		@keywords final
		This class defines a grid column that shows specific image resources based on
		the property value of the cell.	wcfGridPropertyImage instances may only be
		declared as immediate children of instances of {@link wcfObjectGrid}. The image
		displayed will be the image specified by the {@link wcfPropertyValue#icon} attribute.
		To override an image for one or more values, use the "imageResourceMap" attribute.
		
		The following example demonstrates the declaration of an instance of wcfGridIconTypeImage. There
		are three possible icons that will be displayed based on the value of the property named
		"sent".
		
		@START_CODE
		<PropertyDefinition propertyName="sent" copyProtected="true">
			<PropertyValue value="0" displayName="${mktMarketingResources.unsent}" icon="emailActivityUnsentIcon"/>
			<PropertyValue value="1" displayName="${mktMarketingResources.sent}" icon="emailActivitySentIcon"/>
			<PropertyValue value="9" displayName="${mktMarketingResources.scheduled}" icon="emailActivityScheduledIcon"/>
		</PropertyDefinition>
		
		...
		
		<GridPropertyImage name="sent" objectPath="Activity/EmailStatistics[uniqueId=1]"
			propertyName="sent" text="${mktMarketingResources.emailSent}" width="100">
			<GridCellDescriptor propertyName="sent" objectType="ChildWebActivity" disabled="true"/>
		</GridPropertyImage>
		@END_CODE
	-->	
	<class name="wcfGridPropertyImage" extends="wcfGridColumn" editable="false" alignment="center">
		<!---
			@keywords private
			Use "wcfGridPropertyImageViewer" to create instances of this column's viewer.
		-->
		<attribute name="cellViewerClass" value="wcfGridPropertyImageViewer"/>
		<!---
			A map of property values and images in the form: {value1: "resource1", ... , valueN: "resourceN"}.
			The image found in this map will take precedence over the image found in the {@link wcfPropertyValue#icon}
			attribute.
			@type Map
		-->
		<attribute name="imageResourceMap" value="${{}}"/>
		<!--- Image to show when value isn't found in the imageResourceMap -->
		<attribute name="defaultResource" type="string" value="${null}"/>

		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				imageResourceMap: this.imageResourceMap,
				defaultResource: this.defaultResource
			};
			]]>
		</method>
	</class>
	
	<!---
		@keywords private
		
		Viewer class for wcfGridPropertyImage which displays the appropriate image depending on the property value.
	-->
	<class name="wcfGridPropertyImageViewer">
		<!--- A map of property values and images in the form: {value1: "resource1", ... , valueN: "resourceN"} -->
		<attribute name="imageResourceMap" value="null"/>
		<!--- Image to show when value isn't found in the imageResourceMap. Default is null and no image is shown. -->
		<attribute name="defaultResource" type="string" value="${null}"/>
		<!--- @keywords private -->
		<attribute name="icon" type="string" value="${null}"/>
		<!--- wcfModelProperty instance associated with this viewer -->
		<attribute name="property" value="null" setter="setProperty(property)"/>	

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			super.init();
			this.updateIcon();
			]]>
		</method>

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this["updateIconDel"]) {
				this.updateIconDel.unregisterAll();
				delete this.updateIconDel;
			}
			if (this["updateTooltipDel"]) {
				this.updateTooltipDel.unregisterAll();
				delete this.updateTooltipDel;
			}
			super.destroy();
			]]>
		</method>

		<!---
			Set the property for this viewer.
			@param wcfModelProperty newProperty: the new property instance
		-->
		<method name="setProperty" args="newProperty">
			<![CDATA[
			if(newProperty != this["property"]) {
				this.property = newProperty;
				this.updateIcon();
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="updateIcon" args="e=null">
			<![CDATA[
			if (typeof(this.updateIconDel) == "undefined") {
				this.updateIconDel = new lz.Delegate(this, "updateIcon");
			}
			this.updateIconDel.unregisterAll();

			var imageResource = null;
			if (this.property != null) {
				var propValue = this.property.value;
				if (this.imageResourceMap != null && this.imageResourceMap[propValue]) {
					imageResource = this.imageResourceMap[propValue];
				}
				if (imageResource == null && this.property.propertyDefinition) {
					var propValueDef = this.property.propertyDefinition.getPropertyValue(this.property, this.updateIconDel);
					if (propValueDef) {
						imageResource = propValueDef.icon;
					}
				}
				this.updateIconDel.register(this.property, "onvalue");
			}
			if (imageResource == null) {
				imageResource = this.defaultResource;
			}
			
			if (this.icon != imageResource) {
				this.setAttribute("icon", imageResource);
			}

			this.updateTooltip();
			]]>
		</method>

		<!--- @keywords private -->
		<method name="updateTooltip" args="e=null">
			<![CDATA[
			if (this["display"]) {
				if (typeof(this.updateTooltipDel) == "undefined") {
					this.updateTooltipDel = new lz.Delegate(this, "updateTooltip");
				}
				this.updateTooltipDel.unregisterAll();
	
				var tooltipText = null;
				if (this["property"]) {
					var propertyValue = this.property.propertyDefinition.getPropertyValue(this.property, this.updateTooltipDel);
					if (propertyValue != null) {
						tooltipText = propertyValue.getDisplayName(this.updateTooltipDel);
					}
				}
				this.display.tip.setAttribute("text", tooltipText);
				this.display.tip.setAttribute("enabled", tooltipText != null);
			}
			]]>
		</method>

		<image name="display" stretches="both" visible="${classroot.icon ? true : false}" resource="${classroot.icon}" clickable="true">
			<wcfTooltip name="tip"/>

			<handler name="onclick">
				<![CDATA[
				if(parent.parent.parent["onclick"]){
					parent.parent.parent.onclick.sendEvent();
				}
				]]>
			</handler>

			<handler name="ondblclick">
				<![CDATA[
				if(parent.parent.parent["ondblclick"]){
					parent.parent.parent.ondblclick.sendEvent();
				}
				]]>
			</handler>
		</image>
	</class>

	<!---
		@keywords private
		
		Text box editor class for internal use by {@link wcfGridText} to bind a property to the grid input box and will be
		displayed while the grid is in edit mode. Extends {@link wcfTextEditor} to handle transition from edit mode to view
		mode with mouse and key navigation.
	-->
	<class name="wcfGridTextEditor" extends="wcfTextEditor" width="${immediateparent.availableWidth}" maximumHeight="${immediateparent.maximumHeight}" textAreaHeight="18" multiline="true">
		<!---
			Indicates that that this editor contains the find and replace highlight.
		-->
		<attribute name="highlighted" type="boolean" value="false"/>
		<!--- @keywords private -->		
		<method name="init">
			<![CDATA[			
			super.init();					
			this.updateBGColorDel = new lz.Delegate(this, "updateBGColor");	
			this.updateBGColor();
			]]>
		</method>
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[	
			if (this["updateBGColorDel"]){
				this.updateBGColorDel.unregisterAll();
				delete this.updateBGColorDel;
			}	
			super.destroy();		
			]]>
		</method>		
		<!---
			@keywords private
			This method updates the background and border color of the editor.
		-->	
		<method name="updateBGColor" args="e=null"><![CDATA[		
			this.updateBGColorDel.unregisterAll();
			this.updateBGColorDel.register(parent.column, "onvisible");
			if (parent.column.visible) {
				var c = this.style.forminputdisabledbgcolor;
				var b = this.style.disabledbordercolor;
				if (parent.row.selected) {
					if (parent.row.parent.activated) {
						c = this.style.forminputdisabledselectedbgcolor;
						b = this.style.disabledselectedbordercolor;
					} else {							
						c = this.style.forminputdisabledinactiveselectedbgcolor;
						b = this.style.disabledinactiveselectedbordercolor;
					}
				} else  if (parent.row.mouseIn) {
					c = this.style.forminputdisabledhoverbgcolor;
					b = this.style.disabledhoverbordercolor;
				}
				if (c != this.disabledBGColor) {
					this.setAttribute("disabledBGColor", c);
				}
				if (b != this.disabledBorderColor) {
					this.setAttribute("disabledBorderColor", b);
				}
				this.updateBGColorDel.register(parent.row, "onselected");
				this.updateBGColorDel.register(parent.row, "onmouseIn");			
				this.updateBGColorDel.register(parent.row.parent, "onactivated");
			}			
			]]>
		</method>
		<!---
			@keywords private
			Update and refresh the wcfTextEditor value with a new {@link wcfModelProperty} value. 
		-->
		<method name="updateValue" args="e=null">
			<![CDATA[
			if (this.highlighted) {
				this.unhighlight();
			}
			super.updateValue(e);
			]]>
		</method>

		<!---
			@keywords private
			This method adds the visual treatment for find and replace to the specified text.
			@param number index The index of the match
			@param number length The length of the match
		-->
		<method name="highlightWord" args="index,length">
			<![CDATA[
			//Grey out the text
			var textFormat;
			if ($as3) {
				textFormat = this.inputText.tsprite.textfield.getTextFormat(0, this.inputText.getText().length);
			}
			else {
				textFormat = this.inputText.sprite.__LZtextclip.getTextFormat(0, this.inputText.getText().length);
			}
			textFormat.color = 0x9c9c9c;
			if ($as3) {
				this.inputText.tsprite.textfield.setTextFormat(textFormat, 0, this.inputText.getText().length);
			}
			else {
				this.inputText.sprite.__LZtextclip.setTextFormat(0, this.inputText.getText().length, textFormat);
			}

			//Now hilight the word
			if ($as3) {
				textFormat = this.inputText.tsprite.textfield.getTextFormat(index, index+length);
			}
			else {
				textFormat = this.inputText.sprite.__LZtextclip.getTextFormat(index, index+length);
			}
			textFormat.color = 0xFF6633;
			textFormat.bold = true;
			if ($as3) {
				this.inputText.tsprite.textfield.setTextFormat(textFormat, index, index+length);
			}
			else {
				this.inputText.sprite.__LZtextclip.setTextFormat(index, index+length, textFormat);
			}
			this.inputText.updateInputTextHeight();
			this.highlighted = true;
			]]>
		</method>

		<!---
			@keywords private
			This method undoes the visual treatment for find and replace.			
		-->
		<method name="unhighlight">
			<![CDATA[
			//Revert text to original unformatted colour/style
			var textFormat;
			if ($as3) {
				textFormat = this.inputText.tsprite.textfield.getTextFormat(0, this.inputText.getText().length);
			}
			else {
				textFormat = this.inputText.sprite.__LZtextclip.getTextFormat(0, this.inputText.getText().length);
			}

			textFormat.color = this._enabled? 0x000000 : this.style.textdisabledcolor;

			textFormat.bold = false;
			if ($as3) {
				this.inputText.tsprite.textfield.setTextFormat(textFormat, 0, this.inputText.getText().length);
			}
			else {
				this.inputText.sprite.__LZtextclip.setTextFormat(0, this.inputText.getText().length, textFormat);
			}
			this.inputText.updateInputTextHeight();
			this.highlighted = false;
			]]>
		</method>
	</class>

	<!---
		@keywords private
		
		Rich text box editor class for internal use by {@link wcfGridRichText} to bind a property to the grid rich input box and will be
		displayed while the grid is in edit mode. Extends {@link wcfRichTextEditor} to handle transition from edit mode to view
		mode with mouse and key navigation.
		
		In edit mode, a dialog {@link wcfDialog} named wcfRichTextDialog is opened that contains a {@link wcfRichTextEditor} that allows the business
		user to edit the text value.
	-->
	<class name="wcfGridRichTextEditor" extends="basecomponent" width="${immediateparent.availableWidth}" focusable="false">	
		<!--- {@link wcfModelProperty} instance associated with this editor. -->
		<attribute name="property"  value="null" setter="setProperty(property)"/>

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			if (parent["menu"]) {
				parent.menu.addView(this);
			}
			else if (parent.grid["menu"]) {
				parent.grid.menu.addView(this);
			}
			super.init();
			updateValue();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this["updateValueDel"]) {
				this.updateValueDel.unregisterAll();
				delete this.updateValueDel;
			}
			super.destroy();
			]]>
		</method>
		
		<!---
			Set the {@link wcfModelProperty} to be associated with this text box. Listeners are created to
			watch the property value. If the property changes at anytime, the updateValue method will be called.
			@param wcfModelProperty newProperty: New Property associated with this text box
		-->
		<method name="setProperty" args="newProperty">
			<![CDATA[
			if (typeof(this["property"]) == "undefined" || newProperty != this["property"]) {
				if (typeof(this.updateValueDel) == "undefined") {
					this.updateValueDel = new lz.Delegate(this, "updateValue");
				}
				this.updateValueDel.unregisterAll();
				this.property = newProperty;
				if (this["property"]) {
					this.updateValueDel.register(this.property, "onvalue");
					this.updateValue();
				}
			}
			]]>
		</method>

		<!---
			Update and refresh wcfGridTextEditor value with a new {@link wcfModelProperty} value.			
		-->
		<method name="updateValue" args="e=null">
			<![CDATA[
			if (this.isinited) {
				var newText = this.parent.column.getCellText(this.property.o, this.property);
				newText = wcfRichTextEditorUtil.removeTags(newText);
				if (this.richText.text != newText) {
					this.richText.setAttribute("text", newText);
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method adds the visual treatment for find and replace to the specified text.
			@param number index The index of the match
			@param number length The length of the match
		-->
		<method name="highlightWord" args="index,length">
			<![CDATA[
			//Grey out the text
			var greyTag = "<FONT COLOR='#9c9c9c'>";
			var highlightTag = "<FONT COLOR='#FF6633'>";
			var closeColorTag = "</FONT>";
			var boldTag = "<B>";
			var closeBoldTag = "</B>";
			
			
			var newText = this.richText.text;
			newText = greyTag + newText.substring(0, index) + boldTag + highlightTag + newText.substring(index, index+length) + closeColorTag + closeBoldTag + newText.substring(index+length) + closeColorTag;
			this.richText.setAttribute("text", newText);
			]]>
		</method>
		
		<!---
			@keywords private
			This method undoes the visual treatment for find and replace.			
		-->
		<method name="unhighlight">
			<![CDATA[
			this.updateValue(null);
			]]>
		</method>
		
		<simplelayout axis="x" spacing="0"/>
		
		<text name="richText" width="${parent.width-parent.openDialogButton.width}" multiline="true"/>	

		<basebutton name="openDialogButton" enabled="${classroot.enabled}" resource="rteGridIcon" focusable="true">
			<!--
				@keyword private
				onclick is fired not only on mouse click but also when a business user hits the enter key.  onkeyup was being called
				after the wcfRichTextDialog was opened and causing the value to be stored even though there was no change.  This
				marked the object as dirty, see d166420.  An lz.Timer was added to let the flash stack clear before the rte is opened
				to prevent this.
			-->
			<handler name="onclick">
				<![CDATA[
				wcfRichTextDialog.setAttribute("gridEditor", classroot);
				if (typeof(this._opendel) === "undefined") {
					this._opendel = new lz.Delegate(wcfRichTextDialog, "openRichTextDialog");
				}
				lz.Timer.resetTimer( this._opendel, 100 ); //lz.Idle did not work so lz.Timer was used
				]]>
			</handler>
			
			<!--- @keywords private -->
			<method name="destroy">
				<![CDATA[
				if (this.hasdefault) {
					lz._componentmanager.service.checkDefault(null);
				}
				if (this["_opendel"]) {
					this._opendel.unregisterAll();
					delete this._opendel;
				}
				super.destroy();
				]]>
			</method>
			
			<!---
				@keywords private
				Handle focus.
			-->
			<handler name="onfocus">
				<![CDATA[
				if(!this["indicator"]){
					new lz.wcfFocusIndicator(this, {
						name: "indicator",
						focusableView: this,
						indicatorView: this
					});
				}
				]]>
			</handler>
		</basebutton>
	</class>
	
	<!---
		@keywords private
	-->
	<wcfDialog name="wcfRichTextDialog"
			contentPaddingLeftSize="0" contentPaddingRightSize="0" contentPaddingTopSize="0" contentPaddingBottomSize="0">
		<attribute name="gridEditor" value="null"/>
		<attribute name="originalText" value="null"/>
		<attribute name="originalDirty" type="boolean" value="false"/>
		<attribute name="originalOpenGroupOpen" type="boolean" value="false"/>
		
		<method name="openRichTextDialog" args="e=null">
			<![CDATA[
			this.openWindow();
			this.setAttribute("title", this.gridEditor.parent.column.displayText);
			this.originalText = this.gridEditor.property.value;
			this.originalDirty = this.gridEditor.property.dirty;
			this.originalOpenGroupOpen = this.gridEditor.property.o.openGroupObject.open;
			this.richTextEditor.setProperty(this.gridEditor.property);
			this.richTextEditor.updateValue();
			this.richTextEditor.richInputText.setSelection(0, 0);
			]]>
		</method>
		
		<!---
			Set the focus to Text Input field
		-->
		<method name="setInitialFocus" args="e=null">
			<![CDATA[
			lz.Focus.setFocus(this.richTextEditor.richInputText);
			]]>
		</method>

		<method name="closeWindow">
			<![CDATA[
			if (this.originalText != null) {
				if (this.originalDirty) {
					this.gridEditor.property.change(this.originalText);
				}
				else {
					this.gridEditor.property.restore();
				}
				if (!this.originalOpenGroupOpen){
					this.gridEditor.property.o.openGroupObject.setAttribute("open", false);				
				}
			}
			super.closeWindow();
			lz.Focus.setFocus(this.gridEditor.openDialogButton);
			this.gridEditor = null;
			this.originalText = null;
			]]>
		</method>

		<method name="handleOk">
			<![CDATA[
			this.originalText = null;
			this.closeWindow();
			]]>
		</method>
		
		<wcfRichTextEditor name="richTextEditor" width="500" textAreaHeight="240" maximumHeight="400"/>
		<view placement="footer">
			<simplelayout axis="x"/>	
			<wcfButton onclick="parent.parent.handleOk()" text="${foundationResources.richTextDialogOkButton.string}"/>
			<wcfButton onclick="parent.parent.closeWindow()" text="${foundationResources.richTextDialogCancelButton.string}"/>
		</view>	
	 </wcfDialog>
	 
	<!---
		This class defines a grid column that shows the images found at the URLs
		derived from the values of the properties associated with the cells. If
		an image is not available, then a default image that indicates
		the image could not be found will be displayed.
		Cells in this column cannot be changed to edit mode.
		wcfGridImage instances may only be declared as immediate
		children of instances of {@link wcfObjectGrid}.
		
		The following example demonstrates the declaration of an instance of wcfGridImage.
		The column will display the images found at the URLs derived from the values
		of the property instances named "thumbnail" found
		in the object instances	that are resolved using the object path
		"CatalogGroup/CatalogGroupDescription".
				
		@START_CODE
		<GridImage
			name="thumbnail"
			objectPath="CatalogGroup/CatalogGroupDescription"
			propertyName="tImage"
			text="${resourceBundle.productThumbnail_ColumnHeader}"
			visible="false"
			sortable="false"/>
		@END_CODE
	-->
	<class name="wcfGridImage" extends="wcfGridColumn" alignment="center" width="80" editable="false">
		<!---
			@keywords private
			Use "wcfGridImageViewer" to create instances of this column's viewer.
		-->
		<attribute name="cellViewerClass" value="wcfGridImageViewer"/>
		<!---
			This attribute allows you to specify the maximum width for the images displayed in the column. Images that are wider will be scaled
			down to this width.
		-->
		<attribute name="maximumWidth" value="60" type="number"/>
		
		<!---
			This attribute allows you to specify if image tooltip shows along with image displayed in the column.
		-->
		<attribute name="showImageToolTip" value="false" type="boolean"/>
		

		<!---
			@keywords private
			This method returns the viewer initialization arguments.
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return {
				maximumWidth: this.maximumWidth,
				showImageToolTip: this.showImageToolTip
			};
			]]>
		</method>
		
		<!---
			Get the image URL for the specified property value. The default implementation returns the unmodified property value.
			Override this method if the property value must be modified before fetching the image.
			@param string value: the property value
			@return string: the image URL
		-->
		<method name="getImageURL" args="value">
			<![CDATA[
			return value;
			]]>
		</method>
	</class>

	<!---
		@keywords final
		This class defines a grid column that shows formatted date and time
		property values. When a cell in the column changes to edit mode, then the cell
		will be replaced by a date and time picker. wcfGridDateTime instances may only
		be declared as immediate children of instances of {@link wcfObjectGrid}.
		
		The following example demonstrates the declaration of an instance of wcfGridDateTime.
		The column will display the date and time values for the property instances named "startdate"
		found in the row objects.
		
		@START_CODE
		<GridDateTime
			name="startdate"
			propertyName="startdate"
			editable="true"
			text="${mktMarketingResources.startDate}"/>
		@END_CODE
	-->
	<class name="wcfGridDateTime" extends="wcfGridColumn" width="135">
		<!---
			When true, the time of day will default to 23:59:59:999 when the time picker is first enabled.  
			Otherwise start of day is used 00:00:00:001. 
		-->
		<attribute name="endOfDay" type="boolean" value="false"/>
		<!---
			@keywords private
			The name of the class whose instance will be used to display the datetime value
			of the associated property. The default is {@link wcfGridDateTimeViewer}.
		 -->
		<attribute name="cellViewerClass" value="wcfGridDateTimeViewer"/>
		
		<!---
			@keywords private
			The name of the class whose instance will be used to edit the datetime value
			of the associated property. The default is {@link wcfGridDateTimeEditor}.
		 -->
		<attribute name="cellEditorClass" value="wcfGridDateTimeEditor" />
		<!---
			@keywords private
			Use "wcfColumnDateTimeEditor" to create Column Editor editor.
		-->
		<attribute name="columnEditorClass" value="wcfColumnDateTimeEditor" />
		
		<!---
			@keywords private
			This method returns the editor initialization arguments.
		-->					
		<method name="getEditorInitArgs">
			<![CDATA[
			return {
				endOfDay: this.endOfDay
			};
			]]>
		</method>
	</class>
	
	<!--- @keywords private
	
		  wcfDateTimePicker extension for use as an editor in an object grid
	-->
	<class name="wcfGridDateTimeEditor" extends="wcfDateTimePicker" showTimeZone="false">
		<!--
			Number of pixels added to the right of a column when expanding its width
			to fit this editor. This is used to make the spacing look better.
		-->
		<attribute name="columnRightPadding" type="number" value="10"/>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			super.init();
			this.style = parent.style; 
			
			// Expands the column to fit this editor. We can safely assume the parent of a column editor is a cell.
			if(this.width > parent.column.width - this.columnRightPadding){
				parent.column.setAttribute("width", this.width + this.columnRightPadding);
			}
			this.updateBGColorDel = new lz.Delegate(this, "updateBGColor");	
			this.updateBGColor();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
		<![CDATA[
			if (this["updateBGColorDel"]) {
				this.updateBGColorDel.unregisterAll();
				delete this.updateBGColorDel;
			}
			super.destroy();
		]]>
		</method>
				
		<!--- @keywords private  -->
		<handler name="onvisible">
			<![CDATA[
			if(this.visible) {
				// Expands the column to fit this editor. We can safely assume the parent of a column editor is a cell.
				if(this.width > parent.column.width - this.columnRightPadding){
					parent.column.setAttribute("width", this.width + this.columnRightPadding);
				}
			}
			
			]]>
		</handler>			
		
		<!--- @keywords private  -->
		<handler name="onwidth">
			<![CDATA[
			if(this.visible && this.width > parent.column.width - this.columnRightPadding){
				parent.column.setAttribute("width", this.width + this.columnRightPadding);
			}
			]]>
		</handler>
			
		<!---
			@keywords private
			This method updates the background and border color of the editor. 
		-->		
		<method name="updateBGColor" args="e=null"><![CDATA[		
			this.updateBGColorDel.unregisterAll();
			this.updateBGColorDel.register(parent.column, "onvisible");

			if (parent.column.visible) {
				var c = this.style.forminputdisabledbgcolor;
				var b = this.style.disabledbordercolor;
				if (parent.row.selected) {
					if (parent.row.parent.activated) {
						c = this.style.forminputdisabledselectedbgcolor;
						b = this.style.disabledselectedbordercolor;
					} else {							
						c = this.style.forminputdisabledinactiveselectedbgcolor;
						b = this.style.disabledinactiveselectedbordercolor;
					}
				} else  if (parent.row.mouseIn) {
					c = this.style.forminputdisabledhoverbgcolor;
					b = this.style.disabledhoverbordercolor;
				}
				if (c != this.dpview.datepicker.normal_view.dateview.datestr.disabledBGColor) {
					this.dpview.datepicker.normal_view.dateview.datestr.setAttribute("disabledBGColor", c);
				}
				if (b != this.dpview.datepicker.normal_view.dateview.datestr.disabledBorderColor) {
					this.dpview.datepicker.normal_view.dateview.datestr.setAttribute("disabledBorderColor", b);
				}
				if (c != this.tpview.timepicker.timeInput.timeText.disabledBGColor) {
					this.tpview.timepicker.timeInput.timeText.setAttribute("disabledBGColor", c);
				}
				if (c != this.tpview.timepicker.timeInput.timeText.disabledBorderColor) {
					this.tpview.timepicker.timeInput.timeText.setAttribute("disabledBorderColor", b);
				}
				this.updateBGColorDel.register(parent.row, "onselected");
				this.updateBGColorDel.register(parent.row, "onmouseIn");
				this.updateBGColorDel.register(parent.row.parent, "onactivated");
			}
			]]>
		</method>
		
	</class>
	
	<!--- @keywords private -->
	<class name="wcfGridDateTimeViewer" extends="wcfGridTextViewer">
		<method name="getDisplayValue">
			return wcfDateUtil.formatUI(wcfDateUtil.parse(this.property.value, wcfDateUtil.DATE_TIME_FORMAT), wcfDateUtil.UI_DATE_TIME_FORMAT);
		</method>
		
		<method name="updateValue" args="e=null">
			if (this.text != this.getDisplayValue()) {
				this.setAttribute("text", this.getDisplayValue());
			}
		</method>
		<!---
			@keywords private
			This handler will update the date and time field if the user changes their date format preference
		-->
		<handler name="preferenceChanged" reference="preferenceManager" args="preference">
			<![CDATA[
				//if this event is for the CMCDateFormat preference
				if ((preference == "CMCDateFormat" || preference == "CMCTimeFormat")  && this.property != null && this.property["value"]) {
					this.updateValue();
				}
			]]>
		</handler>
	</class>

	<!---
		@keywords final
		This class defines a grid column that shows formatted date
		property values. When a cell in the column changes to edit mode, then the cell
		will be replaced by a date picker. wcfGridDate instances may only
		be declared as immediate children of instances of {@link wcfObjectGrid}.
		
		The following example demonstrates the declaration of an instance of wcfGridDate.
		The column will display the date values for the property instances named "startdate"
		found in the row objects.
		
		@START_CODE
		<GridDate
			name="startDate"
			propertyName="startDate"
			editable="false"
			text="${promotionResources.promotionList_startDate}"
			visible="true"
			width="125"/>
		@END_CODE
	-->
	<class name="wcfGridDate" extends="wcfGridColumn" width="125">
		<!--- Indicates whether to ignore the time when saving the date string value. The default value is <code>false</code>. -->
		<attribute name="dateOnly" type="boolean" value="false"/>
		<!---
			Indicates whether to use the start or end of the day. When set to <code>true</code>, 23:59:59:999 is saved
			to the server as the end of the day. If set to <code>false</code>, 00:00:00:001 is used as the start of the day.
		-->
		<attribute name="endOfDay" type="boolean" value="false"/>
		<!---
			@keywords private
			The name of the class whose instance will be used to display the date value
			of the associated property. The default is {@link wcfGridDateViewer}.
		-->
		<attribute name="cellViewerClass" value="wcfGridDateViewer"/>
		
		<!---
			@keywords private
			The name of the class whose instance will be used to edit the date value
			of the associated property. The default is {@link wcfGridDateEditor}.
		-->
		<attribute name="cellEditorClass" value="wcfGridDateEditor"/>
		<!---
			@keywords private
			Use "wcfColumnDateEditor" to create Column Editor editor.
		-->
		<attribute name="columnEditorClass" value="wcfColumnDateEditor"/>
		
		<!---
			@keywords private
			This method returns the editor initialization arguments.
		-->					
		<method name="getEditorInitArgs">
			<![CDATA[
			return {
				dateOnly: this.dateOnly,
				endOfDay: this.endOfDay
			};
			]]>
		</method>
	</class>
	
	<!---
		@keywords private
		
		wcfDatePicker extension for use as an editor in an object grid
	-->
	<class name="wcfGridDateEditor" extends="wcfDatePicker">
		<!--
			Number of pixels added to the right of a column when expanding its width
			to fit this editor. This is used to make the spacing look better.
		 -->
		<attribute name="columnRightPadding" type="number" value="10"/>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			super.init();
			this.style = parent.style; 
			
			// Expands the column to fit this editor. We can safely assume the parent of a column editor is a cell.
			if(this.width >= parent.column.width - this.columnRightPadding){
				parent.column.setAttribute("width", this.width + this.columnRightPadding);
			}
			
			this.updateBGColorDel = new lz.Delegate(this, "updateBGColor");	
			this.updateBGColor();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[	
			if (this["updateBGColorDel"]){
				this.updateBGColorDel.unregisterAll();
				delete this.updateBGColorDel;
			}
			super.destroy();			
			]]>
		</method>
		
		<!--- @keywords private -->
		<handler name="onvisible">
			<![CDATA[
			if(this.visible) {
				// Expands the column to fit this editor. We can safely assume the parent of a column editor is a cell.
				if(this.width >= parent.column.width - this.columnRightPadding){
					parent.column.setAttribute("width", this.width + this.columnRightPadding);
				}
			}
			]]>
		</handler>
		
		<!---
			@keywords private
			This method updates the background and border color of the editor.
		-->	
		<method name="updateBGColor" args="e=null"><![CDATA[		
			this.updateBGColorDel.unregisterAll();
			this.updateBGColorDel.register(parent.column, "onvisible");
			if (parent.column.visible) {
				var c = this.style.forminputdisabledbgcolor;
				var b = this.style.disabledbordercolor;
				if (parent.row.selected) {
					if (parent.row.parent.activated) {
						c = this.style.forminputdisabledselectedbgcolor;
						b = this.style.disabledselectedbordercolor;
					} else {							
						c = this.style.forminputdisabledinactiveselectedbgcolor;
						b = this.style.disabledinactiveselectedbordercolor;
					}
				} else  if (parent.row.mouseIn) {
					c = this.style.forminputdisabledhoverbgcolor;
					b = this.style.disabledhoverbordercolor;
				}
				if (c != this.normal_view.dateview.datestr.disabledBGColor) {
					this.normal_view.dateview.datestr.setAttribute("disabledBGColor", c);
				}
				if (b != this.normal_view.dateview.datestr.disabledBorderColor) {
					this.normal_view.dateview.datestr.setAttribute("disabledBorderColor", b);
				}
				this.updateBGColorDel.register(parent.row, "onselected");
				this.updateBGColorDel.register(parent.row, "onmouseIn");
				this.updateBGColorDel.register(parent.row.parent, "onactivated");
			}
			]]>
		</method>
	</class>
	
	<!--- @keywords private -->
	<class name="wcfGridDateViewer" extends="wcfGridDateTimeViewer">
		<method name="getDisplayValue">
			return wcfDateUtil.formatUI(wcfDateUtil.parse(this.property.value, wcfDateUtil.DATE_TIME_FORMAT), wcfDateUtil.UI_DATE_FORMAT);
		</method>
	</class>
	
	<!---
		@keywords final
		This class defines a grid column that shows a number in bytes converted to kilobytes.
		Cells in this column are not editable. wcfGridKilobytes instances may only
		be declared as immediate children of instances of {@link wcfObjectGrid}.
		
		The following example demonstrates the declaration of an instance of wcfGridKilobytes.
		The column will display the values for the property instances named "fileSize"
		found in the row objects after converting the value from bytes to kilobytes.
		
		@START_CODE
		<GridKilobytes
			name="fileSize"
			propertyName="fileSize"
			text="${promotionResources.fileSize}"
			visible="true"
			width="125"/>
		@END_CODE
	-->
	<class name="wcfGridKilobytes" extends="wcfGridText" alignment="right" width="125" editable="false" findable="false" datatype="number">
		<!---
			@keywords private
			The name of the class whose instance is used to edit the value.
			By default, the value is null since the value is not editable.
		-->
		<attribute name="cellEditorClass" value="${null}"/>
		<!---
			@keywords private
			This column does not support a column editor.
		-->
		<attribute name="columnEditorClass" value="${null}"/>
		<!---
			@keywords private
			This method will format the property value into the display value.
			@param wcfModelObject o The model object instance this cell represents.
			@param wcfModelProperty property The model object property instance that this cell will display.
			@return string The value to be displayed by the cell.
		-->
		<method name="getCellText" args="o,property">
			<![CDATA[	
			var text = "";
			if (property["value"] != null && property.value != "") {
				var sizeInKB = Math.ceil(property.value/1024);
				text = foundationResources.replaceValues("fileUploaderKilobytes", [sizeInKB]);
			}
			return text;
			]]>
		</method>	
	</class>
	
	<!--- 
		@keywords private
		This editor is used to edit {@link wcfGridText} column
	 -->
	<class name="wcfColumnTextEditor" extends="wcfInputText" maximumHeight="300">
		<!--- 
			@keywords private
			The column being edited by {@link wcfColumnTextEditor} 
		 -->
		<attribute name="column" value="null"/>
		
		<!--- Selected objects {@link wcfModelObject} in grid -->
		<attribute name="selectedObjects" value="null"/>
		
		<!--- @keywords private -->
		<method name="getValue">
			<![CDATA[
			return this.getText();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="resetValue" args="initialValue">
			<![CDATA[
			this.setText(initialValue);
			]]>
		</method>
	</class>
	
	<!--- 
		@keywords private
		This editor is used to edit {@link wcfGridDate} column
	 -->
	<class name="wcfColumnDateEditor" extends="wcfDatePicker">
	
		<!--- 
			@keywords private
			The column being edited by {@link wcfColumnDateEditor} 
		 -->
		<attribute name="column" value="null"/>
		
		<!--- Selected objects {@link wcfModelObject} in grid -->
		<attribute name="selectedObjects" value="null"/>
		
		<!--- @keywords private -->
		<method name="getValue">
			<![CDATA[
			var dateString = this.getDateString();
			var newDate = this.getDate();
			if (newDate != null) {
				if(this.column.dateOnly) {
					dateString = wcfDateUtil.format(newDate, wcfDateUtil.DATE_ONLY_FORMAT);
				}
				else {
					dateString = (this.column.endOfDay) ? wcfDateUtil.format(newDate, wcfDateUtil.DATE_FORMAT_END) : wcfDateUtil.format(newDate, wcfDateUtil.DATE_FORMAT);
				}
			}
			return dateString;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="resetValue" args="initialValue">
			<![CDATA[
			var newDate = wcfDateUtil.parse(initialValue, wcfDateUtil.DATE_FORMAT);
			if (newDate != null) {
				this.setDate(newDate);
			}
			else {
				this.setDateString(initialValue);
			}
			]]>
		</method>
	</class>
	
	<!--- 
		@keywords private
		This editor is used to edit {@link wcfGridDateTime} column
	 -->
	<class name="wcfColumnDateTimeEditor" extends="wcfDateTimePicker" endOfDay="${this.column.endOfDay}">
	
		<!--- 
			@keywords private
			The column being edited by {@link wcfColumnDateTimeEditor} 
		 -->
		<attribute name="column" value="null"/>
		
		<!--- Selected objects {@link wcfModelObject} in grid -->
		<attribute name="selectedObjects" value="null"/>
		
		<!--- @keywords private -->
		<method name="getValue">
			<![CDATA[
			var newValue = this.dpview.datepicker.getDateString();
			var timeString = this.tpview.timepicker.getTimeString();
			if (timeString != "") {
				newValue += " " + timeString;
			}
			var newDateTime = this.getDateTime();
			if (newDateTime != null) {
				newValue = wcfDateUtil.format(newDateTime, wcfDateUtil.DATE_TIME_FORMAT);
			}
			return newValue;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="resetValue" args="initialValue">
			<![CDATA[
			var newDateTime = wcfDateUtil.parse(initialValue, wcfDateUtil.DATE_TIME_FORMAT);
			if (newDateTime != null) {
				this.setDateTime(newDateTime);
			}
			else {
				var newDate = null;
				var dateString = "";
				var timeString = "";
				if (initialValue!= null && initialValue!= "") {
					var delimitPos = initialValue.indexOf(" ");
					dateString = initialValue;
					if (delimitPos != -1) {
						dateString = initialValue.substring(0, delimitPos);
						newDate = wcfDateUtil.parse(dateString, wcfDateUtil.getDatePreferenceFormat());
						if (newDate != null) {
							timeString = initialValue.substring(delimitPos + 1);
						}
						else {
							dateString = initialValue;
						}
					}
				}
				this.dpview.datepicker.setDateString(dateString);
				this.tpview.timepicker.setTimeString(timeString);
				this.setAttribute("hasDate", newDate != null);
			}
			]]>
		</method>
	</class>
</library>
