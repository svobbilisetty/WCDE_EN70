<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2007, 2011 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->


<library>

	<!---
		<p>This is the base class of client-side validators. A validator 
		performs client-side validation on changes to object or object properties.
		There are two levels of validation, object level and property level. A validator
		is of property level if it validates values specific to a certain property. A validator
		is of object level if it validates values specific to a certain object. For example, 
		if a validator performs validation on multiple properties in a model object, it should be 
		an object-level validator. An object-level validator must be declared as an immediate 
		sub-node of an instance of {@link wcfObjectDefinition}. A property-level validator must be declared
		as an immediate sub-node of an instance of {@link wcfPropertyDefinition}.</p>
		
		<p>A single instance of {@link wcfEnablementCondition} can be declared as the child of a validator.
		If the enablement condition evaluates to <code>true</code>, then the validation will be run.
		If the enablement condition evaluates to <code>false</code>, no validation will occur.</p> 
	-->
	<class name="wcfValidator" extends="node">
		<!---  An unique identifier string for this validator within a node. -->
		<attribute name="validatorId" type="string" value=""/>
		
		<!---
			@keywords private
			the default resource bundle of validation error
		-->
		<attribute name="resourceBundle" value="${foundationResources}"/>
		
		<!--- 
			The type of this validator. Other objects and widgets can 
			use this type to associate itself with a certain number of validators. 
			This is useful for widgets to decide which validators' errors will 
			be displayed. For example, the following reference editor instance
			will display error messages generated by the validator that has type
			requiredParentCatalogValidator
			
			@START_CODE
				<ReferenceEditor
					promptText="${catalogResources.parentInMasterCatalogPrompt}"
					headerText="${catalogResources.codePrompt}"
					parentObjectTypes="CatalogGroup,Catalog"
					required="true"
					referenceObjectTypes="ChildCatalogGroup"
					allowCreate="false"
					validatorTypes="requiredParentCatalogValidator"/>
			@END_CODE
			
		-->
		<attribute name="validatorType" type="string" value=""/>
		
		<!--- 
			<p>Performs validation on the specified model object or changed property. 
			Errors may be logged by calling addValidationErrror on the object or on a specific 
			property. This method is called when the object or property that this validator
			is associated with is changed. This method is no op. It should be overriden to 
			provide concrete validation logic.</p>
			
			<p>Implementators of this method are responsible for checking the result of
			{@link wcfValidator#isEnabled} to ensure it is <code>true</code> before performing
			any validation logic. If the result returned is <code>false</code> any previous validation
			errors should be removed using {@link wcfModelObject#clearValidationError} or
			{@link wcfModelProperty#clearValidationError}.</p>
			
			@see wcfModelObject#addValidationError
			@see wcfModelProperty#addValidationError
			   
			@param wcfModelObject o the model object that is to be validated. 
			@param wcfModelProperty changedProperty the property that is just changed
		-->
		<method name="validate" args="o, changedProperty=null">
			<![CDATA[
			//Debug.write("base validator. no op with args = ", o);	
			]]>
		</method>
		
		<!---
			@keywords private
			Returns the error message of a validation error with the given 
			message key. This is a convenience method that wraps the logic
			of getting message from resource bundle. 
			 
			@param String messageKey the key to the error message in resource bundle. 
			@param Array params an array of parameters that will be replacing the place holders in 
			the error message. The index of a value in this array will be the same as that in the 
			place holder. That is, {i} will be replaced by params[i]. 
			@return an error message corresponding to the message key
			
			@see wcfResourceBundle#replaceValues
		 -->
		<method name="getErrorMessage" args="messageKey, params"><![CDATA[
			return this.resourceBundle.replaceValues(messageKey, params);
			]]>
		</method>
		
		<!---  
			@keywords private 
			This method pushes this validator into its immediateparent's attribute, an array named validators. 
			This method should not be overridden, otherwise a validator will not be registered to its parent
			object definition or property definition. 
		-->
		<method name="init">	
			<![CDATA[
			var validators = immediateparent["validators"];
			if (!validators) {
				validators = [];
				immediateparent.validators = validators;
			}
			validators.push(this);
			super.init();
			]]>
		</method>
		
		<!---
			Specifies whether or not this validator is enabled based on the current value of the
			enablement condition.
			@param wcfModelObject o the model object instance to be checked
			@return boolean <code>true</code> if there is no enablement condition defined. Otherwise the result of the
				enablement condition is returned.
		-->
		<method name="isEnabled" args="o">
			<![CDATA[
			var enabled = true;
			if(this["enablementCondition"]) {
				enabled = this.enablementCondition.isEnabled(o);
			}
			return enabled;
			]]>
		</method>
	</class>
	
	<!--- 
		This class is an object-level validator. It validates that an object must have a parent object. 
		If an object to validate does not have a parent object, an error message whose key is requiredParentMissing
		will be added to the object. 
	 -->
	<class name="wcfRequiredParentValidator" extends="wcfValidator">
		<!--- 
			The error message associated with the validation error generated by this validator
		 -->
		<attribute name="errorMessage" type="string" value="${foundationResources.requiredParentMissing.string}"/>
		
		<!--- 
			@keywords private
		 -->
		<method name="validate" args="o, property=null"><![CDATA[
			if(this.hasReferencedParent(o) || !this.isEnabled(o)){
				o.clearValidationError(this); 
			}
			else {
				o.addValidationError(this, this.errorMessage); 
			}
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns true if the given model object has a parent object. False otherwise. 
			@param ModelObject o the model object instance to be checked. 
		 -->
		<method name="hasReferencedParent" args="o"><![CDATA[
			if(!o.referenceMap){
				return false; 
			}
			
			for(var key in o.referenceMap){
				var ref = o.referenceMap[key];
				if(ref.parentObject && !ref.pendingDelete && (ref.objectDefinition.parentReference || ref.objectDefinition.collectionReference) && (!ref.getIsVersionObject() || o.getIsVersionObject())){
					return true; 
				}
			}
			
			return false;
			]]>
		</method>
	</class>

	<!--- 
		An instance of this class validates that an object has a given set of properties, and these properties
		all have their values set. The validation will stop at the first property that is missing
		or does not have its value set. A validation error whose key is requiredPropertyMissing
		will be added to the property. 
	 -->
	<class name="wcfObjectPropertiesSetValidator" extends="wcfValidator">
		<!--- 
			The list of names of the properties to be checked. The names are separated by 
			comma. This is a required attribute.
		 -->
		<attribute name="propertyNames" type="string" value=""/>
		
		<!---
			@keywords private 
			The list of names of the properties to be checked. This attribute will be 
			derived with attribute propertyNames, therefore it should not be 
			updated directly. 
		-->
		<attribute name="propertyNameList" value="${[]}"/>
		
		<!--- @keywords private -->
		<handler name="oninit"><![CDATA[
			this.updatePropertyNameList(); 
			]]>
		</handler>
		
		<!--- @keywords private -->
		<handler name="onpropertyNames"><![CDATA[
			this.updatePropertyNameList(); 
			]]>
		</handler>
		
		<!--- 
			@keywords private
			
			Updates the attribute propertyNameList based on the value of the attribute
			propertyNames. 
		 -->
		<method name="updatePropertyNameList"><![CDATA[
			this.propertyNameList = wcfStringUtil.splitAndTrim(this.propertyNames, ",");		
			]]>
		</method>
		
		<!--- 
			@keywords private
		 -->
		<method name="validate" args="o, property=null"><![CDATA[
			var enabled = this.isEnabled(o);

			for(var i = 0; i < this.propertyNameList.length; ++i){
				var property = o.getProperty(this.propertyNameList[i]); 
				if(property) {
					if(enabled && wcfStringUtil.isBlankString(property.value)) {
						property.addValidationError(this, this.getErrorMessage("requiredPropertyMissing", [property.propertyDefinition.getDisplayName()]));
						break;
					}
					else {
						property.clearValidationError(this);
					}
				}
			}
			]]>
		</method>
	</class>
	
	<!---  
		@keywords private
		This validator syncs the based on version name between the version and the primary object.  The basedOnVersionName property value
		of the primary object will be updated if the user updates the versionName of a version that is currently the based version.   
	 -->
	<class name="wcfSyncBasedOnVersionValidator" extends="wcfValidator">
	
		<!--- @keywords private -->
		<method name="validate" args="o, changedProperty=null">
			<![CDATA[
			if(!o || !changedProperty){
				return; // nothing to validate
			}
			
			if (o.getPropertyValue("isBasedOnVersion") == "true" && o.parentObject.getPropertyValue("basedOnVersionName") != changedProperty.value) {
				var basedOnVersionNameProp = o.parentObject.getProperty("basedOnVersionName");
				basedOnVersionNameProp.setAttribute("value", changedProperty.value);
			}
			]]>
		</method>
	</class>
	
	<!---
		<p>This is a property level validator that ensures that a property has a value. This validator
		will be added automatically to a property definition if the {@link wcfPropertyDefinition#required}
		attribute is set to <code>true</code>. If you need to explicitly include this validator in a property definition,
		then do not specify the <code>required</code> attribute.</p>

		<p>If you need to add an enablement condition to this validator, then you will need to declare it
		explicitly. The following example declares a validator that ensures that the property has a value
		when the "format" property is set to "Sms".</p>
		
		@START_CODE
			<RequiredPropertyValidator validatorId="contentRequiredPropertyValidator">
				<EnablementCondition propertyName="format" enablementValue="Sms"/>
			</RequiredPropertyValidator>
		@END_CODE
	 -->
	<class name="wcfRequiredPropertyValidator" extends="wcfValidator">
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method name="checkPropertyValue" args="propertyDefinition, value">
			<![CDATA[
			var valid = true;
			if (wcfStringUtil.isBlankString(value)) {
				valid = false;
			}
			return valid;
			]]>
		</method>
	
		<!--- @keywords private -->
		<method name="validate" args="o, changedProperty=null">
			<![CDATA[
			if(!changedProperty){
				return; // nothing to validate
			}
			
			if(this.isEnabled(o)) {
				var propertyDef = changedProperty['propertyDefinition'];
				if(propertyDef) {
					if(wcfStringUtil.isBlankString(changedProperty.value)) {
						changedProperty.addValidationError(this, this.getErrorMessage("requiredPropertyMissing", [propertyDef.getDisplayName()]));
						return false;
					}
				}
			}
			changedProperty.clearValidationError(this);
			]]>
		</method>
	</class>
	
	<!--- 		
		An instance of this class ensures that at least one of the required child objects exist. Required child objects
		are defined in this validator by specifying the objectPath. This is an object-level validator, therefore it is 
		must be a child of the wcfObjectDefinition class.  If no child object matching the given object path is found, 
		an error message will be added to the object. The following example declares a validator that ensures the model 
		object it belongs to has a child object that matches path ChildCatentry. If validation fails, the given error 
		message will be associated with the validation error. 
		
		@START_CODE
			<RequiredChildObjectValidator 
				validatorId="reqChildValidator" 
				objectPath="ChildCatentry" 
				errorMessage="${mktMarketingResources.noProductsSelected}"/>
		@END_CODE
		
	 -->
	<class name="wcfRequiredChildObjectValidator" extends="wcfValidator">
		<!--- 
			The object path that describes required child objects. 
		 -->
		<attribute name="objectPath" type="string"/>
		
		<!--- 
			The error message to be added to an object when the object 
			does not have at least one matching child object.
		 -->
		<attribute name="errorMessage" value="" type="string"/>
		<!--- 
			The name of a property to be verified in the child object. If this attribute is
			specified, then in addition to checking for an existence of a matching child object, the validator
			will also ensure that the property has has a value. 
		 -->
		<attribute name="propertyName" type="string" value="${null}"/>
		
		<!--- 
			@keywords private
		 -->
		<method name="validate" args="o, property=null">
			<![CDATA[
			if(this.isEnabled(o)) {
				var childObjects = o.getObjects(this.objectPath);
				if (this.propertyName == null) {
					if (childObjects == null || childObjects.length <= 0) {
						o.addValidationError(this, this.errorMessage);
						return;
					}
				}
				else {
					var childDefs = o.objectDefinition.getChildDefinitions(objectPath);
					if (childObjects == null || childObjects.length <= 0) {
						o.addValidationError(this, this.getRequiredPropertyMessage(o));
						return;
					}
					for (var i = 0; i < childObjects.length; i++) {
						if(wcfStringUtil.isBlankString(childObjects[i].getPropertyValue(this.propertyName))){
							o.addValidationError(this, this.getRequiredPropertyMessage(o));
							return;  
						}
					}
				}
			}
			o.clearValidationError(this);
			]]>
		</method>
		
		<!--- 
			@keywords private
		 -->
		<method name="getRequiredPropertyMessage" args="o">
			<![CDATA[
			var message = this.errorMessage;
			if (message == "") {
				var childDefs = o.objectDefinition.getChildDefinitions(objectPath);
				var propertyDefinition = null;
				if (childDefs.length > 0) {
					propertyDefinition = childDefs[0].getPropertyDefinition(o, this.propertyName);
				}
				var propertyDisplayName = propertyDefinition ? propertyDefinition.getDisplayName() : this.propertyName;
				message = foundationResources.replaceValues("requiredPropertyMissing", [propertyDisplayName]);
			}
			return message;
			]]>
		</method>

	</class>
	
	<!---
		<p>This is an object level validator that ensures that the start date is not after the end date.
		No error will be reported if either the start date or end date are blank.</p>
		
		<p>If the start date and end date properties are not contained within the same object, you must 
		specify the <code>startDateObjectPath</code> and <code>endDateObjectPath</code> attributes so 
		that the validator can resolve those child objects. To ensure that the validator is called when the 
		start date and end date properties change, set {@link wcfPropertyDefinition#forceParentValidation} 
		to "true".
				
		<p>The following example declares a validator that checks if the property with name "endDate" contains
		a value that is later than the value in the property with name "startDate".</p>
		
		@START_CODE
			<StartDateEndDateValidator startDatePropertyName="startDate" endDatePropertyName="endDate"/>
		@END_CODE
	 -->
	<class name="wcfStartDateEndDateValidator" extends="wcfValidator">
		<!---
			The object path to the object containing {@link wcfStartDateEndDateValidator#startDatePropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<attribute name="startDateObjectPath" type="string" value=""/>
		<!---
			The name of the property that contains the start date. The default value is "startDate".
		-->
		<attribute name="startDatePropertyName" type="string" value="startDate"/>
		<!---
			The object path to the object containing {@link wcfStartDateEndDateValidator#endDatePropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<attribute name="endDateObjectPath" type="string" value=""/>
		<!---
			The name of the property that contains the end date. The default value is "endDate".
		-->
		<attribute name="endDatePropertyName" type="string" value="endDate"/>
		
		<!---
			@keywords private 
		 -->
		<method name="validate" args="o, property=null">
			<![CDATA[
			if(!o){
				return; // nothing to validate
			}

			var startO = o.getObject(this.startDateObjectPath);
			var endO = o.getObject(this.endDateObjectPath);

			if(startO && endO) {
				var startDateProperty = startO.getProperty(this.startDatePropertyName);
				var endDateProperty = endO.getProperty(this.endDatePropertyName);

				var clearError = true;
				
				if(this.isEnabled(o)) {
					var startDate = wcfDateUtil.parse(startDateProperty.value, wcfDateUtil.DATE_TIME_FORMAT);
					var endDate = wcfDateUtil.parse(endDateProperty.value, wcfDateUtil.DATE_TIME_FORMAT);
					
					if (startDateProperty.enabled && endDateProperty.enabled && startDate != null && endDate != null && startDate.getTime() > endDate.getTime()) {
						endDateProperty.addValidationError(this, this.getErrorMessage("endDateMustBeAfterStartDate", []));
						clearError = false;
					}
				}
				
				if(clearError) {
					endDateProperty.clearValidationError(this);
				}
			}
			]]>
		</method>
	</class>

	<!--- 
		<p>This is an object level validator that ensures that the start time is not after the end time.
		No error will be reported if either the start time or end time are blank.</p>
		
		<p>If the start date and end date properties are not contained within the same object, you must 
		specify the <code>startTimeObjectPath</code> and <code>endTimeObjectPath</code> attributes so 
		that the validator can resolve those child objects. To ensure that the validator is called when the 
		start time and end time properties change, set {@link wcfPropertyDefinition#forceParentValidation} 
		to "true".
		
		<p>The following example declares a validator that checks if the property with name "endTime" contains a value that 
		is later than the value in the property with name "startTime".</p>
		
		@START_CODE
			<StartTimeEndTimeValidator startTimePropertyName="startTime" endTimePropertyName="endTime"/>		
		@END_CODE
	 -->
	<class name="wcfStartTimeEndTimeValidator" extends="wcfValidator">
		<!---
			The object path to the object containing {@link wcfStartTimeEndTimeValidator#startTimePropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<attribute name="startTimeObjectPath" type="string" value=""/>
		<!---
			The name of the property that contains the start time. The default value is "startTime".
		-->
		<attribute name="startTimePropertyName" type="string" value="startTime"/>
		<!---
			The object path to the object containing {@link wcfStartTimeEndTimeValidator#endTimePropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<attribute name="endTimeObjectPath" type="string" value=""/>
		<!---
			The name of the property that contains the end time. The default value is "endTime".
		-->
		<attribute name="endTimePropertyName" type="string" value="endTime"/>
		
		<!---
			@keywords private
		 -->
		<method name="validate" args="o, property=null">
			<![CDATA[
			if(!o){
				return; // nothing to validate
			}

			var startO = o.getObject(this.startTimeObjectPath);
			var endO = o.getObject(this.endTimeObjectPath);

			if(startO && endO) {
				var startTimeProperty = startO.getProperty(this.startTimePropertyName);
				var endTimeProperty = endO.getProperty(this.endTimePropertyName);
				
				var clearError = true;
				
				if(this.isEnabled(o)) {
					var startTime = wcfDateUtil.parse(startTimeProperty.value, wcfDateUtil.TIME_FORMAT);
					var endTime = wcfDateUtil.parse(endTimeProperty.value, wcfDateUtil.TIME_FORMAT);
					
					if (startTimeProperty.enabled && endTimeProperty.enabled && startTime != null && endTime != null && startTime.getTime() > endTime.getTime()) {
						endTimeProperty.addValidationError(this, this.getErrorMessage("endTimeMustBeAfterStartTime", []));
						clearError = false;
					}
				}
				
				if(clearError) {
					endTimeProperty.clearValidationError(this);
				}
			}
			]]>
		</method>
	</class>
	
	<!---
		<p>This object level validator ensures that two numeric properties represent a valid range. If both properties
		have values, then it ensures that the start number property is not greater than the end number property.
		No error will be reported if either property is left blank.</p>
		
		<p>If the start number and end number properties are not contained within the same object, you must 
		specify the <code>startNumberObjectPath</code> and <code>endNumberObjectPath</code> attributes so 
		that the validator can resolve those child objects. To ensure that the validator is called when the 
		start number and end number properties change, set {@link wcfPropertyDefinition#forceParentValidation} 
		to "true".
	
		<p>The following example demonstrates the declaration of a validator that checks that value entered for the
		"amount1" property is not greater than the value entered for the "amount2" property.</p>
		
		@START_CODE
			<NumberRangeValidator 
				startNumberPropertyName="amount1" 
				endNumberPropertyName="amount2"/>
		@END_CODE
	 -->
	<class name="wcfNumberRangeValidator" extends="wcfValidator">
		<!--- 
			The error message to be displayed when the end number property is less than the start number property. 
		 -->
		<attribute name="errorMessage" type="string" value="${foundationResources.secondValueMustBeGreaterThanFirstValue.string}"/>
		<!---
			The object path to the object containing {@link wcfNumberRangeValidator#startNumberPropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<attribute name="startNumberObjectPath" type="string" value=""/>
		<!---
			The property name of the property that contains the start number. The default value is "startNumber".
		-->
		<attribute name="startNumberPropertyName" type="string" value="startNumber"/>
		<!---
			The object path to the object containing {@link wcfNumberRangeValidator#endNumberPropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<attribute name="endNumberObjectPath" type="string" value=""/>
		<!---
			The property name of the property that contains the end number. The default value is "endNumber".
		-->
		<attribute name="endNumberPropertyName" type="string" value="endNumber"/>
		
		<!---
			@keywords private
		 -->
		<method name="validate" args="o, property=null">
			<![CDATA[
			if(!o){
				return; // nothing to validate
			}
			
			var startO = o.getObject(this.startNumberObjectPath);
			var endO = o.getObject(this.endNumberObjectPath);
			
			if(startO && endO) {				
				var startNumberProperty = startO.getProperty(this.startNumberPropertyName);
				var endNumberProperty = endO.getProperty(this.endNumberPropertyName);
				
				var clearError = true;
				
				if(this.isEnabled(o)) {
					if (startNumberProperty.enabled && endNumberProperty.enabled && startNumberProperty.value != null && endNumberProperty.value != null  && startNumberProperty.value != "" && endNumberProperty.value != "" && Number(startNumberProperty.value) > Number(endNumberProperty.value)) {
						endNumberProperty.addValidationError(this, this.errorMessage);
						clearError = false;
					}
				}
				
				if(clearError) {
					endNumberProperty.clearValidationError(this);
				}
			}
			]]>
		</method>
	</class>
	
	<!--- 
		<p>This is a property level validator that ensures that the length of a property value is less than a specified maximum.
		This validator will be added automatically to a property definition if the {@link wcfPropertyDefinition#maximumSize}
		attribute is set. If you need to explicitly include this validator in a property definition,
		then do not specify the <code>maximumSize</code> attribute.</p>

		<p>If you need to add an enablement condition to this validator, then you will need to declare it
		explicitly. The following example declares a validator that ensures that the property value does not exceed 160
		characters when the "format" property is set to "Sms".</p>
		
		@START_CODE
			<PropertySizeValidator maximumSize="160">
				<EnablementCondition conditionId="condition2" propertyName="format" enablementValue="Sms"/>
			</PropertySizeValidator>
		@END_CODE
	 -->
	<class name="wcfPropertySizeValidator" extends="wcfValidator">
		<!---
			The maximum size allowed for the property value. This attribute is required.
		-->
		<attribute name="maximumSize" type="number"/>
		
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method name="checkPropertyValue" args="propertyDefinition, value">
			<![CDATA[
			var valid = true;
			var propertySize = wcfLangUtil.getUTF8ByteCount(value); 
			if (this.maximumSize > 0 && propertySize > this.maximumSize) {
				valid = false;
			}
			return valid;
			]]>
		</method>
	
		<!---
			@keywords private
		-->
		<method name="validate" args="o, changedProperty=null">
			<![CDATA[
			if(!o || !changedProperty){
				return; // nothing to validate
			}
			
			if(this.isEnabled(o)) {
				verifyMaximumSizeNotExceeded(changedProperty, this.maximumSize);
			}
			else {
				changedProperty.clearValidationError(this);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="verifyMaximumSizeNotExceeded" args="property, maxSize">
			<![CDATA[
			var isNotExceeded = true;
			if(property && property.value) {
				var propertyDef = property.propertyDefinition;
				var value = wcfLangUtil.getUTF8ByteCount(property.value); 
				if(maxSize > 0 && value > maxSize){
					if(propertyDef.format){
						property.addValidationError(this, this.getErrorMessage("propertySizeTooLargeWithFormat", [propertyDef.getDisplayName(), maxSize, propertyDef.format]));
					}else{
						property.addValidationError(this, this.getErrorMessage("propertySizeTooLarge", [propertyDef.getDisplayName(), maxSize]));
					}
					isNotExceeded = false;
				}
			}
			if (isNotExceeded) {
				property.clearValidationError(this);
			}
			return isNotExceeded;
			]]>
		</method>

	</class>
	
	<!--- 
		<p>This is a property level validator that ensures that the decimal places of a property value do not exceed the specified maximum.
		This validator will be added automatically to a property definition if the {@link wcfPropertyDefinition#maximumDecimalPlaces}
		attribute is set. </p>

		
		@START_CODE
			<DecimalPlacesValidator maximumDecimalPlaces="5" validatorId="catDecimalValueSizeValidator"/>
		@END_CODE
	 -->
	
	<class name="wcfDecimalPlacesValidator" extends="wcfValidator">
		<!---
			The maximum decimal places allowed for the property value. 
		-->
		<attribute name="maximumDecimalPlaces" type="number"/>
		
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		
		<method name="checkPropertyValue" args="propertyDefinition, value">
			<![CDATA[
			var valid = true;
			var propertyDecimalPlaces = this.getDecimalPlaces(value);
			if (propertyDecimalPlaces > this.maximumDecimalPlaces) {
				valid = false;
			}
			return valid;
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method name="validate" args="o, changedProperty=null">
			<![CDATA[
			if(!o || !changedProperty){
				return; // nothing to validate
			}
			
			if(this.isEnabled(o)){
				var message = null;
				var propertyDecimalPlaces = this.getDecimalPlaces(changedProperty.value);
				if (propertyDecimalPlaces > this.maximumDecimalPlaces) {
					message = foundationResources.replaceValues("invalidNumberDecimalPlaces", [changedProperty.propertyDefinition.getDisplayName(), this.maximumDecimalPlaces]);
				}				
				
				if (message == null){
					changedProperty.clearValidationError(this);
				}
				else {
					changedProperty.addValidationError(this, message);
				}
			}
			else {
				changedProperty.clearValidationError(this);
			}	
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getDecimalPlaces" args="value">
			<![CDATA[
			
			value = wcfStringUtil.trim(value);	
			
			// Ensure that the value has a decimal component.
			if (value.indexOf('.') == -1 || value.length == 0 || !wcfStringUtil.isNumber(value))
			{
				return -1;
			}
			
			var skippingTrailingZeros = true;
			var decimalPlaces = 0;
			for (var i = value.length - 1; i >= 0; i--) {
				var c = value.charAt(i);
				if (c == ".") {
					break;
				}
				if (skippingTrailingZeros && value.charAt(i) != "0") {
					skippingTrailingZeros = false;
				}
				if (!skippingTrailingZeros) {
					decimalPlaces++;
				}
			}
			return decimalPlaces;
			]]>
		</method>

	</class>
	
	
	
	
		<!---
		<p>This is a property level validator that ensures that the property value 
		does not contain any of the characters specified in the invalidCharacters property.</p>
		
		<p>The following example demonstrates the declaration of a validator that checks that 
		the property value does not contain the specified characters in the "invalidCharacters" attribute.</p>
			
		@START_CODE
			<PropertyStringValidator
				errorMessage="${catalogResources.offerPriceMinimumQuantityWarning}"
				invalidCharacters="&?=#/_ "/>
		@END_CODE
	-->
	<class name="wcfPropertyStringValidator" extends="wcfValidator">
		<!--- 
			The characters which needs to be excluded.  If this character appears in the property
			of the object then the error message will appear.
		-->
		<attribute name="invalidCharacters" type="string"/>
		
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method name="checkPropertyValue" args="propertyDefinition, value">
			<![CDATA[
			var valid = true;
			if (wcfStringUtil.isBlankString(value)) {
				valid = false;
			}
			return valid;
			]]>
		</method>
	
		<!--- 
			@keywords private
		 -->
		<method name="validate" args="o, changedProperty=null">
			<![CDATA[
			if(!changedProperty){
				return; // nothing to validate
			}
			
			if (this.isEnabled(o))
			{
				var propertyDef = changedProperty['propertyDefinition'];
				if(propertyDef) {
					var value = changedProperty.value;
					for (var j = 0; j < this.invalidCharacters.length; j++)
					{
						if (this.containsInvalidCharacter(value, this.invalidCharacters.charAt(j)))
						{
							if (this.invalidCharacters.charAt(j) == " ")
							{
								changedProperty.addValidationError(this, getErrorMessage("invalidBlankCharacter", []));
								return false;
							}					
							changedProperty.addValidationError(this, getErrorMessage("invalidCharacter", [this.invalidCharacters.charAt(j)]));
							return false;
						}
					}
				}
			}
			changedProperty.clearValidationError(this);
			return true;
			]]>
		</method>
		
		<!---
			@keywords private
		 -->
		<method name="containsInvalidCharacter" args="sText, char"><![CDATA[
			return (sText.indexOf(char) != -1);
			]]>
		</method>				
	</class>

	
	
	
	<!--- 
		<p>This is a property level validator that ensures that a property value is within the specified range.
		This validator will be added automatically to a property definition if the {@link wcfPropertyDefinition#minValue}
		or {@link wcfPropertyDefinition#maxValue} attributes are set. If you need to explicitly include this validator in a property definition,
		then do not specify the <code>minValue</code> or <code>maxValue</code> attributes.</p>
	 -->
	<class name="wcfPropertyRangeValidator" extends="wcfValidator">
		<!---
			The minimum allowed value. This attribute is optional.
		-->
		<attribute name="minValue" type="number" value="null"/>
		
		<!---
			The maximum allowed value. This attribute is optional.
		-->
		<attribute name="maxValue" type="number" value="null"/>
		
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method name="checkPropertyValue" args="propertyDefinition, value">
			<![CDATA[
			var valid = true;
			if (isNumeric(value)) {
				value = parseFloat(value);
				if (this.minValue != null) {
					if (value < parseFloat(this.minValue)) {
						valid = false;
					}
				}
				
				if (this.maxValue != null) {
					if (value > parseFloat(this.maxValue)) {
						valid = false;
					}
				}
			}
			return valid;
			]]>
		</method>
	
		<!---
			@keywords private
		 -->
		<method name="validate" args="o, changedProperty=null">
			<![CDATA[
			if(!o || !changedProperty){
				return; // nothing to validate
			}

			if(this.isEnabled(o)) {
				var verified = true;
				if (this.minValue != null) {
					verified = verifyMinRangeNotExceeded(changedProperty, this.minValue);
				}
				if (this.maxValue != null && verified) {
					verified = verifyMaxRangeNotExceeded(changedProperty, this.maxValue);
				}
			}
			else {
				changedProperty.clearValidationError(this);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="verifyMinRangeNotExceeded" args="property, minValue">
			<![CDATA[		
			if(!property || !property.value){
				return true;
			}

			var value = property.value;
			if(isNumeric(value)==true){
				value = parseFloat(value);
				minValue = parseFloat(minValue);	
				if(value < minValue){
					property.addValidationError(this, getErrorMessage("propertyValueTooSmall", [property.propertyDefinition.getDisplayName(), minValue]));
					return false;
				}
			}
			property.clearValidationError(this);
			return true;			
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="verifyMaxRangeNotExceeded" args="property, maxValue">
			<![CDATA[
			
			if(!property || !property.value){
				return true;
			}

			var value = property.value;
			if(isNumeric(value)==true){
				value = parseFloat(value);
				maxValue = parseFloat(maxValue);
				if(value > maxValue){
					property.addValidationError(this, getErrorMessage("propertyValueTooLarge", [property.propertyDefinition.getDisplayName(), maxValue]));
					return false;
				}
			}
			property.clearValidationError(this);
			return true;
			
			
			]]>
		</method>
		
		<!---
			@keywords private
			Determines if a given piece of text is numeric. 
			@param string sText the text to be checked.
			@return true if the given text is numeric. False otherwise. 
		 -->
		<method name="isNumeric" args="sText">
			<![CDATA[
			var validChars = "0123456789-.$'";
			var isNumber = true;
			for (var i = 0; i < sText.length && isNumber == true; i++) {
				var c = sText.charAt(i);
				if (validChars.indexOf(c) == -1) {
					isNumber = false;
				}
			}
			return isNumber;				
			]]>
		</method>		

	</class>
	
	<!---  
		@keywords private
		
		This validator is of object level. When a number is entered with number of decimal places more than than the 
		standard of the active currency, a warning message will be triggered to notify the user. Active 
		currency is resolved based on the logic described below:
		1) if attribute "currencyPropertyName" is supplied, the currency is the value from the {@link wcfModelProperty} with that name
		2) if attribute "currencyPropertyName" is provided but it does not return a valid currency, skip validation process
		3) if attribute "currencyPropertyName" is not provided, validate by the store default currency.
		
		Instances of this validator may only be declared as direct children of {@link wcfObjectDefinition}.
	 -->
	<class name="wcfCurrencyFormatValidator" extends="wcfValidator">
		<!---
			The object path to the object containing {@link wcfCurrencyFormatValidator#currencyPropertyName}.
			If the object path resolves to more than one object, the first object will be used. If no object
			path is specified, the current object will be used.
		-->
		<attribute name="currencyObjectPath" type="string" value=""/>
		<!---
			Indicates that the parent property of the {@link wcfCurrencyFormatValidator#currencyPropertyName}
			retrieved must be the parent primary object.  If it is false it returns the immediate parent. 
		-->
		<attribute name="resolvePrimaryParent" type="boolean" value="false"/>
		<!-- 
			The name of the {@link wcfModelProperty} that contains the currency code used to validate the monetary value. 
			If no property name is specified, then the store default currency will be used.
		-->
		<attribute name="currencyPropertyName" type="string"/>
		<!-- 
			The currency code used to validate the monetary value. This value is ignored if
			<code>currencyPropertyName</code> is specified.
		-->
		<attribute name="currencyCode" type="string"/>
		<!-- 
			The name of the {@link wcfModelProperty property} that contains the monetary value to be validated.
			This is a required attribute.
		-->
		<attribute name="valuePropertyName" type="string"/>
		
		<!--- @keywords private -->
		<method name="validate" args="o, property=null">
			<![CDATA[
			var modelPropertyValue = o.getProperty(this.valuePropertyName);
			
			if(this.isEnabled(o)) {
				var isValid = true;
				var numDecPlaces;
				var val = modelPropertyValue.value;
				var numDecPlaces = this.getNumDecimalPlaces(o);
				if (numDecPlaces != null) {
					var isNum = wcfStringUtil.isNumber(val);
					if (isNum) {
						var dec = "";
						var decpos = val.indexOf(".");
						if (decpos >= 0) {
							var zeropos = val.length;
							for (var i = val.length-1; i > decpos; i--) {
								if (val.charAt(i) == "0") {
									zeropos = i;
								} else {
									break;
								}
							}
							if (zeropos < val.length) {
								val = val.substring(0, zeropos);
							}
							dec = val.substring(decpos+1);
						}
						if (dec.length > numDecPlaces){
							isValid = false;
						}
					}
				}
				if(!isValid) {
					modelPropertyValue.addValidationError(this, getErrorMessage("invalidNumberDecimalPlaces",[modelPropertyValue.propertyDefinition.getDisplayName(), numDecPlaces]));
					return;
				}
			}
			modelPropertyValue.clearValidationError(this);
			]]>
		</method>
		<!--- @keywords private -->
		<method name="getNumDecimalPlaces" args="o">
			<![CDATA[
			var num = null;
			var currencyCode = null;

			if (this["currencyPropertyName"]) {
				var currencyO = o;

				if (this["currencyObjectPath"] && this.currencyObjectPath!="") {
					if (this["resolvePrimaryParent"]) {
						// Get the parent primary object for the current object
						var topO = o.getParentPrimaryObject();
						if (topO) {
							currencyO = topO.getObject(this.currencyObjectPath);
						}										
					}
					else {
						currencyO = o.getObject(this.currencyObjectPath);
					}
				}

				currencyCode = currencyO.getPropertyValue(this.currencyPropertyName);
			 } 
			 else if (this["currencyCode"]) {
				currencyCode = this.currencyCode;
			}
			 else {
				var storeConfig = wcfContextUtil.findStoreConfig(o);
				if (storeConfig != null
					&& storeConfig.defaultCurrency != null) {
					currencyCode = storeConfig.defaultCurrency.currencyCode;
				}
			}
			if (currencyCode != null) {
			 	num = wcfGlobalizationUtil.getCurrencyDecimalPlaces(currencyCode);
			}
			return num;
			]]>
		</method>
	</class>
	<!---  
		@keywords private
		
		This validator is of property level. It validates that a given property's value conforms 
		to the type defined the corresponding property definition. If there is no property definition, 
		the validation will not be run. It supports three types: 
		  number: the property value must be of valid decimal number. 
		  integer: the property value must be of valid integer
		  date: the property value must be follow the format wcfDateUtil.DATE_FORMAT
		  email: the property value must be a valid e-mail address following RFC822 rules
		  
		if the format of the property value is not valid, an error message
		will be added to the property. 
		
		This validator is already a child of {@link wcfPropertyDefinition}
	 -->
	<class name="wcfPropertyValueTypeValidator" extends="wcfValidator">
		<!---
			@keywords private
			Return true if the specified value is valid.
		-->
		<method name="checkPropertyValue" args="propertyDefinition, value">
			<![CDATA[
			var valid = true;
			
			if (value && propertyDefinition.type != "string") {
				switch (propertyDefinition.type) {
					case "number":
						if (!wcfStringUtil.isNumber(value)) {
							valid = false;
						}
						break;
						
					case "integer":
						if (!wcfStringUtil.isInteger(value)) {
							valid = false;
						}
						break;
						
					case "date":
						if (wcfDateUtil.parse(value, wcfDateUtil.DATE_FORMAT) ==  null) {
							valid = false;
						}
						break;
						
					case "datetime":
						if (wcfDateUtil.parse(value, wcfDateUtil.DATE_FORMAT) ==  null) {
							valid = false;
						}
						break;
					
					case "time":
						if (wcfDateUtil.parseFormattedTime(value) ==  null) {
							valid = false;
						}
						break;
					
					case "currency":
						if (!wcfStringUtil.isNumber(value)) {
							valid = false;
						}
						break;
					case "email":
						if (!this.isValidEmail(value)) {
							valid = false;
						}
						break;
				}
			}
			return valid;
			]]>
		</method>

	
		<!--- @keywords private -->
		<method name="validate" args="o, changedProperty=null"><![CDATA[
			if(!o || !changedProperty){
				return; // nothing to validate
			}
			
			if(this.isEnabled(o)) {
				var propertyDef = changedProperty['propertyDefinition'];
				if(propertyDef){
					this.verifyPropertyType(changedProperty, propertyDef.type);
				}
			}
			else {
				changedProperty.clearValidationError(this);
			}
			]]>
		</method>
		 
		<!--- @keywords private -->
		<method name="verifyPropertyType" args="property, type">
			<![CDATA[
			if (property && type != "string") {
				var message = null;
				if (property.value) {
					switch (type) {
						case "number":
							if (!wcfStringUtil.isNumber(property.value)) {
								message = this.getErrorMessage("invalidNumber",[property.propertyDefinition.getDisplayName()]);
							}
							break;
							
						case "integer":
							if (!wcfStringUtil.isInteger(property.value)) {
								message = this.getErrorMessage("invalidInteger",[property.propertyDefinition.getDisplayName()]);
							}
							break;
							
						case "date":
							if (wcfDateUtil.parse(property.value, wcfDateUtil.DATE_FORMAT) ==  null) {
								message = this.getErrorMessage("invalidDate",[property.propertyDefinition.getDisplayName()]);
							}
							break;
						
						case "datetime":
							if (wcfDateUtil.parse(property.value, wcfDateUtil.DATE_FORMAT) ==  null) {
								var delimitPos = property.value.indexOf(" ");
								if (delimitPos != -1 && wcfDateUtil.parse(property.value.substring(0, delimitPos), wcfDateUtil.getDatePreferenceFormat()) != null) {
									message = this.getErrorMessage("invalidTime",[property.propertyDefinition.getDisplayName()]);
								}
								else {
									message = this.getErrorMessage("invalidDate",[property.propertyDefinition.getDisplayName()]);
								}
							}
							break;
						
						case "time":
							if (wcfDateUtil.parseFormattedTime(property.value) ==  null) {
								message = this.getErrorMessage("invalidTime",[property.propertyDefinition.getDisplayName()]);
							}
							break;
							
						case "currency":
							if (!wcfStringUtil.isNumber(property.value)) {
								message = this.getErrorMessage("invalidMonetaryValue",[property.propertyDefinition.getDisplayName()]);
							}
							break;
						case "email":
							if (!this.isValidEmail(property.value)) {
								message = this.getErrorMessage("invalidEmailAddress",[property.propertyDefinition.getDisplayName()]);
							}
							break;
					}
				}
				
				if (message == null) {
					property.clearValidationError(this);
				}
				else {
					property.addValidationError(this, message);
				}
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="isValidEmail" args="str">
			<![CDATA[
			var at = "@";
			var dot = ".";
			var space = " ";
			var idxAt = str.indexOf(at);
			var idxDot = str.indexOf(dot);
			var length = str.length;

			// Invalid if the e-mail address:
			// - does not have an "@" sign
			// - begins with the "@" sign
			// - ends with the first "@" sign
			if (idxAt==-1 || idxAt==0 || idxAt==(length-1)){
				return false;
			}

			// Invalid if the e-mail address:
			// - has no "."
			// - starts with a "."
			// - ends with a "."
			if (idxDot==-1 || idxDot==0 || str.substring(length-1,length)==dot){
				return false;
			}

			// Invalid if the e-mail address:
			// - contains more than one "@" sign
			if (str.indexOf(at,idxAt+1)!=-1){
				return false;
			}

			// Invalid if the e-mail address:
			// - has a "." preceeding or following the "@" sign
			if (str.substring(idxAt-1,idxAt)==dot || str.substring(idxAt+1,idxAt+2)==dot){
				return false;
			}

			// Invalid if the e-mail address:
			// - has no "." after the "@" sign
			if (str.indexOf(dot,idxAt+2)==-1){
				return false;
			}

			// Invalid if the e-mail address:
			// - contains spaces
			if (str.indexOf(space)!=-1){
				return false;
			}

			return true;
			]]>
		</method>
		
	</class>
	<!--- 
		@keywords private
		
		This class is an object-level validator. It validates that an upload file has been selected for a new file object.
	 -->
	<class name="wcfFileRequiredValidator" extends="wcfValidator" validatorType="fileRequiredValidator">
		<!--- 
			The error message associated with the validation error generated by this validator when there is no selected file.
		 -->
		<attribute name="errorMessage" type="string" value="${foundationResources.fileMissing.string}"/>

		<!--- 
			The error message associated with the validation error generated by this validator when the selected file is missing during file uploading or the selected file size is zero.
		 -->
		<attribute name="errorMessageForInvalidUploadFile" type="string" value="${foundationResources.uploadFileFailed.string}"/>

		<!--- 
			@keywords private
		 -->
		<method name="validate" args="o, property=null"><![CDATA[
			if(!this.isEnabled(o) || (o && (!o.objectDefinition.isFileObject || this.hasFileToUpload(o)))) {
				// Check to see if the upload file is size zero
				if (this.isFileSizeZero(o)) {
					o.addValidationError(this, this.errorMessageForInvalidUploadFile); 
				}
				else {				
					o.clearValidationError(this); 				
				}
			}
			else {	
				o.addValidationError(this, this.errorMessage); 
			}
			]]>
		</method>

		<!---
			@keywords private
			This method returns false if the object passed in as an argument is a new object and does not have 
			a file to upload, and returns true otherwise.
		-->
		<method name="hasFileToUpload" args="o"><![CDATA[
			var hasFile = true;
			if (o.newObject && (o.fileref == null || typeof(o.fileref.name) == "undefined")) {
				hasFile = false;
			}		
			return hasFile;
			]]>
		</method>

		<!---
			@keywords private
			This method returns true if the object passed in as an argument and does have 
			a file to upload but the file size is zero, and returns false otherwise.
		-->
		<method name="isFileSizeZero" args="o"><![CDATA[
			var isZeroSize = false;
			if ((o.fileref != null) && (o.fileref.size == 0)) {
				isZeroSize = true;
			}
			return isZeroSize;
			]]>
		</method>
	</class>
		
	<!---  
		@keywords private
		
		Default error message view. This view displays a given piece of error message 
		in a colored box with drop shadow. The width of the box is automatically resizable according to 
		the length of the error message. An error message view requires a target view to attach to. 
		The attribute attachTarget is used to specify this view. An error message view will be 
		attached to the position specified by the attribute "attach". 
	 -->
	<class name="wcfErrorMessageView" extends="basewindow" options="ignorelayout" placement="canvas" allowdrag="false">
		<!--- The error text to be displayed to users -->
		<attribute name="errorMessage" type="string" value=""/>
		
		<!--- True if the message allows multiple lines. False otherwise. -->
		<attribute name="multiline" type="boolean" value="true"/>

		<!--- The default opacity of this error message, ranging from 0 to 1. 0 is completely transparent. 1 is complely opaque -->
		<attribute name="defaultOpacity" type="number" value="1"/>
		
		<!---  The default duration for showing or hiding animation of this view -->
		<attribute name="duration" value="200"/>
		
		<!---  The view to which this message is attached -->
		<attribute name="attachTarget" value="${null}"/>
		
		<!---
			@keywords private
			Indicates that the deferred call to the updateLocation method has been added.
		-->
		<attribute name="updateLocationCallbackAdded" type="boolean" value="false"/>
						
		<!--- 
			The position where this error message will be attached. Only four values are supported: 
			  top: the message is on top of the attach target, arrow pointing down. 
			  bottom: the attach target is on top of the error message. The message's arrow points up. 
			  left: the attach target is to the left of the attach target, arrow pointing to the left. 
			  right: the attach target is to the right of the attach target, arrow pointing to the right. 
		-->
		<attribute name="attach" type="string" value="right"/>
		
		<!--- 
			@keywords private
			The number of pixels that we need to shift to make the joint of the arrow and the error message area
			seamless, if the up or down arrow is to be used. 
		 -->
		<attribute name="arrowVerticalOffset" type="number" value="7"/>
		
		<!--- 
			@keywords private
			The number of pixels that we need to shift to make the joint of the arrow and the error message area
			seamless, if the left or right arrow is to be used. 
		 -->
		<attribute name="arrowHorizontalOffset" type="number" value="3"/>
		
		<!--- 
			@keywords private
		 -->
		<method name="destroy"><![CDATA[
			if(this["updateLocationDel"]){
				this.updateLocationDel.unregisterAll(); 
				delete this.updateLocationDel; 
			}
			if (this.updateLocationCallbackAdded) {
				wcfCallbackUtil.cancelCallback(this.updateLocationCallbackDel);
				this.updateLocationCallbackAdded = false;
			}			
			super.destroy();
			]]>
		</method>
		
		<!---
			@keywords private
			Adjusts the attach location if attach target is updated. 
		 -->
		<handler name="onattachTarget"><![CDATA[
			if (!this['updateLocationDel']){
				this.updateLocationDel = new lz.Delegate(this, "updateLocation"); 
			}
			else {
				this.updateLocationDel.unregisterAll();
			}
			if (this.attachTarget != null) {
				this.updateLocationDel.register(this, "onvisible");
				this.updateLocationDel.register(this, "onwidth");
				this.updateLocationDel.register(this, "onheight");
				var v = this.attachTarget;
				while (v != null && v != canvas) {
					this.updateLocationDel.register(v, "onx");
					this.updateLocationDel.register(v, "ony");
					v = v.immediateparent;
				}
				this.updateLocationDel.register(this.attachTarget, "onwidth");
				this.updateLocationDel.register(this.attachTarget, "onheight");
				this.updateLocationDel.register(immediateparent, "onwidth");
				this.updateLocationDel.register(immediateparent, "onheight");
				this.updateLocation();
			}
			else {
				this.setAttribute("x", -1000);
				this.setAttribute("y", -1000);
			}		
			]]>
		</handler>
		
		<!--- 
			@keywords private
			Returns the width of this error message given where this error message will be attached. 
			@param string attach The position of attachment. It is one of ["left", "right", "top", "bottom"]
			@return the width of the error message assuming the given attachment position
		 -->
		<method name="getPotentialWidth" args="attach"><![CDATA[
			if(attach == "right" || attach == "left"){
				return this.arrow.width + this.left.width + this.message.width + this.right.width; 
			}
			
			return this.left.width + this.message.width + this.right.width; 
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the height of this error message given where this error message will be attached. 
			@param string attach The position of attachment. It is one of ["left", "right", "top", "bottom"]
			@return the height of the error message assuming the given attachment position
		 -->
		<method name="getPotentialHeight" args="attach"><![CDATA[
			if(attach == "top" || attach == "bottom"){
				return this.arrow.height + this.top.height + this.message.height, + this.bottom.height; 
			}
			
			return this.top.height + this.message.height + this.bottom.height; 
			]]>
		</method>
		
		<!--- 
			@keywords private
			@return the x position of this error message if it is attached to the right of the attach target.
		 -->
		<method name="getXForRightAttachment"><![CDATA[
			return this.attachTarget.getAttributeRelative("x", this.immediateparent) + this.attachTarget.width; 
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the y position of this error message if it is attached to the left or right of the attach target. 
		 -->
		<method name="getYForLeftOrRightAttachment"><![CDATA[
			return this.attachTarget.getAttributeRelative("y", this.immediateparent) + (this.attachTarget.height - this.height) / 2; 
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the x positionof this error message if it is attached to the top or bottom of the 
			attach target. 
		 -->
		<method name="getXForTopOrBottomAttachment"><![CDATA[
			return this.attachTarget.getAttributeRelative("x", this.immediateparent); 
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the x position of this error message if it is attached to the left of the attach target. 
		 -->
		<method name="getXForLeftAttachment"><![CDATA[
			return this.attachTarget.getAttributeRelative("x", this.immediateparent) - this.width; 
			]]>
		</method>
		
		
		<!--- 
			@keywords private
			Returns the y position of this error message if it is attached to the top of the attach target. 
		 -->
		<method name="getYForTopAttachment"><![CDATA[
			return this.attachTarget.getAttributeRelative("y", this.immediateparent) - this.height; 
			]]>
		</method>
		
		<!--- 
			@keywords private
			Returns the y position of this error message if it is attached to the bottom of the attach 
			target. 
		 -->
		<method name="getYForBottomAttachment"><![CDATA[
			return this.attachTarget.getAttributeRelative("y", this.immediateparent) + this.attachTarget.height; 
			]]>
		</method>
		
		
		<!--- 
			@keywords private
			Returns the valid attach position, starting with this.attach. If all four positions are tried but 
			none is valid, this.attach will be used. A right or left position is valid if the error message will 
			not extend beyond the vertical edges of its parent. A top or bottom position is valid if the error 
			message will not extend beyond the horizontal edges of its parent. If a position is valid, its opposite
			will be tried first. For example, if left is invalid, right will be tried next. 
			
			Modify this method if we need to change the order of searching valid attachment position. The currently
			implemented order is right -> left -> top -> bottom -> right.
		 -->
		<method name="getValidAttach"><![CDATA[
			if(!this["attachTarget"] || !this.attachTarget.visible){
				return undefined; 
			}
			// starts with default attachment position
			var newAttach = this.attach; 
			// Use count to avoid infinite loop. At most four attemps will be conducted, as there are 
			// only four potential attachment positions. 
			var count = 0; 
			while(true){
				if(newAttach == "right"){
					var availableWidth = this.immediateparent.width - this.getXForRightAttachment(); 
					if(availableWidth >= this.getPotentialWidth(newAttach)){
						return newAttach; 
					}else{
						newAttach = "left"; 
						count += 1; 
					}
				}
				
				if(newAttach == "left"){
					var availableWidth = this.attachTarget.getAttributeRelative("x", this.immediateparent); 
					if(availableWidth >= this.getPotentialWidth(newAttach)){
						return newAttach; 
					}else{
						newAttach = "top"; 
						count += 1; 
					}
				}
				
				if(newAttach == "bottom"){
					var availableHeight = this.immediateparent.height - this.getYForBottomAttachment(); 
					if(availableHeight >= this.getPotentialHeight(newAttach)){
						return newAttach;
					}else{
						newAttach = "right"; 
						count += 1; 
					}
				}
				
				if(newAttach == "top"){
					var availableHeight = this.attachTarget.getAttributeRelative("y", this.immediateparent); 
					if(availableHeight >= this.getPotentialHeight(newAttach)){
						return newAttach; 
					}else{
						newAttach = "bottom"; 
						count += 1; 
					}
				}
				// Use the default option when all options are tried but none is good enough
				if(count >= 4){
					return this.attach; 
				}
			}
			]]>
		</method>
		
		<!--- 
			@keywords private
			Add a deferred call back to update location.
		 -->
		<method name="updateLocation" args="e=null">
			<![CDATA[
			if (!this.updateLocationCallbackAdded) {
				if (typeof(this["updateLocationCallbackDel"]) == "undefined") {
					this.updateLocationCallbackDel = new lz.Delegate(this, "updateLocationCallback");
				}
				this.updateLocationCallbackAdded = true;
				wcfCallbackUtil.addDeferredCallback(this.updateLocationCallbackDel, null, wcfCallbackUtil.PRIORITY_FOREGROUND);		
			}
			]]>
		</method>
		
		<!--- 
			@keywords private
			Updates the location of this error message based on the first found valid attachment position. 
		 -->
		<method name="updateLocationCallback" args="e=null"><![CDATA[
			this.updateLocationCallbackAdded = false;
			if(this['attachTarget'] && this.visible){
				switch(this.getValidAttach()){
					case "right": 
						this.setAttribute('x', this.getXForRightAttachment()); 
						this.setAttribute('y', this.getYForLeftOrRightAttachment()); 
						//Debug.write("for right (x, y) = ", this.x, this.y); 
						break; 
					
					case "left": 
						this.setAttribute('x', this.getXForLeftAttachment()); 
						this.setAttribute('y', this.getYForLeftOrRightAttachment()); 
						//Debug.write("for left (x, y) = ", this.x, this.y); 
						break; 
					
					case "bottom": 
						this.setAttribute('x', this.getXForTopOrBottomAttachment()); 
						this.setAttribute('y', this.getYForBottomAttachment()); 
						break; 
					
					case "top": 
						this.setAttribute('x', this.getXForTopOrBottomAttachment()); 
						this.setAttribute('y', this.getYForTopAttachment()); 
				}
				this.layout.update();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			The layout manager for this error message
		 -->
		<layout name="layout">			
			<!--- 
				Sets up the x-coordinates of all the views composing the error message area. That is, 
				the arrow is not included. 
				 
				@param Number startX the x position of the top left corner of the message area. 
			 -->
			<method name="updateMessageAreaX" args="startX"><![CDATA[
				classroot.topLeft.setAttribute('x', startX); 										
				classroot.top.setAttribute('x', classroot.topLeft.x + classroot.topLeft.width); 
				classroot.top.setAttribute('width', classroot.message.width); 
				classroot.topRight.setAttribute('x', classroot.top.x + classroot.top.width); 					
				
				classroot.left.setAttribute('x', classroot.topLeft.x); 
				classroot.message.setAttribute('x', classroot.left.x + classroot.left.width); 
				classroot.background.setAttribute('x', classroot.left.x + classroot.left.width); 
				classroot.background.setAttribute('width', classroot.message.width); 
				classroot.right.setAttribute('x', classroot.message.x + classroot.message.width); 					
				
				classroot.bottomLeft.setAttribute('x', classroot.topLeft.x); 
				classroot.bottom.setAttribute('x', classroot.bottomLeft.x + classroot.bottomLeft.width); 
				classroot.bottom.setAttribute('width', classroot.message.width); 
				classroot.bottomRight.setAttribute('x', classroot.bottom.x + classroot.bottom.width); 
				]]>
			</method>
			
			<!--- 
				Displays the appropriate arrow based on the given attachment position. 
			 -->
			<method name="updateArrowResource" args="attach"><![CDATA[
				var resourceMap = {
					right: 1, 
					bottom: 2, 
					left: 3,
					top: 4 
				}; 
				classroot.arrow.setAttribute('frame', resourceMap[attach]); 
				]]>
			</method>
			
			<!--- 
				Updates the x-cordinates of all the views in this error message, including arrow's. 
			 -->
			<method name="updateX" args="attach"><![CDATA[
				switch(attach){
					case "right": 
						classroot.arrow.setAttribute('x', 0); 
						this.updateMessageAreaX(classroot.arrow.x + classroot.arrow.width - classroot.arrowHorizontalOffset); 
						break; 
					case "left": 
						this.updateMessageAreaX(0); 
						classroot.arrow.setAttribute('x', classroot.right.x + classroot.right.width - classroot.arrowHorizontalOffset); 
						break; 
					default: 
						this.updateMessageAreaX(0); 
						// for bottom and top attachment, we shift the arrow to the right for 10 points
						classroot.arrow.setAttribute('x', classroot.left.x + classroot.left.width + 10); 
				}
				]]>
			</method>
			
			<!---
				Updates the y-coordinate of the message area
			 -->
			<method name="updateMessageAreaY" args="startY"><![CDATA[
				classroot.topLeft.setAttribute('y', startY); 
				classroot.left.setAttribute('y', classroot.topLeft.y + classroot.topLeft.height); 
				classroot.left.setAttribute('height', classroot.message.height); 
				classroot.bottomLeft.setAttribute('y', classroot.left.y + classroot.left.height); 
				
				classroot.top.setAttribute('y', classroot.topLeft.y); 
				classroot.message.setAttribute('y', classroot.top.y + classroot.top.height); 
				classroot.background.setAttribute('y', classroot.top.y + classroot.top.height); 
				classroot.background.setAttribute('height', classroot.message.height);
				classroot.bottom.setAttribute('y', classroot.message.y + classroot.message.height); 
				
				classroot.topRight.setAttribute('y', classroot.top.y); 
				classroot.right.setAttribute('y', classroot.topRight.y + classroot.topRight.height); 
				classroot.right.setAttribute('height', classroot.message.height); 
				classroot.bottomRight.setAttribute('y', classroot.right.y + classroot.right.height); 
				]]>
			</method>
			
			<!--- 
				Updates the y-coordinates of the message
			 -->
			<method name="updateY" args="attach"><![CDATA[
				switch(attach){
					case "bottom": 
						classroot.arrow.setAttribute('y', 0); 
						this.updateMessageAreaY(classroot.arrow.height - classroot.arrowVerticalOffset);
						break; 
					case "top": 
						this.updateMessageAreaY(0); 
						classroot.arrow.setAttribute('y', classroot.bottom.y + classroot.bottom.height - classroot.arrowVerticalOffset); 
						break; 
					default: 
						this.updateMessageAreaY(0); 
						classroot.arrow.setAttribute('y', classroot.topLeft.y + (classroot.getPotentialHeight(attach) - classroot.arrow.height) / 2); 
				
				}
				]]>
			</method>
			
			<method name="update" args="e=null"><![CDATA[
				if(this.locked == false){
					this.lock(); 
					var validAttach = classroot.getValidAttach(); 
					if(validAttach){
						this.updateArrowResource(validAttach); 
						this.updateX(validAttach); 
						this.updateY(validAttach); 
					}
					
					this.locked = false; 
				}
				]]>
			</method>
		</layout>
		
		<view name="topLeft" resource="errorMessageTopLeft"/>
		<view name="left" resource="errorMessageLeft" stretches="height"/>
		<view name="bottomLeft" resource="errorMessageBottomLeft"/>
		
		<view name="top" resource="errorMessageTop" stretches="width"/>
		<view name="background" resource="errorMessageBackground" stretches="both"/>
		<view name="bottom" resource="errorMessageBottom" stretches="width"/>
		
		<view name="topRight" resource="errorMessageTopRight"/>
		<view name="right" resource="errorMessageRight" stretches="height"/>
		<view name="bottomRight" resource="errorMessageBottomRight"/>
		
		<text name="message" multiline="${parent.multiline}" resize="true" text="${classroot.errorMessage}" fgcolor="white"/>

		<view name="arrow" resource="errorMessageArrow"/>
		
		<animator name="showAnimator" attribute="opacity" from="0" to="${parent.defaultOpacity}" duration="${parent.duration}" start="false"/>
		<!---  somehow animator.setTo(to) doesn't take effect immediately. So, we use two animator to make sure error message always show or hide. -->
		<animator name="hideAnimator" attribute="opacity" from="${parent.defaultOpacity}" to="0" duration="${parent.duration}" start="false"/>
		<!--- 
			This method shows the given error message with animation .
			@param String message The message that is to be displayed
		 -->
		<method name="show" args="message"><![CDATA[
			this.setAttribute("errorMessage", message);
			if(!this['showing']){
				this.setAttribute("visible", true);
				this.showAnimator.doStart();
				this.showing = true;
			}
			]]>
		</method>
		
		<!--- 
			This method hides the shown error message if the expected attachment target is the current
			attachTarget or there is no exptected attachment target at all. 
			@param lz.view expectedTarget the expected attachment target. This view will be hiden only 
			if there is no expected target specified, or the expected target is the same as this.attachTarget. 
			We need this because multiple widgets may share the same error message, so we need to ensure an 
			irrelevant widget will not hide this message accidentally. 
		 -->
		<method name="hide" args="expectedTarget=null"><![CDATA[
			if(this['showing'] && (!expectedTarget || this.attachTarget == expectedTarget)){
				this.hideAnimator.doStart();
				this.showing = false;
				this.setAttribute("visible", false);
			}
			]]>
		</method>
	</class>	
	
	<!--- 
		A globally available error message instance. Since at most one error message will be displayed at any 
		given moment, all widgets that needs error message should use this instance. 
	-->
	<wcfErrorMessageView id="wcfErrorMessage" visible="false"/>
	
	<!---
		This object level validator ensures that if the current object has any child objects that
		match the specified object path, that at least one of those objects has a property that matches the specified
		property name and property values. In order to ensure that this validator gets called when the
		property value changes, there must be a property definition for the property and it must have
		{@link wcfPropertyDefinition#forceParentValidation forceParentValidation} set to "true".
		No error will be displayed if there are no child objects that match the object path.
		The following example demonstrates the declaration of a 
		validator that checks that one of the catalog entry offer prices
		has a minimum quantity set to "1".
		
		@START_CODE
			<RequiredSpecificValueForChildObjectPropertyValidator
				objectPath="CatalogEntryOfferGroup" 
				errorMessage="${catalogResources.offerPriceMinimumQuantityWarning}"
				propertyName="minimumQuantity" 
				propertyValues="1.0,1"/>
		@END_CODE
	 -->
	<class name="wcfRequiredSpecificValueForChildObjectPropertyValidator" extends="wcfValidator">
		<!--- 
			The name of the property which must have a specific value. This is a required attribute.
		-->
		<attribute name="propertyName" type="string" value=""/>
		
		<!---
			Comma separated list of property values. This is a required attribute.
		-->
		<attribute name="propertyValues" type="string" value=""/>
		
		<!--- 
			The object path that describes the child objects.
		-->
		<attribute name="objectPath" type="string"/>
		
		<!---
			If this is set to "true", this validator will ensure any child objects that
			match the specified object path, that none of those objects has a property that
			matches the specified property name and property values. Default value is false.
		-->
		<attribute name="negate" type="boolean" value="false"/>
		
		<!---
			The error message to display when no matching property is found.
		-->
		<attribute name="errorMessage" value="" type="string"/>
		
		<!---
			@keywords private
		 -->
		<attribute name="propertyValueList" value="${[]}"/>
		
		<!--- @keywords private -->
		<handler name="oninit"><![CDATA[
			this.updatePropertyValueList(); 
			]]>
		</handler>
		
		<!--- 
			@keywords private
			Updates the attribute propertyNameList based on the value of the attribute
			propertyNames. 
		 -->
		<method name="updatePropertyValueList"><![CDATA[
			this.propertyValueList = wcfStringUtil.splitAndTrim(this.propertyValues, ",");
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method name="validate" args="o, property=null">
			<![CDATA[
			if(this.isEnabled(o)) {
				var childObjects = o.getObjects(this.objectPath);
				if (childObjects == null || childObjects.length <= 0) {
					o.clearValidationError(this);
					return;
				}
				
				for(var i = 0; i < childObjects.length; ++i) {
					var childObject = childObjects[i];
					var propertyValue = childObject.getPropertyValue(this.propertyName);
					for(var j = 0; j < this.propertyValueList.length; ++j) {
						if(propertyValue == this.propertyValueList[j]) {
							if(!negate) {
								o.clearValidationError(this);
								return;
							}
							else {
								o.addValidationError(this, this.errorMessage);
								return;
							}
						}
					}
				}
				
				if(!negate) {
					o.addValidationError(this, this.errorMessage);
				}
				else {
					o.clearValidationError(this);
				}
			}
			else {
				o.clearValidationError(this);
			}
			]]>
		</method>
	</class>
	
	<!---
		<p>The <code>wcfUniqueValueForChildObjectPropertyValidator</code> class is an object level validator. If the selected object has any child objects that match the 
		specified object path, this class ensures that each of these child objects has a unique property value. To call this validator when the property 
		value changes, create a property definition with forceParentValidation set to "true". If multiple child objects match the specified object path 
		and have the same property values, an error message is displayed.
		<p>The following example demonstrates the declaration of a validator that checks that the value of minimumQuantity is unique.
		
		@START_CODE
			<CatalogEntryUniquenessValidator
				package="cat"
				objectPath="CatalogEntryOfferGroup" 
				errorMessage="${catalogResources.uniquenessWarning}"
				propertyName="minimumQuantity"/>
		@END_CODE
	 -->
	<class name="wcfUniqueValueForChildObjectPropertyValidator" extends="wcfValidator">
		<!--- 
			The name of the property which must have a unique value. This is a required attribute.
		-->
		<attribute name="propertyName" type="string" value=""/>			
		<!--- 
			The object path that describes the child objects. This is a required attribute.
		-->
		<attribute name="objectPath" type="string"/>		
		<!---
			The error message text to display when the property value is not unique. The message can have two substitution variables denoted 
			by {0} and {1}. {0} is replaced with the property value and {1} is replaced with the display name.
		-->
		<attribute name="errorMessage" value="${foundationResources.uniquenessWarning.string}" type="string"/>
		
		<!---
			@keywords private
		-->
		<method name="validate" args="o, property=null">
			<![CDATA[		
			if(this.isEnabled(o)) {
				var childObjects = o.getObjects(this.objectPath);
				if (childObjects == null || childObjects.length <= 0) {					
					return;
				}				
				var propMap = {};				
				for(var i = 0; i < childObjects.length; ++i){
					var childObject = childObjects[i];
					var property = childObject.getProperty(this.propertyName);
					var val = property.value;
										
					var propertyValue = property.propertyDefinition.getPropertyValue(property, null);
					if(propertyValue && propertyValue.getDisplayName(null) != "") {
						val = propertyValue.getDisplayName(null);
					}
					else if (property.propertyDefinition.type == "number") {				
						val = parseFloat(val);
					}					
					if (propMap[val] != null) {
						var message = wcfStringUtil.replaceParams(this.errorMessage, [val, property.propertyDefinition.displayName]);						
						property.addValidationError(this, message);
						propMap[val].addValidationError(this, message);									
					} else {
						property.clearValidationError(this);
						propMap[val] = property;
					}					
				}				
			}
			]]>
		</method>
	</class>
	
</library>
