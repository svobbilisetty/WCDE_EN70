<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2007, 2013 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<library>
	<!---
		A model object is the representation of a business object. Every business object that is loaded by the Management Center framework is an instance of wcfModelObject.
		A business object is an object that is authored by a business user. The characteristics of these objects are defined in the object definition.
		<p>
		For example,<br/>
		A product is a business object. The characteristics of products are defined in a wcfObjectDefinition instance. In this case, the object definition is
		{@link catProductPrimaryObjectDefinition}. When a new product is created by the business user, the Management Center framework creates a new instance of
		wcfModelObject that represents this new product. The Management Center creates an association between this wcfModelObject and the object definition
		catProductPrimaryObjectDefinition.
		<P>
		The model object will contain all of the data of this specific instance.  For example:
		<ul>
			<li>A number of {@link wcfModelProperty model properties}
			<li>Child objects, such as product description, and product price
			<li>References to other objects, such as merchandising associations
		</ul>
		
		The Management Center creates instances of wcfModelObject when:
		
		<ul>
			<li>The business user requests to create a new business object
			<li>The business user requests to load objects from the server
		</ul>
	-->
	<class name="wcfModelObject" extends="node">
		<!---
			@keywords private
			Reference to the parent model that manages this model object
			@see wcfModel
		-->
		<attribute name="model" value="null"/>
		
		<!---
			Reference to definition of this model object.
			@see wcfObjectDefinition
			@type wcfObjectDefinition
		-->
		<attribute name="objectDefinition" value="null"/>
		
		<!---
			The type of this object. This is a read-only attribute. It is populated with the value from this
			object's {@link wcfObjectDefinition objectDefinition}.
		 -->
		<attribute name="objectType" value="" type="string"/>
		
		<!---
			@keywords private
			Unique identifier of this model object among objects with the same
			object type or under the same parent object.
		-->
		<attribute name="objectId" value="" type="string"/>
		
		<!---
			@keywords private
			The current template type of this model object.
		-->
		<attribute name="templateType" value="" type="string"/>
		
		<!---
			@keywords private
			Unique identifier of the version of this model object.
		-->
		<attribute name="objectVersionId" value="" type="string"/>
		
		<!---
			@keywords private
			Object key used in object maps. It must be unique in the scope where
			an object map is used. For example, all the child objects under the
			same parent object must have unique keys. If some child objects are
			also available globally in the model, they must have unique keys in
			the model.
		-->
		<attribute name="objectKey" value="" type="string"/>
		
		<!---
			@keywords private
			Object display name.
		-->
		<attribute name="objectDisplayName" value="null"/>

		<!---
			@keywords private
			Object display name in lower case
		-->
		<attribute name="lowerCaseDisplayName" value="null"/>
		
		<!---
			@keywords private
			Object long display name, this is defined by the <code>longObjectDisplayNameProperty</code>
			in the object's {@link wcfObjectDefinition}
		-->		
		<attribute name="objectLongDisplayName" value="null"/>
		
		<!---
			@keywords private
			Object's Read Only State, if explicitly set
		-->
		<attribute name="objectReadOnly" value="null"/>
		
		<!---
			@keywords private
			Object's Deletable State, if explicitly set
		-->
		<attribute name="objectDeletable" value="null"/>
		
		<!---
			@keywords private
			Open group's Read Only State. This flag is set to "true" if the group doesn't have any
			editable properties and doesn't contain any objects that are read only.
		-->
		<attribute name="openGroupReadOnly" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Open group's Partially Editable State. This flag is set to true if the object has some but not all
			editable properties.
		-->	
		<attribute name="openGroupPartiallyEditable" type="boolean" value="false"/>
		

		<!--- Object's Read Only State, either explicitly set or inherited.-->
		<attribute name="readOnly" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Array of model object lists that are tied to this object's children.
		-->
		<attribute name="childModelObjectLists" value="${[]}"/>
		
		<!---
			@keywords private
			Array of objects that describe the binding between this object
			and a model object list that contains a list of objects that
			reference this object. The binding objects contain the following properties:
			- list: the model object list instance
			- paths: an array of arrays of reference object definitions
			- intermediateObjects: an array of intermediate objects
		-->
		<attribute name="referenceListBindings" value="${[]}"/>
		
		<!---
			@keywords private
			Indicate that user has access rights to the store
		 -->
		<attribute name="hasAccessRight" type="boolean" value="true"/>
		
		<!---
			@keywords private
			An array of the get children services currently loading.
		-->
		<attribute name="getChildrenServicesLoading" value="${[]}"/>
		
		<!---
			@keywords private
			An array of the get children services currently loaded.
		-->
		<attribute name="getChildrenServicesLoaded" value="${[]}"/>
		
		<!---
			@keywords private
			An array of the get children services that failed the last time the load was requested.
		-->
		<attribute name="getChildrenServicesFailed" value="${[]}"/>
		
		<!---
			@keywords private
			Indicates that the object's references are not up to date.
		-->
		<attribute name="referencesStale" type="boolean" value="true"/>
		
		<!---
			@keywords private
			Indicates that the object's references are not up to date.
		-->
		<attribute name="referencesLoaded" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicates that the object's refresh service is currently loading.
		-->
		<attribute name="refreshing" type="boolean" value="false"/>
		
		<!---
			Indicates that the object is waiting to be deleted. It will be deleted when the parent is saved.
		-->
		<attribute name="pendingDelete" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicates that the object is waiting to have its child object lists updated.
		-->
		<attribute name="childObjectListsStale" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicates that the object is waiting to have its reference lists updated.
		-->
		<attribute name="referenceListsStale" type="boolean" value="false"/>
		
		<!---
			Parent object. Primary objects do not have a parent.
			@type wcfModelObject
		-->
		<attribute name="parentObject" value="null"/>
		
		<!---
			@keywords private
			A map of this object's references. A key in this map must be an <code>objectKey</code>,
			and the value referred to by this key must be an model object that owns
			the same <code>objectKey</code>.
		-->
		<attribute name="referenceMap" value="${{}}"/>
		
		<!---
			@keywords private
			An array of all of the model objects that reference this object.
		-->
		<attribute name="references" value="${[]}"/>
		
		<!--- "true" if this is a new object that has never been saved. -->
		<attribute name="newObject" type="boolean" value="false"/>
		
		<!--- "true" if the new object was created implicitly. -->
		<attribute name="implicitNewObject" type="boolean" value="false"/>

		<!--- "true" if this object is a test object. -->
		<attribute name="testObject" type="boolean" value="false"/>
				
		<!--- "true" if this object is new or being edited. -->
		<attribute name="open" type="boolean" setter="this.setOpen(open)"/>
		
		<!--- "true" if this object is opened in Compare View. -->
		<attribute name="isOpenInCompareView" type="boolean" value="false"/>
		
		<!---
			@keywords private
			A map of this object's children. The key of this map is a {@link wcfModelObject#objectKey},
			and the value referred to by this key must be a model object instance that owns this
			<code>objectKey</code>.
		-->
		<attribute name="childObjectMap" value="${{}}"/>
		<!---
			@keywords private
			An array of child object keys that are ordered based on when they were assigned. The most recently assigned
			child object keys will be at the end of the list.
		-->
		<attribute name="orderedChildObjectKeys" value="${[]}"/>
		
		<!---
			@keywords private
			An array of this object's children. Each element in this array has to be a model object.
			This list is not always synchronized to <code>childObjectMap</code>. If the most current
			list of child objects need to be retrieved, use {@link wcfModelObject#childObjectMap}.
		-->
		<attribute name="childObjects" value="${[]}"/>
		
		<!---
			@keywords private
			A map of this object's properties.
		-->
		<attribute name="propertyMap" value="${{}}"/>
		
		<!---
			The top object for the open group to which this object belongs.
			@type wcfModelObject
		-->
		<attribute name="openGroupObject" value="null"/>
		
		<!--- "true" if the object has validation errors. This attribute is only set for the open group object. -->
		<attribute name="errorInOpenGroup" type="boolean" value="false"/>
		
		<!---
			The first object error found in the open group.
			@type String
		-->
		<attribute name="openGroupError" value="null"/>
		
		<!---
			@keywords private
			An array of client validation errors. Client validation errors are stored as objects that contain two properties:
			"message" and "validator".
		-->
		<attribute name="clientErrors" value="${[]}"/>

		<!---
			@keywords private
			An array of server validation errors. Server validation errors are stored as strings.
		-->
		<attribute name="serverErrors" value="${[]}"/>
		
		<!---
			"true" if the open group has at least one unsaved change. False otherwise. This attribute
			is guaranteed to be set only when this object is its open group object.
		 -->
		<attribute name="openGroupDirty" type="boolean" value="false" setter="this.setOpenGroupDirty(openGroupDirty)"/>
		
		<!---
			@keywords private
			The service transaction object associated with this object. A transaction
			object will be created for service requests that are persisting the current
			state of this model object. If this value is null, it indicates that there
			is no active transaction request.
		-->
		<attribute name="transaction" value="null"/>
		
		<!---
			@keywords private
			The array of pending transaction objects associated with this object. Only
			one transaction service request is active at a time.
		-->
		<attribute name="pendingTransactions" value="${[]}"/>
		
		<!---
			@keywords private
			Indicates that there is an active transaction that is creating this object.
		-->
		<attribute name="creating" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicates that there is an active transaction that is deleting this object.
		-->
		<attribute name="deleting" type="boolean" value="false"/>
		
		<!---
			@keywords private
			A non-zero value indicates that this object is locked. Updates will not be trigged until the
			object is unlocked.
		-->
		<attribute name="lockCount" type="number" value="0"/>
		
		<!---
			@keywords private
			A non-zero value keeps track of the number of references are made to this object.
		-->
		<attribute name="referenceCount" type="number" value="0"/>
		
		<!---
			@keywords private
			A non-zero value indicates that this object has child in open state.
		-->
		<attribute name="openChildCount" type="number" value="0"/>
		
		<!---
			@keywords private
			"true" if this object is an open group object and its init() method is completed.
			False otherwise.
		 -->
		<attribute name="openGroupInitiated" type="boolean" value="false"/>
		
		<!---
			@keywords private
			The state of the views that are bound to this model object.
		-->
		<attribute name="viewState" type="string" value=""/>

		<!---
			@keywords private
			An instance of {@link wcfDisplayNameStyle} that the framework will use to display the display name of this
			business object. If this value is null, then the default display name style will
			be used.
		-->
		<attribute name="displayNameStyle" value="null"/>
		
		<!---
			@keywords private
			Array of status objects indicating the state of loading get children services. Each entry in the array is
			an object with the following properties:
			service - the wcfGetChildrenService instance associated with this status object
			message - the status message that will be displayed to the user
			messageForTree - the status message that will be displayed to the user (on browse object tree)
			hasError - indicates that the status message is an error
			startIndex - the start index of the current page
			totalRecords - recordSetTotal returned from service.
			currPageNum - the current page number.
			lastPageNum - the last page number.
			deleteCount - number of records deleted.
			serviceObjectList - the list of objects returned from the service.
		-->
		<attribute name="loadChildrenStatusObjects" type="string" value="${[]}"/>
		
		<!---
			@keywords private
			Array of status objects indicating the state of loading get references services. Each entry in the array is
			an object with the following properties:
			service - the wcfGetReferencesService instance associated with this status object
			message - the status message that will be displayed to the user
			hasError - indicates that the status message is an error
		-->
		<attribute name="loadReferencesStatusObjects" type="string" value="${[]}"/>
		
		<!---
			@keywords private
			Raw data property map. This is an internal data structure that stores property values of this model object when
			it is first loaded. This data will not be refreshed until the model object is reloaded. It is read only and should
			never be updated by other classes. It is used for lazy initialization of property values.
		-->
		<attribute name="rawDataPropertyMap" value="${{}}"/>
		
		<!---
			@keywords private
			Indicates that validation messages have been reported to the message logger. Messages are only logged
			in the message logger if the object is open.
		-->
		<attribute name="messagesLogged" type="boolean" value="false"/>
		
		<!---
			An array of the views this object is shown with
			@keywords private
		-->
		<attribute name="objectViews" value="${[]}"/>
		
		<!---
			"true" if we should force the parsed data
			@keywords private
		-->
		<attribute name="forceParseData" type="boolean" value="false"/>
		
		<!---
			Map for tracking whether a request for loading children for a given languageId have been sent.
			Key is languageId and value is an array of wcfGetChildrenService instances for which the languageId
			has been requested.
			@keywords private
		-->
		<attribute name="loadChildrenLanguageMap" value="${{}}"/>

		<!---
			An array of XML objects whose parsing is deferred by the framework because their parent
			objects have not been parsed as of yet.
			@keywords private
		-->
		<attribute name="deferredElements" value="${[]}"/>		
		
		<!---
			@keywords private
			Unique identifier of the store that this model object belongs to.
		-->
		<attribute name="objectStoreId" value="" type="string"/>
		
		<!---
			@keywords private
			Object's Modifiable State in change control metadata, if explicitely set
		-->
		<attribute name="changeControlModifiable" value="null"/>
		
		<!--- This event is triggered if the object is being destroyed. -->
		<event name="beingDestroyed"/>
		
		<!--- @keywords private
		
			  The file reference object, for internal use. This is an ActionScript object that is available as of swf8.
			  This attribute has a default value of null. If the object definition for this object has
			  {@link wcfObjectDefinition#isFileObject} set to "true", then file upload widgets such as {@link wcfPropertyFileUploader}
			  will create the FileReference object for the model object to support the file upload.
		-->
		<attribute name="fileref" value="${null}"/>
		
		<!---  Object is being saved. This event will be triggered before any change is actually saved -->
		<event name="beingSaved"/>
		
		<!--- @keywords private
		
			  Indicates that this model object is moveable
		-->
		<attribute name="moveable" type="boolean" value="true"/>
		
		<!--- @keywords private
		
			  Indicates that this model object has been explicitly opened and viewed in its properties view.
		-->
		<attribute name="viewed" type="boolean" value="false"/>
		
		<!--- @keywords private
		
			  The number of milliseconds since the last time this model object has been explicitly opened and
			  viewed in its properties view.
		-->
		<attribute name="lastViewedTime" type="number" value="0"/>
		<!--- @keywords private
			The number of calls to be made to the method updateChildObjectLists.
		-->
		<attribute name="updateChildObjectListsCallbackCount" type="number" value="0"/>
		<!--- @keywords private
			The number of calls to be made to the method updateReferencesLists.
		-->
		<attribute name="updateReferencesListsCallbackCount" type="number" value="0"/>
		<!---
			@keywords private
			Indicates that a deferred callback has been added for the update log messages callback.
		-->
		<attribute name="updateLogMessagesCallbackAdded" type="boolean" value="false"/>
		
		<!--- @keywords private
			  The number of milliseconds since the last time this model object has been changed.
		-->
		<attribute name="changeToDirtyTime" type="number" value="0"/>
		
		<!---
			@keywords private
			Indicates that this object has releasable children. This attribute is set to true when
			an object is opened before all of the children services are loaded.
		-->
		<attribute name="hasReleasableChildren" type="boolean" value="false"/>
		<!---
			@keywords private
			The initialization identifier associated with the model this object was created with.  This is
			only set for objects that are put into the object map.
		-->
		<attribute name="modelInitializationIdentifier" type="number" value="0"/>
		<!---
			@keywords private
			Array of unparsed object elements.
		-->
		<attribute name="unparsedObjects" value="null"/>
		<!---
			@keywords private
			The default language child object for this object.
		-->
		<attribute name="defaultLanguageObject" value="null"/>
		<!---
			@keywords private
			The parent primary object for this object. This will be set for non-primary objects.
		-->
		<attribute name="parentPrimaryObject" value="null"/>	
		<!---
			@keywords private
			The post save transaction object associated with this object. One post save transaction
			object will be created for each create and update request for the open group object.
			If this value is null, it indicates that there is no active post save transaction request.
		-->
		<attribute name="postSaveTransaction" value="null"/>	
		<!---
			@keywords private
			This flag is set to true when a call to the {@link wcfPostSaveService#post save service} fails. When true, the {@link wcfPostSaveService#post save service}
			needs to be called the next time the object is saved even if no changes have been made to the object.
		-->
		<attribute name="postSaveFailed" value="false"/>	
		<!---
			@keywords private
			This attribute is used to cache the referenced object of this object.
		-->
		<attribute name="referencedObject" value="null"/>

		<!---
			@keywords private
			This attribute contains an instance of the context class that is used within the scope of this object.
		-->
		<attribute name="localContext" />

		<!---  @keywords private -->
		<method name="init">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "init");
			}
			*/
			super.init();
			
			this.updateChildObjectListsDel = new lz.Delegate(this, "updateChildObjectLists");
			this.updateReferencesListsDel = new lz.Delegate(this, "updateReferencesLists");
			this.updateFilteredChildObjectsDel = new lz.Delegate(this, "updateFilteredChildObjects");
			this.updateReadOnlyDel = new lz.Delegate(this, "updateReadOnly");
			this.updateDisplayNameDel = new lz.Delegate(this, "updateDisplayName");
			this.updateLongDisplayNameDel = new lz.Delegate(this, "updateLongDisplayName");
			this.updateTemplateTypeDel = new lz.Delegate(this, "updateTemplateType");
			this.onLanguageChangeDel = new lz.Delegate(this, "checkLanguageSensitiveObject");
			this.checkOpenGroupReadOnlyDel = new lz.Delegate(this, "checkOpenGroupReadOnly");
			this.updateLogMessagesCallbackDel = new lz.Delegate(this, "updateLogMessagesCallback");
			this.setDefaultPropertyValuesDel = new lz.Delegate(this, "setDefaultPropertyValues");
			this.updateDisplayNameStyleDel = new lz.Delegate(this, "updateDisplayNameStyle");
			this.checkLoadedChildrenDel = new lz.Delegate(this, "checkLoadedChildren");
			this.loadLanguageSensitiveChildrenDel = new lz.Delegate(this, "loadLanguageSensitiveChildren");
						
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "init");
			}
			*/	
			]]>
		</method>
		
		<!---
			@keywords private
			@param Object args An object whose properties will be copied to this model object.
		-->
		<method name="initializeObject" args="args">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "initializeObject");
			}
			*/
			this.referenceCount = 0;
			for (var key in args) {
				this[key] = args[key];
			}
			this.parent = this.model;
			
			if (this.model.oEditor.localContext != null && typeof(this.localContext) == "undefined") {
				this.localContext = this.model.oEditor.localContext;
			}
			
			this.setAttribute("open", false);
			
			if (typeof(this["objectReadOnly"]) == "undefined") {
				this.objectReadOnly = null;
			}
			this.initOpenGroupObject();
			
			if (this.newObject) {
				var storeConfig = (this.localContext ? this.localContext.storeConfig : null);
				if(this.objectDefinition.initializeObjectStoreId && (storeConfig != null)){
					var prop = this.propertyMap["objectStoreId"];
					if (prop) {
						prop.setAttribute("value", storeConfig.storeId);
					}
					else {
						var rawData = this.rawDataPropertyMap["objectStoreId"];
						if (!rawData) {
							rawData = {};
							this.rawDataPropertyMap["objectStoreId"] = rawData;
						}
						rawData.propertyValue = storeConfig.storeId;
						rawData.propertyReadOnly = false;
						rawData.trimmed = false;
					}
					this.parseObjectStoreId();
				}
				
				this.setDefaultPropertyValues();
				var e = this.objectDefinition.getTemplate();
                if (e) {
					this.parseDataElement(e);
				}
				if (this.openGroupObject != null && !this.implicitNewObject) {
					this.openGroupObject.setAttribute("open", true);
					this.openGroupObject.checkUnsavedChanges(true);
				}
				else if (this.objectDefinition.organizational) {
					this.newObject = false;
				}
			}
			else {
				this.setDefaultPropertyValues();
				var e = this.objectDefinition.getTemplate();
                if (e) {
					this.parseProperties(e);
				}
			}
			this.updateDisplayName();
			this.updateLongDisplayName();
			this.updateTemplateType();
			this.updateDisplayNameStyle();
			
			if(this == this.openGroupObject){
				this.openGroupInitiated = true;				
			}
			
			this.checkOpenGroupReadOnly();
			this.updateRefreshTimer();
			
			// add delegate to check if the object needs to be removed.
			if (this.objectDefinition.languageSensitive && this.implicitNewObject) {
				wcfContextUtil.findContextValue(this, "inputLanguageIds", this.onLanguageChangeDel);
			}

			if (wcfLogger.enabled) {
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "initializeObject", "objectType: " + objectType + "objectId: " + objectId);						
			}	
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "initializeObject");
			}
			*/	
			]]>
		</method>
		
		<!---
			@keywords private
			This method sets up the refresh timer if this object has an enabled refresh condition.
		-->
		<method name="updateRefreshTimer" args="e=null">
			<![CDATA[
			if (this.objectDefinition["refreshCondition"]) {
				if (this["updateRefreshTimerDel"]) {
					this.updateRefreshTimerDel.unregisterAll();
				}
				else {
					this.updateRefreshTimerDel = new lz.Delegate(this, "updateRefreshTimer");
					this.refreshTimeoutDel = new lz.Delegate(this, "refreshTimeout");
				}
				this.objectDefinition.refreshCondition.registerDelegate(this, this.updateRefreshTimerDel);
				if (this.objectDefinition.refreshCondition.isEnabled(this)) {
					lz.Timer.resetTimer(this.refreshTimeoutDel, 1000 * this.objectDefinition.refreshInterval);
				}
				else {
					lz.Timer.removeTimer(this.refreshTimeoutDel);
				}
			}
			]]>
		</method>	
		
		<!---
			@keywords private
		-->
		<method name="refreshTimeout" args="e=null">
			<![CDATA[
			if (this.objectDefinition.refreshService != null && !this.refreshing) {
				this.refreshing = true;
				this.objectDefinition.refreshService.doRequest(this);
			}
			lz.Timer.resetTimer(this.refreshTimeoutDel, 1000 * this.objectDefinition.refreshInterval);
			]]>
		</method>
		
		<!---
			@keywords private
			This method updates the template type for the given template type property.
		-->
		<method name="updateTemplateType" args="e=null">
			<![CDATA[
			this.updateTemplateTypeDel.unregisterAll();
			if (this.objectDefinition.templateTypeProperty) {

				var templateTypeProperty = this.getProperty(this.objectDefinition.templateTypeProperty);
				this.updateTemplateTypeDel.register(templateTypeProperty, "onvalue");
				
				if (this.templateType != templateTypeProperty.value) {
					if (this.templateType) {
						var objectTemplate = this.objectDefinition.objectTemplates[this.templateType];
						if (objectTemplate && objectTemplate.deleteObjectTypes != "") {
							var deleteObjectTypes = wcfStringUtil.splitAndTrim(objectTemplate.deleteObjectTypes, ",");
							for (var i = 0; i < deleteObjectTypes.length; i++) {
								var objectsToDelete = this.getObjects(deleteObjectTypes[i]);
								for (var j = 0; j < objectsToDelete.length; j++) {
									objectsToDelete[j].deleteObject();
								}
							}
						}
					}
					
					this.templateType = templateTypeProperty.value;
					
					if (templateTypeProperty.dirty) {
						var objectTemplate = this.objectDefinition.objectTemplates[this.templateType];
						if (objectTemplate) {
							this.parseDataElement(objectTemplate.getTemplate(), false, true);
						}
					}
				}
			}
			]]>
		</method>			
		
		<!---
			@keywords private
			@return "true" if this object is currently being viewed. False otherwise.
		-->
		<method name="isViewed">
			<![CDATA[
			return this.objectViews.length > 0;
			]]>
		</method>
		
		<!---
			@keywords private
			Registers a view that is currently being used to display this model object.
			@param lz.view objectView a view that displays this object
		-->
		<method name="registerObjectView" args="objectView">
			<![CDATA[
			if (this.objectDefinition != null) {
				var i = this.objectViews.indexOf(objectView);
				if (i < 0) {
					this.objectViews.push(objectView);
				}
				this.checkParsedData();
				if (this.objectDefinition.reference) {
					var ref = this.getReferencedObject();
					if (ref && ref != this) {
						ref.registerObjectView(objectView);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Removes an object view that displays this model object, if the given
			object view is already registered to this model object.
			@param lz.view objectView the view to be removed.
			@see wcfModelObject#registerObjectView
		-->
		<method name="unregisterObjectView" args="objectView">
			<![CDATA[
			if (this.objectDefinition != null) {
				var i = this.objectViews.indexOf(objectView);
				if (i >= 0) {
					this.objectViews.splice(i, 1);
				}
				
				if (this.objectDefinition.reference) {
					var ref = this.getReferencedObject();
					if (ref && ref != this) {
						ref.unregisterObjectView(objectView);
					}
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Checks if the data element associated with this model object is set. If it is set,
			the element will be parsed.
		-->
		<method name="checkParsedData">
			<![CDATA[
			if (this.unparsedObjects != null) {
				this.parseDataElement();
			}
			]]>
		</method>

		<!---
			Destroy this object. This method will send the "beingDestroyed" event on this object.
			@keywords private
		-->
		<method name="destroy">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "destroy");
			}
			
			this.release();
			
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "SEVERE", "wcfModelObject", "destroy", "Unexpected wcfModelObject destroy from "+arguments.caller.name);
			
			delete this.updateReadOnlyDel;
			delete this.updateDisplayNameDel;
			delete this.updateLongDisplayNameDel;
			delete this.updateChildObjectListsDel;
			delete this.updateReferencesListsDel;
			delete this.updateFilteredChildObjectsDel;
			delete this.updateTemplateTypeDel;
			delete this.onLanguageChangeDel;
			delete this.updateAccessRightDel;
			delete this.checkOpenGroupReadOnlyDel;
			delete this.updateLogMessagesCallbackDel;
			delete this.setDefaultPropertyValuesDel;
			delete this.updateDisplayNameStyleDel;
			delete this.checkLoadedChildrenDel;
			delete this.updateRefreshTimerDel;
			delete this.refreshTimeoutDel;
			delete this.loadLanguageSensitiveChildrenDel;
			
			if (typeof(this["checkErrorsCallbackDel"]) != "undefined") {
				delete this.checkErrorsCallbackDel;
				this.checkErrorsCallbackCount = 0;
			}
			
			super.destroy();
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "destroy");
			}				
			]]>
		</method>
		
		<!---
			Releases this object. This method will send the "beingDestroyed" event on this object.
			@event beingDestroyed
			@keywords private
		-->
		<method name="release">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "release");
			}
			this.releasing = true;
			this.beingDestroyed.sendEvent(this);
			
			if (this.newObject && this.objectDefinition.reference) {
				var referencedObject = this.getReferencedObject();
				if (!referencedObject["releasing"] && referencedObject.open && referencedObject.newObject && !referencedObject.viewed) {
					var deleteReferencedObject = true;
					for (var refKey in referencedObject.referenceMap) {
						var ref = referencedObject.referenceMap[refKey];
						if (!ref.objectDefinition.organizational && ref != this) {
							deleteReferencedObject = false;
							break;
						}
					}
					if (deleteReferencedObject) {
						this.removeChild(referencedObject);
						referencedObject.deleteObject(false);
					}
				}
			}
			
			this.updateFilteredChildObjectsDel.unregisterAll();
			this.checkLoadedChildrenDel.unregisterAll();

			for (var key in this.referenceMap) {
				var o = this.referenceMap[key];
				if (o.getReferencedObject() == this) {
					var referenceOpenGroupObject = o.openGroupObject;
					var dirty = o.hasUnsavedChanges();
					wcfModelUtil.releaseModelObject(o);
					if (dirty && referenceOpenGroupObject != null && referenceOpenGroupObject != this) {
						referenceOpenGroupObject.checkUnsavedChanges();
					}
				}
				else {
					o.removeChild(this);
				}
			}
			for (var i = 0; i < this.orderedChildObjectKeys.length; i++) {
				var key = this.orderedChildObjectKeys[i];
				var o = this.childObjectMap[key];
				if (typeof(o) != "undefined") {
					if (o.parentObject == this) {
						o.parentObject = null;
						wcfModelUtil.releaseModelObject(o);
					}
					else {
						o.removeReference(this);
					}
				}
			}

			
			this.discardPendingTransactions();

			if (this.open) {
				this.setAttribute("open", false);
			}
			if (this.updateLogMessagesCallbackAdded) {
				wcfCallbackUtil.cancelCallback(this.updateLogMessagesCallbackDel);
				this.updateLogMessagesCallbackAdded = false;
			}
			this.clearLogMessages();

			if (this.objectDefinition.primary || this.objectDefinition.organizational) {
				// Object map only keeps track of primary or organizational objects
				if (this.model.objectMap[this.objectKey] == this) {
					delete this.model.objectMap[this.objectKey];
				}
			}
			if (this.objectDefinition.organizational) {
				if (this.model.organizationalObjectMap[this.objectKey] == this) {
					delete this.model.organizationalObjectMap[this.objectKey];
				}
			}
			
			if (this.parentObject) {
				this.parentObject.removeChild(this);
			}
			
			if (this.updateChildObjectListsCallbackCount > 0) {
				wcfCallbackUtil.cancelCallback(this.updateChildObjectListsDel);
			}
			if (this.updateReferencesListsCallbackCount > 0) {
				wcfCallbackUtil.cancelCallback(this.updateReferencesListsDel);
			}
			
			if (typeof(this["checkErrorsCallbackDel"]) != "undefined" && this.checkErrorsCallbackCount > 0) {
				wcfCallbackUtil.cancelCallback(this.checkErrorsCallbackDel);
				this.checkErrorsCallbackCount = 0;
			}
			
			var releaseProperties = [];
			for (var key in this.propertyMap) {
				releaseProperties.push(this.propertyMap[key]);
			}
			for (var i = 0; i < releaseProperties.length; i++) {
				wcfModelUtil.releaseModelProperty(releaseProperties[i]);
			}

			while (this.childModelObjectLists.length > 0) {
				this.releaseViewFromChildren(this.childModelObjectLists[0].v);
			}
			while (this.referenceListBindings.length > 0) {
				this.releaseViewFromReferences(this.referenceListBindings[0].list.v);
			}
			
			this.updateReadOnlyDel.unregisterAll();
			this.updateDisplayNameDel.unregisterAll();
			this.updateLongDisplayNameDel.unregisterAll();
			this.updateTemplateTypeDel.unregisterAll();
			this.onLanguageChangeDel.unregisterAll();
			if (this["updateAccessRightDel"]) {
				this.updateAccessRightDel.unregisterAll();
			}		
			this.checkOpenGroupReadOnlyDel.unregisterAll();
			this.setDefaultPropertyValuesDel.unregisterAll();
			this.updateDisplayNameStyleDel.unregisterAll();
			if (this["updateRefreshTimerDel"]) {
				this.updateRefreshTimerDel.unregisterAll();
				lz.Timer.removeTimer(this.refreshTimeoutDel);
			}
			
			this.loadLanguageSensitiveChildrenDel.unregisterAll();
			
			if (this.openGroupObject && this.openGroupObject.messagesLogged) {
				messageLogger.clearModelObjectMessages(this);
			}
			this.model = null;
			this.objectDefinition = null;
			this.objectType = "";
			this.objectId = "";
			this.objectVersionId = "";
			this.objectKey = "";
			this.objectDisplayName = null;
			this.lowerCaseDisplayname = null;
			this.objectLongDisplayName = null;
			this.displayNameStyle = null;
			this.objectReadOnly = null;
			this.objectDeletable = null;
			this.readOnly = false;
			this.openGroupReadOnly = false;
			this.childModelObjectLists = [];
			this.referenceListBindings = [];
			this.getChildrenServicesLoading = [];
			this.getChildrenServicesLoaded = [];
			this.getChildrenServicesFailed = [];
			this.referencesStale = true;
			this.referencesLoaded = false;
			this.pendingDelete = false;
			this.childObjectListsStale = false;
			this.referenceListsStale = false;
			this.parentObject = null;
			this.referenceMap = {};
			this.references = [];
			this.newObject = false;
			this.implicitNewObject = false;
			this.open = false;
			this.isOpenInCompareView = false;
			this.childObjectMap = {};
			this.orderedChildObjectKeys = [];
			this.childObjects = [];
			this.propertyMap = {};
			this.templateObject = null;
			this.openGroupObject = null;
			this.errorInOpenGroup = false;
			this.openGroupError = null;
			this.clientErrors = [];
			this.serverErrors = [];
			this.openGroupDirty = false;
			this.changeToDirtyTime = 0;
			this.transaction = null;
			this.pendingTransactions = [];
			this.creating = false;
			this.deleting = false;
			this.lockCount = 0;
			this.referenceCount = 0;
			this.openChildCount = 0;
			this.openGroupInitiated = false;
			this.viewState = "";
			this.loadChildrenStatusObjects = [];
			this.loadReferencesStatusObjects = [];
			this.rawDataPropertyMap = {};
			this.messagesLogged = false;
			this.loadChildrenLanguageMap = {};
			this.objectViews = [];
			this.forceParseData = false;
			this.deferredElements = [];
			this.templateType = "";
			this.objectStoreId = "";
			this.changeControlModifiable = null;
			this.fileref = null;
			this.testObject = false;
			this.viewed = false;
			this.lastViewedTime = 0;
			this.moveable = true;
			this.refreshing = false;
			this.hasAccessRight = true;
			this.openGroupPartiallyEditable = false;
			this.updateChildObjectListsCallbackCount = 0;
			this.updateReferencesListsCallbackCount = 0;
			this.hasReleasableChildren = false;
			this.modelInitializationIdentifier = 0;
			this.unparsedObjects = null;
			this.defaultLanguageObject = null;
			this.parentPrimaryObject = null;
			this.postSaveFailed = false;
			this.postSaveTransaction = null;
			this.releasing = false;
			this.referencedObject = null;
			this.localContext = undefined;
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "release");
			}				
			]]>
		</method>
		
		<!---
			@keywords private
			
			Validates this object and optionally the properties in this object.
			@param validateProperties "true" if the properties of this object should be validated. False otherwise.
		-->
		<method name="validate" args="validateProperties=true">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "validate(validateProperties)", [validateProperties]);
			}
			*/
			if (!this.testObject && this.openGroupObject != null && !this.openGroupObject.refreshing && !global["noValidation"]) {
				if (!this.objectDefinition.primary || (this.isGetChildrenServicesLoaded(this.objectDefinition.getOpenGroupObjectDefinitions()) && this.referencesLoaded)) {
					var validators = this.objectDefinition.validators;
					for (var i = 0; i < validators.length; i++) {
						validators[i].validate(this);
					}
				}
				
				if (validateProperties && this.objectDefinition.propertyDefinitions) {
					for (var key in this.objectDefinition.propertyDefinitions) {
						var pDef = this.objectDefinition.getPropertyDefinition(this, key);
						if (pDef && pDef.validators.length > 0) {
							var prop = this.propertyMap[pDef.propertyName];
							if (prop) {
								prop.validate(false);
							}
							else if (!pDef.checkPropertyValue(this, this.getPropertyValue(pDef.propertyName))) {
								this.getProperty(pDef.propertyName).validate(false);
							}
						}
					}
				}
			}
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "validate(validateProperties)");
			}
			*/				
			]]>
		</method>

		<!---
			@keywords private
			Returns "true" if this object is the top object of an open group.
			@return boolean "true" if this object is the open group object.
		 -->
		<method name="isOpenGroupObject"><![CDATA[
			return this == this.openGroupObject;
			]]>
		</method>
				
		<!---
			@keywords private
			Add this object's validation errors to the message logger. This method will be called recursively for
			all the object's in the open group.
		-->
		<method name="addLogMessages">
			<![CDATA[
			if (!this.messagesLogged) {
				this.messagesLogged = true;
				this.validate(true);
				this.addPropertyLogMessages();
				var isVersionObject = this.getIsVersionObject();
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.addLogMessages();
					}
				}
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.addPropertyLogMessages();
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Adds this object's property validation errors to the message logger.
		-->
		<method name="addPropertyLogMessages">
			<![CDATA[
			for (var i = 0; i < this.serverErrors.length; i++) {
				messageLogger.logValidationError(this.serverErrors[i], this, null, null);
			}
			for (var i = 0; i < this.clientErrors.length; i++) {
				var error = this.clientErrors[i];
				messageLogger.logValidationError(error.message, this, null, error.validator);
			}
			for (var key in this.propertyMap) {
				var property = this.propertyMap[key];
				if (property.serverErrors.length > 0) {
					for (var i = 0; i < property.serverErrors.length; i++) {
						messageLogger.logValidationError(property.serverErrors[i], this, property, null);
					}
				}
				else {
					for (var i = 0; i < property.clientErrors.length; i++) {
						var error = property.clientErrors[i];
						messageLogger.logValidationError(error.message, this, property, error.validator);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Clears this object's messages from the message logger.
		-->		
		<method name="clearLogMessages">
			<![CDATA[
			if (this.messagesLogged) {
				this.messagesLogged = false;
				this.clearServiceErrors();
				messageLogger.clearModelObjectMessages(this);
				var isVersionObject = this.getIsVersionObject();
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.clearLogMessages();
					}
				}
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.clearServiceErrors();
						messageLogger.clearModelObjectMessages(o);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Add a deferred callback to update the log messages.
		 -->
		<method name="updateLogMessages">
			<![CDATA[
			if (!this.updateLogMessagesCallbackAdded) {
				this.updateLogMessagesCallbackAdded = true;
				wcfCallbackUtil.addDeferredCallback(this.updateLogMessagesCallbackDel, null, wcfCallbackUtil.PRIORITY_FOREGROUND);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the message logger. If the object is open, then validation errors associated with this object are added to
			the message logger. If the object is closed, then validation errors removed from the model object and service
			errors are cleared.
		 -->
		<method name="updateLogMessagesCallback" args="e=null">
			<![CDATA[
			this.updateLogMessagesCallbackAdded = false;
			this.clearLogMessages();
			if (this.openGroupObject != null && this.openGroupObject.open && !this.refreshing) {
				this.addLogMessages();
			}
			]]>
		</method>
		
		<!---
			Registers a validation error for the specified validator. Each
			validator can register only one error message. A "null" value for the
			validator indicates that the message has been reported by a service.
			There is no limit to the number of service errors.
			
			@param wcfValidator validator validator that generates the given error message
			@param string errorMsg the error message of the validation error to be registered
			@event onvalidationErrors if the error is added and the event onvalidationErrors exists
		-->
		<method name="addValidationError" args="validator, errorMsg">
			<![CDATA[
			var update = false;
			var error = null;
			if (validator != null) {
				for (var i = 0; i < this.clientErrors.length; i++) {
					if (this.clientErrors[i].validator == validator) {
						error = this.clientErrors[i];
						if (error.message != errorMsg) {
							error.message = errorMsg;
							update = true;
						}
						break;
					}
				}
				if (error == null) {
					error = {message:errorMsg, validator:validator};
					this.clientErrors.push(error);
					update = true;
				}
			}
			else {
				this.serverErrors.push(errorMsg);
				update = true;
			}
			if (update) {
				if (this.openGroupObject) {
					this.checkErrors();
					if (this.openGroupObject.messagesLogged) {
						messageLogger.logValidationError(errorMsg, this, null, validator);
					}
				}
				if (this["onvalidationErrors"]) {
					this.onvalidationErrors.sendEvent();
				}
			}
			]]>
		</method>
		
		<!---
			Returns an array of the validation errors in this object.
			@return String[] an array of all validation errors in this node. An empty array if
				no validation errors.
		-->
		<method name="getValidationErrors">
			<![CDATA[
			var errors = [];
			for (var i = 0; i < this.serverErrors.length; i++) {
				errors.push(this.serverErrors[i]);
			}
			for (var i = 0; i < this.clientErrors.length; i++) {
				var error = this.clientErrors[i];
				errors.push(error.message);
			}
			return errors;
			]]>
		</method>
		
		<!---
			Finds all the validation errors that are created by the validators with the given validator type
			in this model object.
			@param String[] a list of validator types. Each validator type is a string. See {@link wcfValidator#validatorType}
				for description of validator types.
			@return String[] A list of validation errors that are created by the validators with the given validator types. Empty
				array if none is found. Each validation error describes what this error is, and is NL-enabled.
		 -->
		<method name="getValidationErrorsByValidatorTypes" args="validatorTypes"><![CDATA[
			if(typeof(validatorTypes) == "undefined" || validatorTypes == null){
				return [];
			}
			
			var result = [];
			for(var i = 0; i < this.clientErrors.length; ++i){
				var error = this.clientErrors[i];
				var validator = error.validator;
				if(validator["validatorType"]){
					for(var j = 0; j < validatorTypes.length; ++j){
						if(validator.validatorType == validatorTypes[j]){
							result.push(error.message);
						}
					}
				}
			}
			return result;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if this object has any validation error.
			@param boolean ignoreServiceErrors if "true", ignore errors reported by service requests
			@return boolean "true" if there are validation errors
		-->
		<method name="hasValidationError" args="ignoreServiceErrors">
			<![CDATA[
			var hasError = false;
			if (ignoreServiceErrors) {
				hasError = this.clientErrors.length > 0;
			}
			else {
				hasError = this.clientErrors.length > 0 || this.serverErrors.length > 0;
			}
			return hasError;
			]]>
		</method>
		
		<!---
			Removes the validator error for the specified validator. The errors associated
			with the given validator in this object and in the message console will be
			cleared for the open group object of this object. The event onvalidationErrors
			will be sent out if this event exists.
			
			@param wcfValidator validator The validator used to identify the validation errors to be removed.
			@event onvalidationError
		-->
		<method name="clearValidationError" args="validator">
			<![CDATA[
			var update = false;
			if (validator != null) {
				for (var i = 0; i < this.clientErrors.length; i++) {
					if (this.clientErrors[i].validator == validator) {
						update = true;
						this.clientErrors.splice(i, 1);
						i--;
					}
				}
			}
			else {
				if (this.serverErrors.length > 0) {
					this.serverErrors = [];
					update = true;
				}
			}
			if (update) {
				this.checkErrors();
				if (this.openGroupObject && this.openGroupObject.messagesLogged) {
					messageLogger.clearValidationError(this, null, validator);
				}
				if (this["onvalidationErrors"]) {
					this.onvalidationErrors.sendEvent();
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Clear service errors for this object.
		-->
		<method name="clearServiceErrors">
			<![CDATA[
			this.clearValidationError(null);
			for (var key in this.propertyMap) {
				var property = this.propertyMap[key];
				property.clearValidationError(null);
			}
			]]>
		</method>
	
		<!---
			@keywords private
			Check to see whether there are server errors for this object.
			@return boolean "true" if the object has server errors
		-->
		<method name="hasServiceErrors">
			<![CDATA[
			var propertyErrors = false;
			for (var key in this.propertyMap) {
				var property = this.propertyMap[key];
				if (property.serverErrors.length > 0 || property.clientErrors.length > 0) {
					propertyErrors = true;
					break;
				}
			}
			return propertyErrors || this.serverErrors.length > 0;
			]]>
		</method>
	
		<!---
			@keywords private
			Sets the top object for the open group to which this object belongs.
		-->
		<method name="initOpenGroupObject">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "initOpenGroupObject");
			}
			*/
			if (this.openGroupObject == null) {
				var o = this;
				do {
					var oDef = o.objectDefinition;
					if (oDef.openGroupTop) {
						this.openGroupObject = o;
						for (var key in this.childObjectMap) {
							var childObject = this.childObjectMap[key];
							childObject.initOpenGroupObject();
						}
						this.checkOpenGroupPartiallyEditable();
						this.updateLogMessages();
						break;
					}
					if (oDef.referencedDefinitions != null && (oDef.parentReference || oDef.collectionReference)) {
						var i = 0;
						var referencedObject = null;
						while (!referencedObject && i < o.objectDefinition.referencedDefinitions.length) {
							referencedObject = o.getObject(o.objectDefinition.referencedDefinitions[i].objectType);
							i++;
						}
						o = referencedObject;
					}
					else {
						o = o.parentObject;
					}
				} while (o);
				this.updateAccessRight();
				this.updateReadOnly();
			}
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "initOpenGroupObject");
			}
			*/				
			]]>
		</method>
		
		<!---
			@keywords private
			Bind the specified view to the children of this model object.
			@param view v the view to be bound
			@param wcfFilter filter an optional filter. If the given view doesn't have object list, this filter will be used to create a new
				object list.
			@param string objectTypes optional comma separated list of object types. These types are used to determine which objects should be bound.
			@param object sortComparator the sort comparator. This comparator is used to sort the objects in the newly created object list, if
				the given view doesn't have a object list yet.
		-->
		<method name="bindViewToChildren" args="v, filter=null, objectTypes=null, sortComparator=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "bindViewToChildren(v, filter, objectTypes)", [v, filter, objectTypes]);
			}
			var baseFilter = null;
			if (filter != null) {
				baseFilter = filter;
			}
			var objectSelectors = null;
			var objectDefinitions = null;
			if (objectTypes) {
				objectSelectors = this.model.getObjectSelectors(this, objectTypes);
			}
			this.referenceCount++;
			if (wcfLogger.enabled) {
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "bindViewToChildren(v, filter, objectTypes)", "Increment reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
			}
			var list = v["oList"];
			if (list) {
				list.setAttribute("baseFilter", baseFilter);
				list.setAttribute("objectSelectors", objectSelectors);
				list.setAttribute("modelObjects", this.childObjects);
				list.setAttribute("sortComparator", sortComparator);
			}
			else {
				list = new lz.wcfModelObjectList(v, {
					v: v,
					baseFilter: baseFilter,
					objectSelectors: objectSelectors,
					modelObjects: this.childObjects,
					sortComparator: sortComparator,
					pageController: this
				});
			}
			v.setAttribute("parentO", this);
			this.childModelObjectLists.push(list);
			this.updateChildObjectListStatus(list);
			
			list.loadChildren();
			list.onreset.sendEvent();
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "bindViewToChildren(v, filter, objectTypes)");
			}				
			]]>
		</method>

		<!---
			@keywords private
			Bind the specified view to the references to this model object.
			param view v: the view to be bound
			@param wcfFilter filter an optional filter. If the given view doesn't have object list, this filter will be used to create a new
				object list.
			@param string referenceObjectPaths comma separated list of reference object paths
		-->
		<method name="bindViewToReferences" args="v, filter, referenceObjectPaths">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "bindViewToReferences(v, filter, referenceObjectPaths)", [v, filter, referenceObjectPaths]);
			}
			if (typeof(filter) == "undefined") {
				filter = null;
			}
			var baseFilter = null;
			if (filter != null) {
				baseFilter = filter;
			}
			var paths = null;
			if (referenceObjectPaths) {
				paths = [];
				var refObjPaths = wcfStringUtil.splitAndTrim(referenceObjectPaths, ",");
				for (var i = 0; i < refObjPaths.length; i++) {
					var path = [];
					var types = refObjPaths[i].split("/");
					for (var j = 0; j < types.length; j++) {
						path.unshift(types[j]);
					}
					paths.push(path);
				}
			}
			this.referenceCount++;
			if (wcfLogger.enabled) {
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "bindViewToReferences(v, filter, referenceObjectPaths)", "Increment reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
			}
			var list = v["oList"];
			if (list) {
				list.setAttribute("baseFilter", baseFilter);
			}
			else {
				list = new lz.wcfModelObjectList(v, {
					v: v,
					baseFilter: baseFilter
				});
			}
			var binding = {
				list: list,
				paths: paths,
				intermediateObjects: [],
				updateIntermediateReferencesDel: new lz.Delegate(this, "updateIntermediateReferences"),
				releaseIntermediateObjectDel: new lz.Delegate(this, "releaseIntermediateObject")
			};
			this.referenceListBindings.push(binding);
			this.updateReferenceListBinding(binding);
			this.loadReferences();
			list.onreset.sendEvent();
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "bindViewToReferences(v, filter, referenceObjectPaths)");
			}				
			]]>
		</method>
		
		<!---
			@keywords private
			
			Releases the specified view from list of child objects.
			@param view v the view to be released.
		-->
		<method name="releaseViewFromChildren" args="v">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "releaseViewFromChildren(v)", [v]);
			}
			var lists = this.childModelObjectLists;
			for (var i = 0; i < lists.length; i++) {
				if (lists[i].v == v) {
					v.setAttribute("parentO", null);
					lists[i].setAttribute("modelObjects", []);
					lists[i].setAttribute("statusObject", null);
					lists.splice(i, 1);
					this.referenceCount--;
					if (wcfLogger.enabled) {
						wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "releaseViewFromChildren(v)", "Decrement reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
					}
					break;
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "releaseViewFromChildren(v)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Releases the specified view from list of references.
			@param view v the view to be released
		-->
		<method name="releaseViewFromReferences" args="v">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "releaseViewFromReferences(v)", [v]);
			}
			var bindings = this.referenceListBindings;
			for (var i = 0; i < bindings.length; i++) {
				var binding = bindings[i];
				if (binding.list.v == v) {
					binding.list.setAttribute("modelObjects", []);
					this.releaseIntermediateObjects(binding);
					for (var prop in binding) {
						delete binding[prop];
					}
					bindings.splice(i, 1);
					this.referenceCount--;
					if (wcfLogger.enabled) {
						wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "releaseViewFromReferences(v)", "Decrement reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
					}
					break;
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "releaseViewFromReferences(v)");
			}
			]]>
		</method>

		<!---
			@keywords private
			Gets the data language Ids for unloaded languages for the current language context
			@param wcfGetChildrenService service the get children service that will be called for the languages
			@param boolean all Optional parameter when "true" forces all the languages to load
			@return String a comma delimited string of data language ids
		-->
		<method name="getDataLanguageIds" args="service, all">
			<![CDATA[
			var dataLanguageIds = "";
			var context = wcfContextUtil.findContext(this);
			if (context != null && context.storeConfig != null) {
				var languagesContext = all ? context.getContextValue("storeLanguageIds") : context.getContextValue("inputLanguageIds");
				var dataLanguages = context.storeConfig.getLanguagesById((languagesContext != null) ? languagesContext.value : "");
				var missingPages = false;
				if (all) {
					for (var k = 0; k < this.loadChildrenStatusObjects.length; k++) {
						var statusObject = this.loadChildrenStatusObjects[k];
						if (statusObject.service == service) {
							if (statusObject.lastPageNum != 1) {
								missingPages = true;
							}
							break;
						}
					}
				}
				
				for(var i = 0; i < dataLanguages.length; i++){
					var language = dataLanguages[i];
					var services = this.loadChildrenLanguageMap[language.languageId];
					if (missingPages || typeof(services) == "undefined" || services.indexOf(service) == -1) {
						if (dataLanguageIds.length > 0) {
							dataLanguageIds += ",";
						}
						dataLanguageIds += language.languageId;
					}
				}
			}
			
			return dataLanguageIds;
			]]>
		</method>
		
		<!---
			@keywords private
			Mark the specified data language IDs as requested for the specified service.
			@param wcfGetChildrenService service for which the language has been requested
			@param string languageIds Comma separated list of language IDs
		-->
		<method name="setRequestedDataLanguageIds" args="service, languageIds">
			<![CDATA[
			var ids = languageIds.split(",");
			for (var i = 0; i < ids.length; i++) {
				var services = this.loadChildrenLanguageMap[ids[i]];
				if (typeof(services) == "undefined") {
					services = [];
					this.loadChildrenLanguageMap[ids[i]] = services;
				}
				if (services.indexOf(service) == -1) {
					services.push(service);
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Clear the requested data language IDs for the specified service.
			@param wcfGetChildrenService service for which the data language ids should be cleared
		-->
		<method name="clearRequestedDataLanguageIds" args="service">
			<![CDATA[
			for (var id in this.loadChildrenLanguageMap) {
				var services = this.loadChildrenLanguageMap[id];
				for (var i = 0; i < services.length; i++) {
					if (services[i] == service) {
						services.splice(i, 1);
						break;
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Checks the given get children service to see if its stale
			@param wcfGetChildrenService service the get children service to check
			@return boolean "true" if the children service is stale
		-->
		<method name="isGetChildrenServiceStale" args="service">
			<![CDATA[
			for (var i = 0; i < this.getChildrenServicesLoaded.length; i++) {
				if (this.getChildrenServicesLoaded[i] == service) {
					return false;
				}
			}
			
			for (var i = 0; i < this.getChildrenServicesLoading.length; i++) {
				if (this.getChildrenServicesLoading[i] == service) {
					return false;
				}
			}

			return true;
			]]>
		</method>	
		
		<!---
			@keywords private
			Sets the the get children services for this object as loaded
		-->
		<method name="setGetChildrenServicesLoaded">
			<![CDATA[
			var services = this.objectDefinition ? this.objectDefinition.getChildrenServices : null;
			if (services && services.length > 0) {
				for (var i = 0; i < services.length; i++) {
					this.spliceGetChildrenServiceLoaded(services[i]);
					this.clearRequestedDataLanguageIds(services[i]);
					var loaded = true;
					var objectDefinitions = services[i].getObjectDefinitions(this.objectDefinition);
					if (objectDefinitions.length > 0) {
						loaded = false;
						for (var j = 0; j < objectDefinitions.length; j++) {
							if (!objectDefinitions[j].deferLoad) {
								loaded = true;
								break;
							}
						}
						for (var j = 0; !loaded && j < this.childModelObjectLists.length; j++) {
							var objectSelectors = this.childModelObjectLists[j].objectSelectors;
							if (objectSelectors != null && objectSelectors.length > 0) {
								for (var k = 0; k < objectSelectors.length; k++) {
									if (objectDefinitions.indexOf(objectSelectors[k].objectDefinition) != -1) {
										loaded = true;
										break;
									}
								}
							}
						}
					}
					if (loaded) {
						this.getChildrenServicesLoaded.push(services[i]);
						var storeLanguageIdsContext = wcfContextUtil.findContextValue(this, "storeLanguageIds");
						this.setRequestedDataLanguageIds(services[i], storeLanguageIdsContext != null ? storeLanguageIdsContext.value : "");
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the corresponding children services for the given object definition as stale
			@param wcfObjectDefinition oDef The object definition
			@param boolean reload trigger the reload
		-->
		<method name="setGetChildrenServicesStale" args="oDef,reload=true">
			<![CDATA[
			var services = this.objectDefinition ? this.objectDefinition.getChildrenServices : null;
			if (services.length == 0 && !this.objectDefinition.primary && !this.objectDefinition.organizational) {
				this.parentObject.setGetChildrenServicesStale(this.objectDefinition);
			}
			else {
				if (services && services.length > 0) {
					for (var i = 0; i < services.length; i++) {
						if (oDef == null || services[i].matchesObjectDefinition(this.objectDefinition, oDef)) {
							this.spliceGetChildrenServiceLoaded(services[i]);
							this.clearRequestedDataLanguageIds(services[i]);
						}
					}
				}
				if (reload && this.modelInitializationIdentifier == this.model.initializationIdentifier) {
					var doLoadChildren = (oDef == null && this.childModelObjectLists.length > 0);
					for (var i = 0; !doLoadChildren && i < this.childModelObjectLists.length; i++) {
						var objectSelectors = this.childModelObjectLists[i].objectSelectors;
						if (objectSelectors == null || objectSelectors.length == 0) {
							doLoadChildren = true;
						}
						else {
							for (var j = 0; j < objectSelectors.length; j++) {
								if (objectSelectors[j].objectDefinition == oDef) {
									doLoadChildren = true;
									break;
								}
							}
						}
					}
					if (doLoadChildren) {
						if (oDef != null) {
							this.loadChildren([oDef]);
						}
						else {
							this.loadChildren();
						}
					}
				}
			}
			]]>
		</method>
				
		<!---
			@keywords private
			Loads this object's children.
			@param [wcfObjectDefinition] oDefs optional array of object definitions to load
			@param boolean getAll Optional parameter when "true" forces all the languages and children to load 
			@param boolean refresh Optional parameter when "true" only loads get children services marked for refresh, object definitions are ignored
			@param boolean strictMatch: if "true" services with no object types specified will not match the object definitions
			@param integer pageNum: the page number to be loaded.
		-->
		<method name="loadChildren" args="oDefs=null, getAll=false, refresh=false, strictMatch=false, pageNum=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "loadChildren");
			}
			
			if (refresh) {
				this.loadChildrenLanguageMap = {};
			}
			
			var serviceRequests = [];
			
			if (!this.newObject || (this.implicitNewObject && this.parentPrimaryObject != null && !this.parentPrimaryObject.newObject)) {
				var services = this.objectDefinition ? this.objectDefinition.getChildrenServices : null;
				if (services && services.length > 0) {
					if (refresh) {
						var reload = !this.objectDefinition.organizational || this.childModelObjectLists.length > 0;
						for (var i = 0; i < this.getChildrenServicesLoaded.length; i++) {
							if (reload) {
								serviceRequests.push(this.getChildrenServicesLoaded[i]);
							}
						}
						for (var i = 0; i < this.getChildrenServicesFailed.length; i++) {
							if (reload) {
								serviceRequests.push(this.getChildrenServicesFailed[i]);
							}
						}
						this.getChildrenServicesLoaded = [];
						this.getChildrenServicesFailed = [];
					}
					else {
						for (var i = 0; i < services.length; i++) {
							if (services[i].matchesObjectDefinitions(this.objectDefinition, oDefs, strictMatch)) {
								if (this.isGetChildrenServiceStale(services[i])) {
									this.spliceGetChildrenServiceFailed(services[i]);
									serviceRequests.push(services[i]);
								}
								else if (services[i].isLanguageSensitive(this.objectDefinition) && this.getDataLanguageIds(services[i], getAll).length > 0) {
									this.spliceGetChildrenServiceLoaded(services[i]);
									serviceRequests.push(services[i]);
								}else if (getAll) {
									this.spliceGetChildrenServiceLoaded(services[i]);
									serviceRequests.push(services[i]);
								}
							}
						}
					}

					if (serviceRequests.length > 0) {
						var checkLoadedChildrenRequired = false;
						for (var i = 0; i < serviceRequests.length; i++) {
							var submitRequest = true;
							var startIndex = 0;
							for (var j = 0; j < this.loadChildrenStatusObjects.length; j++) {
								if (this.loadChildrenStatusObjects[j].service == serviceRequests[i]) {
									var statusObject = this.loadChildrenStatusObjects[j];
									if (pageNum != null) {
										var maxRecordSetTotal = statusObject.service.getMaxRecordSetTotal();
										if (statusObject.currPageNum > 0 && statusObject.currPageNum < pageNum) {
											var maxItems = statusObject.service.getMaxItems();
											startIndex = statusObject.startIndex + (maxRecordSetTotal * (pageNum - statusObject.currPageNum))
															- Math.ceil(statusObject.deleteCount/maxItems)*maxItems;
										} else {
											startIndex = maxRecordSetTotal * (pageNum-1);
										}
										if (startIndex >= statusObject.totalRecords) {
											submitRequest = false;
										}
									}
									statusObject.deleteCount = 0;
									statusObject.currPageNum = 0;
									statusObject.lastPageNum = 0;
									statusObject.startIndex = 0;
									if (statusObject.serviceObjectList != null) {
										statusObject.serviceObjectList = null;
										checkLoadedChildrenRequired = true;
									}
									break;
								}
							}
							if (submitRequest) {
								this.getChildrenServicesLoading.push(serviceRequests[i]);
								var dataLanguageIds = this.getDataLanguageIds(serviceRequests[i], getAll);
								this.setRequestedDataLanguageIds(serviceRequests[i], dataLanguageIds);
								serviceRequests[i].doRequest(this, {dataLanguageIds:dataLanguageIds}, {startIndex:startIndex, getAll:getAll});
							}
						}
						if (checkLoadedChildrenRequired) {
							this.checkLoadedChildren();
						}
					}
				}
			}
			
			if (serviceRequests.length == 0 && this["onGetChildrenServiceCompleted"]) {
				this.onGetChildrenServiceCompleted.sendEvent();
			}

			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "loadChildren");
			}
			]]>
		</method>
		
		<!---
			@keywords private
		-->		
		<method name="isGetChildrenServicesLoaded" args="oDefs, all=false">
			<![CDATA[
			if (this.newObject) {
				return true;
			}
			
			var services = this.objectDefinition ? this.objectDefinition.getChildrenServices : null;
			if (services && services.length > 0) {
				for (var i = 0; i < services.length; i++) {
					if (services[i].matchesObjectDefinitions(this.objectDefinition, oDefs)) {
						var found = false;
						for (var j = 0; j < this.getChildrenServicesLoaded.length; j++) {
							if (this.getChildrenServicesLoaded[j] == services[i]) {
								if (!services[i].isLanguageSensitive(this.objectDefinition) || this.getDataLanguageIds(services[i], all).length == 0) {
									found = true;
									if (all) {
										for (var k = 0; k < this.loadChildrenStatusObjects.length; k++) {
											var statusObject = this.loadChildrenStatusObjects[k];
											if (statusObject.service == services[i]) {
												if (statusObject.lastPageNum != 1) {
													found = false;
												}
												break;
											}
										}
									}
								}
								break;
							}
						}
						
						if (!found) {
							return false;
						}
					}
				}
			}
			return true;
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method name="isGetChildrenServicesLoading">
			<![CDATA[
			return this.getChildrenServicesLoading.length > 0;
			]]>
		</method>

		<!---
			@keywords private
		-->		
		<method name="spliceGetChildrenServiceLoading" args="service">
			<![CDATA[
			for (var i = 0; i < this.getChildrenServicesLoading.length; i++) {
				if (this.getChildrenServicesLoading[i] == service) {
					this.getChildrenServicesLoading.splice(i, 1);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
		-->		
		<method name="spliceGetChildrenServiceLoaded" args="service">
			<![CDATA[
			for (var i = 0; i < this.getChildrenServicesLoaded.length; i++) {
				if (this.getChildrenServicesLoaded[i] == service) {
					this.getChildrenServicesLoaded.splice(i, 1);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
		-->		
		<method name="spliceGetChildrenServiceFailed" args="service">
			<![CDATA[
			for (var i = 0; i < this.getChildrenServicesFailed.length; i++) {
				if (this.getChildrenServicesFailed[i] == service) {
					this.getChildrenServicesFailed.splice(i, 1);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Sets up childrens populated by the serice that gets children. This method is
			called by the get children service when its request has been completed.
			@param wcfGetChildrenService service: the service that gets children of this object
			@param number startIndex: the index of the first object of the current page
			@param number totalObjects: the total number of child objects available - if the results are paged this will be greater than the number loaded
			@param boolean recordSetComplete: to indicate whether all record sets loaded	
		-->
		<method name="childrenServiceRequestCompleted" args="service, startIndex, totalRecords, recordSetComplete">
			<![CDATA[
			if (wcfLogger.enabled) {
				wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject"
					, "childrenServiceRequestCompleted(service, startIndex, totalRecords, recordSetComplete)"
					, [service, startIndex, totalRecords, recordSetComplete]);
			}
			// set index to correct numeric value if not available
			if (isNaN(totalRecords)) {
				totalRecords = 0;
			}
			if (isNaN(startIndex) || (startIndex > 0 && totalRecords == 0)) {
				startIndex = -1;
			}
			var maxRecordSetTotal = service.getMaxRecordSetTotal();
			var currPageNum = Math.ceil((startIndex+maxRecordSetTotal) / maxRecordSetTotal);
			var lastPageNum = currPageNum;
			if (startIndex == 0 && recordSetComplete) {
				lastPageNum = 1;
			}
			else if (startIndex + maxRecordSetTotal < totalRecords) {
				lastPageNum += Math.ceil((totalRecords-startIndex-maxRecordSetTotal)/maxRecordSetTotal);
			}
			
			var currPageNum = Math.ceil(startIndex/maxRecordSetTotal)+1;
			var statusObject;
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				statusObject = this.loadChildrenStatusObjects[i];
				if (statusObject.service == service) {
					statusObject.hasError = false;
					statusObject.message = null;
					statusObject.messageForTree = null;
					statusObject.startIndex = startIndex;
					statusObject.totalRecords = totalRecords;
					statusObject.currPageNum = currPageNum;
					statusObject.lastPageNum = lastPageNum;
					break;
				}
			}

			this.spliceGetChildrenServiceLoading(service);
			
			var found = false;
			for (var i = 0; i < this.getChildrenServicesLoading.length; i++) {
				if (this.getChildrenServicesLoading[i] == service) {
					found = true;
					break;
				}
			}
			
			if (!found) {
				this.getChildrenServicesLoaded.push(service);
				this.childObjectListsStale = true;
				this.updateChildObjects(true);
			
				if (this.isGetChildrenServicesLoaded(this.objectDefinition.getOpenGroupObjectDefinitions()) && !this.childObjectListsStale) {
					this.validate(false);
					this.checkErrors();
				}
			
				if (this["onGetChildrenServiceCompleted"]) {
					this.onGetChildrenServiceCompleted.sendEvent(service);
				}
			}
			
			if (wcfLogger.enabled) {
					wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "childrenServiceRequestCompleted(service, startIndex, totalRecords, recordSetComplete)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			
			Called by the get children service when its request has been completed
			@param wcfGetReferencesService service the service that gets children.
			@param string message status message to be displayed to the user
		-->
		<method name="childrenServiceRequestError" args="service,message=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "childrenServiceRequestError(service)", [service]);
			}
			var serviceFound = false;
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				var statusObject = this.loadChildrenStatusObjects[i];
				if (statusObject.service == service) {
					if (statusObject.serviceObjectList != null) {
						statusObject.serviceObjectList = null;
						this.checkLoadedChildren();
					}
					serviceFound = true;
					if (message) {
						statusObject.message = message;
						statusObject.messageForTree = null;
						statusObject.hasError = true;
						statusObject.startIndex = 0;
						statusObject.totalRecords = 0;
						statusObject.deleteCount = 0;
						statusObject.currPageNum = -1;
						statusObject.lastPageNum = -1;
					}
					else {
						this.loadChildrenStatusObjects.splice(i, 1);
					}
					break;
				}
			}
			if (!serviceFound && message) {
				this.loadChildrenStatusObjects.push({
					service: service,
					serviceObjectList: null,
					message: message,
					messageForTree: null,
					hasError: true,
					startIndex: 0,
					totalRecords: 0,
					deleteCount: 0,
					currPageNum: -1,
					lastPageNum: -1
				});
			}

			this.spliceGetChildrenServiceLoading(service);
			
			var found = false;
			for (var i = 0; i < this.getChildrenServicesFailed.length; i++) {
				if (this.getChildrenServicesFailed[i] == service) {
					found = true;
					break;
				}
			}
			
			if (!found) {
				this.getChildrenServicesFailed.push(service);
			}
			
			if (service.isLanguageSensitive(this.objectDefinition)) {
				this.loadChildrenLanguageMap = {};
			}
			
			if (this["onGetChildrenServiceError"]) {
				this.onGetChildrenServiceError.sendEvent(service);
			}
			if (message) {
				this.childObjectListsStale = true;
				this.updateChildObjects(true);
			}

			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "childrenServiceRequestError(service)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Load this object's references.
		-->
		<method name="loadReferences">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "loadReferences", [this.referencesStale,this.newObject]);
			}
			if (this.referencesStale && !this.newObject) {
				this.referencesLoaded = false;
				this.referencesStale = false;
				this._getReferenceServiceRequests = [];
				var services = this.objectDefinition ? this.objectDefinition.getReferencesServices : null;
				if (services && services.length > 0) {
					for (var i = 0; i < services.length; i++) {
						this._getReferenceServiceRequests.push(services[i]);
					}
					for (var i = 0; i < services.length; i++) {
						services[i].doRequest(this);
					}
				}
				else {
					this.setAttribute("referencesLoaded", true);
				}
			}
			else if (this.newObject) {
				this.setAttribute("referencesLoaded", true);
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "loadReferences",[this.referencesLoaded]);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Call-back method that is called by the get reference service when its request has been completed.
			@keywords private the service that gets references.
		-->
		<method name="referenceServiceRequestCompleted" args="service">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "referenceServiceRequestCompleted(service)", [service]);
			}

			for (var i = 0; i < this._getReferenceServiceRequests.length; i++) {
				if (this._getReferenceServiceRequests[i] == service) {
					this._getReferenceServiceRequests.splice(i, 1);
					break;
				}
			}
			
			if (this._getReferenceServiceRequests.length == 0) {
				this.setAttribute("referencesLoaded", true);
				this.validate(false);
				this.checkErrors();
			}
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "referenceServiceRequestCompleted(service)");
			}
			]]>
		</method>
		
		
		<!---
			@keywords private
			Call-back method that is called by the get reference service when its request has returned with errors.
			@param wcfGetReferencesService service the service that gets references.
			@param string message status message to be displayed to the user
		-->
		<method name="referenceServiceRequestError" args="service,message=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "referenceServiceRequestError(service)", [service]);
			}
			var serviceFound = false;
			for (var i = 0; i < this.loadReferencesStatusObjects.length; i++) {
				if (this.loadReferencesStatusObjects[i].service == service) {
					serviceFound = true;
					if (message) {
						this.loadReferencesStatusObjects[i].message = message;
						this.loadReferencesStatusObjects[i].hasError = true;
					}
					else {
						this.loadReferencesStatusObjects.splice(i, 1);
					}
					break;
				}
			}
			if (!serviceFound && message) {
				this.loadReferencesStatusObjects.push({service: service, message: message, hasError: true});
			}

			for (var i = 0; i < this._getReferenceServiceRequests.length; i++) {
				if (this._getReferenceServiceRequests[i] == service) {
					this._getReferenceServiceRequests.splice(i, 1);
					break;
				}
			}
			if (message) {
				this.referenceListsStale = true;
				this.updateReferences();
			}
			if (this._getReferenceServiceRequests.length == 0) {
				this.setAttribute("referencesLoaded", true);
			}

			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "referenceServiceRequestError(service)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Parses the specified data element attributes for this object, and sets the objectReadOnly attribute
			if the element has its readonly attribute set and sets the moveable attribute.
			@param XML e the data element to be parsed.
		-->
		<method name="parseAttributes" args="e">
			<![CDATA[
			var attrReadOnly = e.attributes["readonly"];
			if (typeof(attrReadOnly) != "undefined") {
				if (this.objectReadOnly != attrReadOnly) {
					this.setAttribute("objectReadOnly", attrReadOnly);
				}
			}
			var attrMoveable = e.attributes["moveable"];
			if (typeof(attrMoveable) != "undefined") {
				var newMoveable = attrMoveable != "false";
				if (this.moveable != newMoveable) {
					this.setAttribute("moveable", newMoveable);
				}
			}
			var attrDeletable = e.attributes["deletable"];
			if (typeof(attrDeletable) != "undefined") {
				if (this.objectDeletable != attrDeletable) {
					this.setAttribute("objectDeletable", attrDeletable);
				}
			}			
			]]>
		</method>
		
		<!---
			@keywords private
			Parses the specified data element and add any properties and child objects found from parsing to this object.
			@param XML e the data element to be parsed.
			@param boolean lazyParse if "true" pass lazy parsing to child objects
			@param boolean createAsNew: If "true" created the parsed objects as new objects
		-->
		<method name="parseDataElement" args="e=null,lazyParse=false,createAsNew=false">
			<![CDATA[
			if (e) {
				this.parseProperties(e);
			}
			if (this.unparsedObjects != null && (!lazyParse || wcfModelUtil.isParseRequired(this))) {				
				this.parseObjects(lazyParse, null, createAsNew);
				this.updateChildObjects();
			}
			if (e) {
				this.parseAttributes(e);
			}
			]]>
		</method>
		
		<!---
			Parse any unparsed child objects.

			@param boolean lazyParse: if true do lazy parsing
			@param string type: the object type to be parsed
			@param boolean createAsNew: If true created the parsed objects as new objects
		-->
		<method name="parseObjects" args="lazyParse, type, createAsNew=false">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "parseObjects(lazyParse, type)");
			}
			if (this.unparsedObjects != null) {
				var elements = this.unparsedObjects;
				if (!type) {
					this.unparsedObjects = null;
				}
				for (var i = 0; i < elements.length; i++) {
					var e = elements[i];
					if (e.nodeName == "object") {
						if (type) {
							var doParse = false;
							var objectType = e.attributes["objectType"];
							if (objectType == type) {
								doParse = true;
							}
							else {
								var od = this.model.getObjectDefinition(this, objectType, true);
							 	if (od && od.matchesType(type)) {
							 		doParse = true;
							 	}
							}
							if (doParse) {
								elements.splice(i, 1);
								i--;
								this.model.parseObject(e, this, lazyParse, createAsNew);
							}
						}
						else {
							this.model.parseObject(e, this, lazyParse, createAsNew);
						}
					}
					else if (!type && e.nodeName == "reference") {
						var o = this.model.parseObject(wcfXMLUtil.getFirstElement(e, "object"), null, false, false, this.objectVersionId, this.localContext);
						if (o == null) {
							wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "SEVERE", "wcfModelObject", "parseObjects", "Error parsing reference " + e);
						}
						else {
							o.addChild(this);
						}
					}
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "parseObjects(lazyParse, type)");
			}				
			]]>
		</method>
		
		<!---
			@keywords private
			Parses the specified data element and create property objects for any child elements found.
			Child elements that are named "object" are ignored.
			@param XML e the data element to be parsed.
		-->
		<method name="parseProperties" args="e=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "parseProperties(e)", [e]);
			}
			if (this.unparsedObjects == null) {
				this.unparsedObjects = [];
			}
			var unparsedProperties = [];
            var nodes = e.childNodes;
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var propertyName = node.nodeName;
                if (propertyName == "object" || propertyName == "reference" || propertyName == "parent") {
                    this.unparsedObjects.push(node);
                }
                else {
                    unparsedProperties.push(node);
                }
            }

            var propChanged = false;
            var objectKeyChanged = false;
            for (var i = 0; i < unparsedProperties.length; i++) {
                var node = unparsedProperties[i];
                var propertyName = node.nodeName;
				var propertyValue = wcfXMLUtil.getNodeValue(node);
                var attrReadOnly = node.attributes["readonly"];
                if (typeof(attrReadOnly) == "undefined") {
                    attrReadOnly = null;
                }

                var property = this.propertyMap[propertyName];
                if (property) {
                    if ((!property.dirty || property.transaction != null) && property.value != propertyValue) {
                    	this._parsing = true;
                        property.setAttribute("value", propertyValue);
                        this._parsing = false;
                    }
                    property.setAttribute("propertyReadOnly", attrReadOnly);
                }
                else if (propertyValue != "" || attrReadOnly != null || typeof(this.objectDefinition.defaultPropertyValues[propertyName]) != "undefined") {
                    var rawData = this.rawDataPropertyMap[propertyName];
                    if (!rawData) {
                        rawData = {};
                        this.rawDataPropertyMap[propertyName] = rawData;
                    }
                    propChanged = propChanged || rawData["propertyValue"] != propertyValue;
                    rawData.propertyValue = propertyValue;
                    rawData.propertyReadOnly = attrReadOnly;
                    rawData.trimmed = false;
                }
                else if (this.rawDataPropertyMap[propertyName]) {
                    delete this.rawDataPropertyMap[propertyName];
                }
                if (propertyName == this.objectDefinition.idProperty) {
                	objectKeyChanged = true;
                }
            }
            if (objectKeyChanged) {
            	this.updateObjectId(true);
            }
            if (propChanged && this["propertyChanged"]) {
                this.propertyChanged.sendEvent();
            }
            this.parseObjectStoreId();
            this.parseChangeControlModifiableProperty();
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "parseProperties(e)");
			}
			]]>
		</method>	

		<!---
			@keywords private
			Update display name style based on the {@link wcfDisplayNameStyle}
			configuration.
		-->
		<method name="updateDisplayNameStyle" args="e=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateDisplayNameStyle(e)", [e]);
			}
			this.updateDisplayNameStyleDel.unregisterAll();
			var newDisplayNameStyle = null;
			var o = this.getReferencedObject();
			if (o != null) {
				for (var i = 0; i < o.objectDefinition.displayNameStyles.length; i++) {
					var style = o.objectDefinition.displayNameStyles[i];
					style.registerDelegate(o, this.updateDisplayNameStyleDel);
					if (style.isEnabled(o)) {
						newDisplayNameStyle = style;
						break;
					}
				}
			}
			if (newDisplayNameStyle != this.displayNameStyle) {
				this.setAttribute("displayNameStyle", newDisplayNameStyle);
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateDisplayNameStyle(e)");
			}
			]]>
		</method>		
		<!---
			@keywords private
			This method parses the value of the object store identifier.
		-->
		<method name="parseObjectStoreId">
			<![CDATA[
				if (wcfLogger.enabled) {
					wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "parseObjectStoreId", [this.objectKey]);
				}
				var storeId = this.getPropertyValue("objectStoreId");
				if (storeId != this.objectStoreId && wcfStringUtil.isInteger(storeId)) {
					this.setAttribute("objectStoreId", storeId);
				}
			
				if (wcfLogger.enabled) {
					wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "parseObjectStoreId", [this.objectReadOnly, this.readOnly, this.objectStoreId]);
				}
			]]>
		</method>
		
		<!---
			@keywords private
			This method to parse the value of the change control modifiable property.
		-->
		<method name="parseChangeControlModifiableProperty">
			<![CDATA[
				if (wcfLogger.enabled) {
					wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "parseChangeControlModifiableProperty", [this.objectKey]);
				}
				var modifiable = this.getPropertyValue("changeControlModifiable");
				if (modifiable != "" && modifiable != this.changeControlModifiable) {
					this.setAttribute("changeControlModifiable", modifiable);
					this.checkOpenGroupPartiallyEditable();
				}
				if (wcfLogger.enabled) {
					wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "parseChangeControlModifiableProperty", [this.readOnly, this.changeControlModifiable]);
				}
			]]>
		</method>
		
		<!---
			@keywords private
			Initializes this model object from its template.
			@param wcfModelObject templateObject The source object to be used to create the current object
			@param boolean changeDisplayNameProperty "true" or undefined if the property used for display name should be changed.
		-->
		<method name="initFromTemplate" args="templateObject, changeDisplayNameProperty">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "initFromTemplate(templateObject, changeDisplayNameProperty)", [templateObject, changeDisplayNameProperty]);
			}
			
			if(templateObject.objectDefinition.hasChildDefinitions()) {
				for (var i = 0; i < this.orderedChildObjectKeys.length; i++) {
					var key = this.orderedChildObjectKeys[i];
					var o = this.childObjectMap[key];
					if (typeof(o) != "undefined") {
						if(templateObject.objectDefinition.getChildDefinition(o.objectType) && !o.objectDefinition.primary && !o.pendingDelete) {
							o.deleteObject();
						}
					}
				}
			}
			
			templateObject.checkParsedData();
			var propertyValues = templateObject.getPropertyValues();
			for (var propertyName in propertyValues) {
				var newPropertyName = null;
				if (propertyName == templateObject.objectDefinition.displayNameProperty && this.objectDefinition.displayNameProperty) {
					newPropertyName = this.objectDefinition.displayNameProperty;
				}
				else {
					newPropertyName = propertyName;
				}
			
				var copyProperty = true;
				
				var pDef = templateObject.objectDefinition.getPropertyDefinition(templateObject, propertyName);
				if (propertyName == templateObject.objectDefinition.idProperty && !templateObject.objectDefinition.languageSensitive) {
					copyProperty = pDef && !pDef.copyProtected;
				}
				else if (newPropertyName == this.objectDefinition.displayNameProperty && templateObject.objectDefinition.displayNameProperty && propertyName != templateObject.objectDefinition.displayNameProperty) {
					copyProperty = false;
				}
				else if (propertyName == "objectStoreId" && this.objectType != templateObject.objectType) {
					// this means we did a conversion to a compatible type so we should not copy the objectStoreId,
					// instead we should set the objectStoreId to current storeId.
					copyProperty = false;
					var context = wcfContextUtil.findContext(this);
					var storeConfig = context != null ? context.storeConfig : null;
					if (storeConfig != null) {
						var propertyValue = storeConfig.storeId;
						var property = this.propertyMap[propertyName];
						if (property) {
							property.setAttribute("value", propertyValue);
						}
						else {
							var rawData = this.rawDataPropertyMap[propertyName];
							if (!rawData) {
								rawData = {};
								this.rawDataPropertyMap[propertyName] = rawData;
							}
							rawData.propertyValue = propertyValue;
							rawData.propertyReadOnly = false;
							rawData.trimmed = false;
						}
					}
				}
				else if (propertyName == "changeControlModifiable" || propertyName == "changeControlWorkspaceName" ||
						 propertyName == "changeControlWorkspaceTaskGroup" || propertyName == "changeControlWorkspaceTask" ||
						 propertyName == "basedOnVersionNumber" || propertyName == "basedOnVersionName" ||
						 propertyName == "objectVersionId" || propertyName == "objectVersionNumber") {
					copyProperty = false;
				}
				else {
					copyProperty = !pDef || (pDef && !pDef.copyProtected);
				}
				
				var defaultPropertyValue = null;
				
				if (!copyProperty && typeof(this.objectDefinition.defaultPropertyValues[newPropertyName]) != "undefined") {
					defaultPropertyValue = this.objectDefinition.defaultPropertyValues[newPropertyName];
				}

				if (copyProperty || defaultPropertyValue != null) {
					var propertyValue = null;
					var changeProperty = false;
					if (copyProperty) {
						if (newPropertyName == this.objectDefinition.displayNameProperty && changeDisplayNameProperty) {
							propertyValue = foundationResources.replaceValues("templateCopyOf", [propertyValues[propertyName]]);							
						}
						else {
							propertyValue = propertyValues[propertyName];
						}
						
						if(newPropertyName == this.objectDefinition.templateTypeProperty &&
								propertyName != templateObject.objectDefinition.templateTypeProperty){
							changeProperty = true;
						}
					}
					else {
						propertyValue = defaultPropertyValue;
					}
					var property = this.propertyMap[newPropertyName];
					if (property) {
						if(changeProperty){
							property.change(propertyValue);
						}else{
							property.setAttribute("value", propertyValue);
						}
					}
					else {
						var newRawData = {};
						newRawData.propertyValue = propertyValue;
						newRawData.propertyReadOnly = false;
						newRawData.trimmed = false;
						this.rawDataPropertyMap[newPropertyName] = newRawData;
					}
				}
			}
			
			var templateObjectIsVersionObject = templateObject.getIsVersionObject();
			for (var i = 0; i < templateObject.orderedChildObjectKeys.length; i++) {
				var key = templateObject.orderedChildObjectKeys[i];
				var o = templateObject.childObjectMap[key];
				if (typeof(o) != "undefined") {
					if (o.objectDefinition.primary) {
						this.addChild(o, false);
					}
					else if (!o.pendingDelete && !o.objectDefinition.parentReference && !o.objectDefinition.collectionReference && !o.objectDefinition.copyProtected && (templateObjectIsVersionObject || !o.getIsVersionObject())) {
						var newObject = null;
						var objectDef = this.model.getObjectDefinition(this, o.objectDefinition.objectType);
						if (objectDef) {
							var propertyDef = objectDef.getPropertyDefinition(this, objectDef.idProperty);
							if (objectDef.languageSensitive || (propertyDef && !propertyDef.copyProtected)) {
								newObject = this.model.createObject(this, objectDef, o.objectId, true);
							}
							else {
								newObject = this.model.createNewObject(objectDef, this, false);
							}
							newObject.initFromTemplate(o, false);
						}
					}
				}
			}

			this.updateChildObjects();

			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "initFromTemplate(templateObject, changeDisplayNameProperty)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Revert this object to a new object. Server managed properties such as the ID property will
			be removed and the newObject attribute will be reset to true.
		-->
		<method name="revertToNewObject">
			<![CDATA[
			var oDef = this.objectDefinition;
			if (!this.objectDefinition.languageSensitive) {
				var propertyName = this.objectDefinition.idProperty;
				var prop = this.propertyMap[propertyName];
				if (prop) {
					if (prop.value != "") {
						prop.setAttribute("value", "");
					}
				}
				else {
					delete this.rawDataPropertyMap[propertyName];
				}
			}
			for (var propertyName in this.objectDefinition.propertyDefinitions) {
				var pDef = this.objectDefinition.getPropertyDefinition(this, propertyName);
				if (pDef && pDef.serverManaged) {
					var prop = this.propertyMap[propertyName];
					if (prop) {
						if (prop.value != "") {
							prop.setAttribute("value", "");
						}
					}
					else {
						delete this.rawDataPropertyMap[propertyName];
					}
				}
			}
			transaction.o.setAttribute("newObject", true);
			]]>
		</method>
		
		<!---
			@keywords private
			Returns a saveable parent primary object.
		-->
		<method name="getSaveableParentPrimaryObject">
			<![CDATA[
			var saveableParentPrimaryObject = null;
			if (this.objectDefinition.saveParentPrimaryObject && this.viewed) {
				var po = this.getParentPrimaryObject();
				if (po && this.openGroupObject != po.openGroupObject && po.openGroupObject.openGroupDirty) {
					saveableParentPrimaryObject = po;
				}
			}
			return saveableParentPrimaryObject;
			]]>
		</method>
		
		<!---
			@keywords private
			Saves the object including its children. If the saved object is an open group object and contains validation
			error, a confirmation box will be prompt, unless the argument prompt is set to false. Before any value is
			actually saved, the event beingSaved will be sent out.
			
			@param boolean prompt False if no dialog window should be popped up when a validation error is present while this
				model object is an open group object. Otherwise, a dialog window will be shown.
			@param boolean saveRelatedObjects true if the save should ensure that related objects are saved
			@event beingSaved
		-->
		<method name="saveObject" args="prompt=true, saveRelatedObjects=true">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "saveObject");
			}
			if (!this["saveObjectLock"]) {
				this.saveObjectLock = true;
				
				var doSaveObject = true;
				
				if (this.isOpenGroupObject()) {
					this.beingSaved.sendEvent(this);
				}
				
				if (prompt && this.isOpenGroupObject() && this.hasErrors(true)) {
					wcfSaveWithErrorConfirmationDialog.openSaveWithErrorConfirmationDialog(this);
					doSaveObject = false;					
				}
											
				if (doSaveObject) {
					if (saveRelatedObjects) {
						var unsavedOpenAncestors = this.getUnsavedOpenAncestors();
						for (var i = 0; i < unsavedOpenAncestors.length; i++) {
							unsavedOpenAncestors[i].saveObject(false, true);
						}
						var saveableParentPrimaryObject = this.getSaveableParentPrimaryObject();
						if (saveableParentPrimaryObject != null) {
							saveableParentPrimaryObject.saveObject(false, true);
						}
					}
					if (this.objectDefinition["saveHandler"] != null) {
						this.objectDefinition.saveHandler.save(this);
					}
					else {
						if (!this.pendingDelete) {
							for (var key in this.childObjectMap) {
								var o = this.childObjectMap[key];
								if (!o.getIsVersionObject() && o.objectDefinition.reference && !o.objectDefinition.parentReference && !o.objectDefinition.collectionReference) {
									var referencedObject = o.getReferencedObject();
									if (referencedObject != null && (referencedObject.newObject || (!referencedObject.viewed && referencedObject.isOpenGroupObject() && referencedObject.openGroupDirty))) {
										referencedObject.saveObject(false, false);
									}
								}
							}
						}
						
						var saveChildren = !this.objectDefinition.parentReference && !this.objectDefinition.collectionReference;
						if (this.newObject && !this.creating) {
							if (this.objectDefinition.createService != null) {
								this.objectDefinition.createService.doRequest(this);	
							}
						}
						else if (this.pendingDelete) {
							if (this.objectDefinition.deleteService != null) {
								this.objectDefinition.deleteService.doRequest(this);
							}
							saveChildren = false;
						}
						else {
							if (this.objectDefinition.saveService != null) {				
								this.objectDefinition.saveService.doRequest(this);							
							}
						}
						if (saveChildren) {
							var saveObjects = [];
							for (var key in this.referenceMap) {
								var o = this.referenceMap[key];
								var oDef = o.objectDefinition;
								if (!o.getIsVersionObject() && (oDef.parentReference || oDef.collectionReference)) {
									//add reference objects pending delete to the end
									if (o.pendingDelete) {
										saveObjects.push(o);
									}
									else {
										saveObjects.unshift(o);
									}
								}
							}
							for (var i = 0; i < saveObjects.length; i++) {
								var o = saveObjects[i];
								var oDef = o.objectDefinition;
								o.saveObject(false, saveRelatedObjects && oDef.collectionReference);
							}
							saveObjects = [];
							for (var key in this.childObjectMap) {
								var o = this.childObjectMap[key];
								
								if (o.getIsVersionObject()) {
									continue;
								}
								
								if (o.parentObject == this && o.openGroupObject == this.openGroupObject) {
									saveObjects.push(o);
								}
								else if (o.objectDefinition.parentReference || o.objectDefinition.collectionReference) {
									var referencedObject = o.getReferencedObject();
									if (saveRelatedObjects && !referencedObject.viewed && referencedObject.isOpenGroupObject() && referencedObject.openGroupDirty) {
										referencedObject.saveObject(false, false);
									}
								}
								else if (!o.viewed && o.parentObject == this && o.isOpenGroupObject() && o.openGroupDirty) {
									saveObjects.push(o);
								}
							}
							if (saveObjects.length > 0) {
								wcfModelUtil.sortObjectsBySaveOrder(saveObjects);
								for (var i = 0; i < saveObjects.length; i++) {
									saveObjects[i].saveObject(false, false);
								}
							}					
						}
					}
					if (!this.pendingDelete){
						if (this.objectDefinition.postSaveService != null) {
							this.objectDefinition.postSaveService.doRequest(this);																
						}
					}
					
					if (!this.viewed && this.open) {
						this.closeObject(false);
					}

					if (this.isOpenGroupObject()) {
						this.checkUnsavedChanges();
					}
				}
				
				this.saveObjectLock = false;
			}
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "saveObject");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			True if the current object is deleting or whether its referenced object is deleting.
			@param lz.Delegate del The
		-->
		<method name="isDeleting" args="del=null">
			<![CDATA[
			var isDeletingBool = false;
			if (this.objectDefinition != null) {
				if (del) {
					del.register(this, "ondeleting");
				}
				if (this.deleting) {
					isDeletingBool = true;
				}
				if (!isDeletingBool && this.objectDefinition.reference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null && referencedObject.isDeleting(del)) {
						isDeletingBool = true;
					}
				}
			}
			return isDeletingBool;
			]]>
		</method>

		<!---
			@keywords private
			Deletes this object including its children.
			@param boolean prompt Prompt the user to confirm the delete action. The default is false.
			@param boolean immediate Whether the delete service request for child objects should be sent immediately or not. The default is false.
		-->
		<method name="deleteObject" args="prompt=false, immediate=false">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "deleteObject(prompt, immediate)", [prompt, immediate]);
			}
			var openGroupObject = this.openGroupObject;
			if (this.newObject && !this.creating) {
				if (prompt && openGroupObject != null && openGroupObject == this) {
					wcfDeleteConfirmationDialog.openDeleteConfirmationDialog(this);
				} else {
					wcfModelUtil.releaseModelObject(this);
					if (openGroupObject != null && openGroupObject != this) {
						openGroupObject.checkUnsavedChanges();
					}
				}
			}
			else if (this.objectDefinition.deleteService && (immediate || openGroupObject == this)) {
				if (prompt && openGroupObject != null && openGroupObject == this) {
					wcfDeleteConfirmationDialog.openDeleteConfirmationDialog(this);
				}
				else {
					this.objectDefinition.deleteService.doRequest(this);
				}
			}
			else if (this.parentObject != null) {
				this.pendingDelete = true;
				this.parentObject.childObjectListsStale = true;
				this.parentObject.updateChildObjects();
				if (this.openGroupObject != null) {
					if (this.openGroupObject.messagesLogged) {
						messageLogger.clearModelObjectMessages(this);
					}
					this.openGroupObject.setAttribute("open", true);
					this.openGroupObject.setAttribute("openGroupDirty", true);
				}
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == null && !o.getIsVersionObject()) {
						o.referenceListsStale = true;
						o.updateReferences();
					}
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "deleteObject(prompt, immediate)");
			}
			]]>
		</method>

		<!---
			@keywords private
			Restore this object if it is pending delete.
		-->
		<method name="undeleteObject">
			<![CDATA[
				if (this.pendingDelete && this.parentObject != null) {
					this.pendingDelete = false;
					this.parentObject.childObjectListsStale = true;
					this.parentObject.updateChildObjects();
					if (this.openGroupObject != null) {
						if (this.openGroupObject.messagesLogged) {
							this.addPropertyLogMessages();
						}
						this.openGroupObject.checkUnsavedChanges();
						if (!this.openGroupObject.viewed && !this.openGroupObject.openGroupDirty && this.openGroupObject.open) {
							this.openGroupObject.closeObject(false);
						}
					}
					for (var key in this.childObjectMap) {
						var o = this.childObjectMap[key];
						if (o.parentObject == null) {
							o.referenceListsStale = true;
							o.updateReferences();
						}
					}
				}
			]]>
		</method>

		<!---
			@keywords private
			Gets the reference object that matches the specified object definition and referenced
			object. This may include pending delete reference objects. If no such object exists, then null is returned.
			@param wcfObjectDefinition refDef the reference object definition
			@param wcfModelObject o referenced object
		-->
		<method name="getMatchingReferenceObject" args="refDef, o">
			<![CDATA[
				var ro = null;
				for (var key in this.childObjectMap) {
					var childObject = this.childObjectMap[key];
					if (childObject.objectDefinition == refDef && childObject.getReferencedObject() == o) {
						ro = childObject;
						break;
					}
				}
				return ro;
			]]>
		</method>

		<!---
			@keywords private
			Returns "true" if this object has any unsaved changes. The children and references of this object will be searched too.
			@return boolean "true" if the object has unsaved changes
		-->
		<method name="hasUnsavedChanges">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "hasUnsavedChanges");
			}
			var unsavedChanges = (this.pendingDelete && !this.deleting) ||
					(this.newObject && !this.implicitNewObject && !this.creating) ||
					this.hasUnsavedPropertyChanges();
					
			if (!unsavedChanges) {
				unsavedChanges = (this.postSaveFailed && this.postSaveTransaction == null);
			}	
							
			if (!unsavedChanges) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject() && o.hasUnsavedChanges()) {
						unsavedChanges = true;
						break;
					}
				}
			}
			if (!unsavedChanges) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if (((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject) && !o.getIsVersionObject() &&
						((o.newObject && !o.creating) || (o.pendingDelete && !o.deleting) || o.hasUnsavedPropertyChanges())) {
						unsavedChanges = true;
						break;
					}
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "hasUnsavedChanges", unsavedChanges);
			}
			return unsavedChanges;
			]]>
		</method>

		<!---
			@keywords private
			Returns "true" if this object has any unsaved property changes.
			@return boolean "true" if the object has unsaved property changes
		-->
		<method name="hasUnsavedPropertyChanges">
			<![CDATA[
			var unsavedChanges = false;
			if(!this.pendingDelete){
				for (var key in this.propertyMap) {
					var prop = this.propertyMap[key];
					if (prop.dirty && prop.transaction == null) {
						unsavedChanges = true;
						break;
					}
				}
			}
			return unsavedChanges;
			]]>
		</method>

		<!---
			@keywords private
			Checks if there are unsaved changes in the open group and updates the "openGroupDirty" attribute.			
			@param boolean dirty: pass in true if the caller knows that we have unsaved changes. Don't
				pass in this argument if the caller has committed or rolled back a change and is checking to see if
				there are still other unsaved changes
		-->
		<method name="checkUnsavedChanges" args="dirty=false">
			<![CDATA[
			if (this.openGroupObject != null) {
				var newOpenGroupDirty = dirty ? dirty : this.openGroupObject.hasUnsavedChanges();
				if (newOpenGroupDirty != this.openGroupObject.openGroupDirty) {
					this.openGroupObject.setAttribute("openGroupDirty", newOpenGroupDirty);					
				}		
			}
			]]>
		</method>		
		
		<!--- 
			@keywords private
			Returns a boolean value indicating if this openGroup object is dirty or not. 
			If the flag of checkDescendants is set to true, then this method looks at the model's 
			open objects which are descendants of this object to see if any one of them
			is dirty. 
			@param boolean checkDescendants: set to true if the caller wants to include the 
			model's open objects that are descendants of this object in the check for dirty property. 
		-->
		<method name="isOpenGroupDirty" args="checkDescendants=false">
			<![CDATA[			
			var newOpenGroupDirty = false;
			if(this.openGroupObject != null){
				newOpenGroupDirty = this.openGroupObject.openGroupDirty;
				if(!newOpenGroupDirty && checkDescendants){
					var currentOpenObjects = this.model.openObjects;
					for (var i = 0; i < currentOpenObjects.length; i++) {			
						var o = currentOpenObjects[i];
						if(o.openGroupDirty && this.openGroupObject.isDescendant(o)){
							newOpenGroupDirty = true;
							break;
						}
					}				
				}				
			}
			return newOpenGroupDirty;			
			]]>		
		</method>
		
		<!---
			@keywords private
			Returns "true" if this object has any validation errors.
			@param boolean ignoreServiceErrors if "true", ignore errors reported by service requests
			@return boolean "true" if the object has validation errors.
		-->
		<method name="hasErrors" args="ignoreServiceErrors=false">
			<![CDATA[
			var hasErrors = this.hasValidationError(ignoreServiceErrors) || this.hasPropertyErrors(ignoreServiceErrors);
			var isVersionObject = this.getIsVersionObject();
		 	if (!hasErrors) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (!o.pendingDelete && o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject()) && o.hasErrors(ignoreServiceErrors)) {
						hasErrors = true;
						break;
					}
				}
		 	}
			if (!hasErrors) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if (!o.pendingDelete && (oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject()) &&
						(o.hasValidationError(ignoreServiceErrors) || o.hasPropertyErrors(ignoreServiceErrors))) {
						hasErrors = true;
						break;
					}
				}
			}
			return hasErrors;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if this object has any property errors.
			@param boolean ignoreServiceErrors if "true", ignore errors reported by service requests
			@return boolean "true" if the object has property errors.
		-->
		<method name="hasPropertyErrors" args="ignoreServiceErrors">
			<![CDATA[
			var hasErrors = false;
			for (var key in this.propertyMap) {
				if (this.propertyMap[key].hasValidationError(ignoreServiceErrors)) {
					hasErrors = true;
					break;
				}
			}
			return hasErrors;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns the first error found in this model object. This method will recursively search through
			all the objects in the open group until an error is found.
			@return object the first error object found in this model object
		 -->
		<method name="getError">
			<![CDATA[
			var error = this.getObjectError();
			var isVersionObject = this.getIsVersionObject();
		 	if (error == null) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (!o.pendingDelete && o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						error = o.getError();
						if (error != null) {
							break;
						}
					}
				}
		 	}
			if (error == null) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if (!o.pendingDelete && (oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						error = o.getObjectError();
						if (error != null) {
							break;
						}
					}
				}
			}
			return error;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns the first error found in this model object. If object-level error is found,
			the model object's properties will be searched for errors.
			@return string the message of the first error object found in this model object or in the properties of this model object
		-->
		<method name="getObjectError">
			<![CDATA[
			var error = null;
			if (this.serverErrors.length > 0) {
				error = this.serverErrors[0];
			}
			else if (this.clientErrors.length > 0) {
				error = this.clientErrors[0].message;
			}
			if (error == null) {
				error = this.getPropertyError();
			}
			// display language desc in error code if object is lang sensitive
			if (error != null) {
				var context = wcfContextUtil.findContext(this);
				var storeConfig = context != null ? context.storeConfig : null;
				if (this.objectDefinition.languageSensitive && storeConfig != null) {
					var langId = this.getPropertyValue("languageId");
					if (langId) {
						var langObject = storeConfig.getLanguageById(langId);
						if (langObject) {
							error = error + " (" + langObject.languageDescription + ")";
						}
					}
				}
			}
			return error;
			]]>
		</method>

		<!---
			@keywords private
			To register a language sensitive object to a delegate so that when input language selection is changed,
			it will be removed if it's language specific input is no longer necessary.
		-->
		<method name="checkLanguageSensitiveObject" args="e=null">
			<![CDATA[
			if (!this.hasUnsavedChanges() && this.implicitNewObject) {
				var objLang = this.getPropertyValue("languageId");
				var inputLanguageIdsContext = wcfContextUtil.findContextValue(this, "inputLanguageIds");
				var inputLangs = inputLanguageIdsContext != null ? inputLanguageIdsContext.value.split(",") : [];
				var isInputLang = false;
				for(var i = 0; i < inputLangs.length; i++){
					if (inputLangs[i] == objLang) {
						isInputLang = true;
						break;
					}
				}
				if (!isInputLang) {
					this.onLanguageChangeDel.unregisterAll();
					this.deleteObject();
				}
			}
			]]>
		</method>	
		<!---
			@keywords private
			Gets the validation error first found in a property of this model object. All the properties
			in this model object will be searched until an error is found in a property or until all
			properties are tried. No child object will be searched.
			@return Object the first error object found in a property of this model object
		-->
		<method name="getPropertyError"><![CDATA[
			for(var key in this.propertyMap){
				var errors = this.propertyMap[key].getValidationErrors();
				if(errors.length > 0){
					return errors[0];
				}
			}
			
			return null;
			]]>
		</method>
		
		<!---
			@keywords private
			Add a deferred callback to check errors.
		 -->
		<method name="checkErrors">
			<![CDATA[
			if (this.openGroupObject != null && !this.openGroupObject.isGetChildrenServicesLoading()) {
				if (typeof(this.openGroupObject["checkErrorsCallbackDel"]) == "undefined") {
					this.openGroupObject.checkErrorsCallbackDel = new lz.Delegate(this.openGroupObject, "checkErrorsCallback");
					this.openGroupObject.checkErrorsCallbackCount = 0;
				}
				if (this.openGroupObject.checkErrorsCallbackCount > 0) {
					wcfCallbackUtil.cancelCallback(this.openGroupObject.checkErrorsCallbackDel);	
					this.openGroupObject.checkErrorsCallbackCount--;
				}
				this.openGroupObject.checkErrorsCallbackCount++;
				wcfCallbackUtil.addDeferredCallback(this.openGroupObject.checkErrorsCallbackDel);
			}			
			]]>
		</method>
		<!---
			@keywords private
			Checks if there are any errors in the open group and updates the "errorInOpenGroup" and "openGroupError" attributes.
		-->	
		<method name="checkErrorsCallback" args="e=null">
			<![CDATA[
			var newErrorInOpenGroup = this.hasErrors();
			if (newErrorInOpenGroup != this.errorInOpenGroup) {
				this.setAttribute("errorInOpenGroup", newErrorInOpenGroup);
			}
			var newOpenGroupError = this.getError();
			if (newOpenGroupError != this.openGroupError) {
				this.setAttribute("openGroupError", newOpenGroupError);
			}
			]]>
		</method>

		<!---
			@keywords private
			Returns "true" if this object has any transactions
			@return boolean "true" if the object has any transactions
		-->
		<method name="hasTransaction">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "hasTransaction");
			}
			var hasTransactionBool = (this.transaction != null);
			var isVersionObject = this.getIsVersionObject();
			if (!hasTransactionBool) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject()) && o.hasTransaction()) {
						hasTransactionBool = true;
						break;
					}
				}
			}
			if (!hasTransactionBool) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && o.transaction != null && (isVersionObject || !o.getIsVersionObject())) {
						hasTransactionBool = true;
						break;
					}
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "hasTransaction", hasTransactionBool);
			}
			return hasTransactionBool;
			]]>
		</method>
		
		<!---
			@keywords private
			Adds the specified object to the list of child objects.
			@param wcfModelObject o the new object to be added
			@param boolean update trigger the update of child objects if "true". The default is "true".
		-->
		<method name="addChild" args="o, update=true">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "addChild(o, update)", [o, update]);
			}
			var key = o.objectKey;
			if (this.childObjectMap[key] != o) {
				if (typeof(this.childObjectMap[key]) == "undefined" && this.orderedChildObjectKeys.indexOf(key) == -1) {
					this.orderedChildObjectKeys.push(key);
				}
				this.childObjectMap[key] = o;
				if (o.objectDefinition.primary || o.objectDefinition.organizational) {
					o.addReference(this);
					o.updateReferenceObjectIds();
					if (this.objectDefinition.reference) {
						this.updateDisplayName();
					}
					if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
						this.updateAccessRight();
						this.updateReadOnly();
					}
				}
				else {
					o.parentObject = this;
					if (this.objectDefinition.primary) {
						o.parentPrimaryObject = this;
					}
					else {
						o.parentPrimaryObject = this.parentPrimaryObject;
					}
					if (!o.objectDefinition.openGroupTop) {
						o.initOpenGroupObject();
					}
					else {
						o.updateAccessRight();
						o.updateReadOnly();
					}
					if (o.newObject && o.openGroupObject != null && !o.implicitNewObject) {
						o.openGroupObject.setAttribute("open", true);
						o.openGroupObject.setAttribute("openGroupDirty", true);
					}
					if (o.open) {
						// Update open child counter of the parent object
						var po = o.getParentPrimaryObject();
						po.openChildCount++;
						if (wcfLogger.enabled) {
							wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "addChild(o, update)", "Child object: Object key=" + o.objectKey + ". Increment open child count for: Object key=" + po.objectKey + ", new open child count=" + po.openChildCount);
						}
					}
					if (o.objectDefinition.parentReleaseProtected) {
						// Increment reference count of the parent object
						this.referenceCount++;
						if (wcfLogger.enabled) {
							wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "addChild(o, update)", "Child object: Object key=" + o.objectKey + ". Increment reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
						}
					}
				}
				
				this.childObjectListsStale = true;
				
				if (update) {
					this.updateChildObjects();
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "addChild(o, update)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Removes the specified object from the list of child objects.
			@param wcfModelObject o the object to remove
			@param boolean update trigger update of the child objects if "true". The default is ""true"".
		-->
		<method name="removeChild" args="o, update=true">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "removeChild(o, update)", [o, update]);
			}
			var key = o.objectKey;
			delete this.childObjectMap[key];
			if (o.objectDefinition.primary || o.objectDefinition.organizational) {
				o.removeReference(this);
			}
			else {
				if (o.open) {
					// Update open child counter of the parent object
					var po = o.getParentPrimaryObject();
					po.openChildCount--;
					if (wcfLogger.enabled) {
						wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "removeChild(o, update)", "Child object: Object key=" + o.objectKey + ". Decrement open child count for: Object key=" + po.objectKey + ", new open child count=" + po.openChildCount);
					}
				}
				o.parentObject = null;
				if (o.objectDefinition.parentReleaseProtected) {
					// Decrement parent reference count of the parent object
					this.referenceCount--;
					if (wcfLogger.enabled) {
						wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "removeChild(o, update)", "Child object: Object key=" + o.objectKey + ". Decrement reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
					}
				}
				if (this.defaultLanguageObject == o) {
					this.defaultLanguageObject = null;
				}
			}
			
			this.childObjectListsStale = true;
			
			if (update) {
				this.updateChildObjects();
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "removeChild(o, update)");
			}			
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the list of child objects to reflect changes.
			Views that are bound to the list of child objects will
			be updated.
			@param boolean immediate "true" to update the child objects immediately without a deferred callback
		-->
		<method name="updateChildObjects" args="immediate=false">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateChildObjects");
			}

			if (this.childObjectListsStale && this.lockCount == 0) {
				if (this.updateChildObjectListsCallbackCount > 0) {
					wcfCallbackUtil.cancelCallback(this.updateChildObjectListsDel);	
					this.updateChildObjectListsCallbackCount--;
				}	
	
				this.updateChildObjectListsCallbackCount++;
				if (immediate) {
					this.updateChildObjectLists();
				}
				else {
					wcfCallbackUtil.addDeferredCallback(this.updateChildObjectListsDel);
				}
			}
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateChildObjects");
			}			
			]]>
		</method>
		
		<!---
			@keywords private
			Force the update of the list of child objects. This is called when the filter condition changes for
			one of the child objects.
		-->
		<method name="updateFilteredChildObjects" args="e=null">
			<![CDATA[
			this.childObjectListsStale = true;
			this.updateChildObjects();
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the list of child objects to reflect changes.
			Views that are bound to the list of child objects will
			be updated.
			@event onchildObjects
		-->
		<method name="updateChildObjectLists" args="e=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateChildObjectLists");
			}
			
			this.updateChildObjectListsCallbackCount--;

			if (this.childObjectListsStale) {
				this.childObjects = [];
				var filter = null;
				if (this.objectDefinition.organizational && this.objectDefinition.filters.length > 0) {
					filter = this.objectDefinition.filters[0];
					this.updateFilteredChildObjectsDel.unregisterAll();
				}
				for (var i = 0; i < this.orderedChildObjectKeys.length; i++) {
					var key = this.orderedChildObjectKeys[i];
					var o = this.childObjectMap[key];
					if (typeof(o) == "undefined") {
						this.orderedChildObjectKeys.splice(i, 1);
						i--;
					}
					else if (!o.pendingDelete && (o.objectVersionId == null || o.objectVersionId == "")) {
						if (filter != null) {
							filter.registerDelegate(o, this.updateFilteredChildObjectsDel);
							if (filter.matchesFilter(o)) {
								this.childObjects.push(o);
							}
						}
						else {
							this.childObjects.push(o);
						}
					}
				}
				if (this.childModelObjectLists) {
					var lists = this.childModelObjectLists;
					for (var i = 0; i < lists.length; i++) {
						lists[i].setAttribute("modelObjects", this.childObjects);
						this.updateChildObjectListStatus(lists[i]);
					}
				}
				if (this.objectDefinition.referencedDefinitions != null) {
					this.updateDisplayName();
					this.updateDisplayNameStyle();
				}
				
				this.childObjectListsStale = false;
				
				if (this["onchildObjects"]) {
					this.onchildObjects.sendEvent(this.childObjects);
				}

				this.validate(false);
				this.checkErrors();
				this.checkOpenGroupReadOnly();
			}

			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateChildObjectLists");
			}			
			]]>
		</method>

		<!---
			@keywords private
			Updates the status of the specified model object list.
			@param wcfModelObjectList list
		-->
		<method name="updateChildObjectListStatus" args="list">
			<![CDATA[
			var totalRecords = 0;
			var currPageNum = 0;
			var lastPageNum = 0;
			var hasError = false;
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				var statusObject = this.loadChildrenStatusObjects[i];
				if (statusObject.service.matchesObjectDefinitions(this.objectDefinition, list.getChildObjectDefinitions())) {
					if (statusObject.hasError) {
						list.setAttribute("statusObject", statusObject);
						hasError = true;
						break;
					}
					currPageNum = Math.max(currPageNum, statusObject.currPageNum);
					lastPageNum = Math.max(lastPageNum, statusObject.lastPageNum);
					totalRecords += statusObject.totalRecords;
				} 
			}
			if (!hasError) {			
				if (lastPageNum > 1) {
					list.setAttribute("statusObject", {
						message: foundationResources.replaceValues("serviceOverLimitMsg", [currPageNum, totalRecords]),
						messageForTree: foundationResources.replaceValues("serviceOverLimitMsgForTree", [currPageNum, totalRecords]),
						hasError: false,
						currPageNum: currPageNum,
						lastPageNum: lastPageNum,
						pageController: this
					});
				} else {
					list.setAttribute("statusObject", null);
				}
			}
			]]>
		</method>
				
		<!---
			@keywords private
			Finds the parent object of a given model object.
			@param object the model object whose parent is to be found.
			@return the paretn object of the given object.
		 -->
		<method name="findParentObject" args="object">
			<![CDATA[
				var o = object;
				var found = false;
				while(!found){
					if (o.parentObject != null) {
						o = o.parentObject;
						found = true;
					}
					else {
						found = true;
						var isVersionObject = this.getIsVersionObject();
						for (var key in this.referenceMap) {
							var ref = this.referenceMap[key];
							if(typeof(ref) != "undefined" && !ref.pendingDelete && ref.objectDefinition.parentReference && (isVersionObject ||  !ref.getIsVersionObject())){
								o = ref;
								found = false;
							}
						}
					}
				}
				return o;
			]]>
		</method>		
		
		<!---
			@keywords private
			Updates the object ID of this model object.
		-->
		<method name="updateObjectId" args="parsing=false">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateObjectId");
			}
			
			if (this.modelInitializationIdentifier != 0 && this.modelInitializationIdentifier != this.model.initializationIdentifier) {
				return;
			}

			var newObjectId = this.getPropertyValue(this.objectDefinition.idProperty);
			if (!newObjectId) {
				newObjectId = this.objectId;
			}
			var newObjectKey = this.model.getObjectKey(this.objectDefinition, newObjectId, this.objectVersionId, this.localContext);
			if (this.objectId != newObjectId || this.objectKey != newObjectKey) {
				var oldObjectKey = this.objectKey;
				this.setAttribute("objectId", newObjectId);
				if (this.objectDefinition.primary || this.objectDefinition.organizational) {
					// Object map only keeps track of primary or organizational objects
					delete this.model.objectMap[oldObjectKey];
					this.model.objectMap[newObjectKey] = this;
				}
				if (!this.newObject && parsing && this.parentObject != null && this.parentObject.childObjectMap[newObjectKey] != undefined && this.parentObject.childObjectMap[newObjectKey] != this) {
					wcfModelUtil.releaseModelObject(this.parentObject.childObjectMap[newObjectKey]);
				}
				if (this.parentObject) {
					var keyIndex = this.parentObject.orderedChildObjectKeys.indexOf(oldObjectKey);
					delete this.parentObject.childObjectMap[oldObjectKey];
					var dupCount = 0;
					var k = newObjectKey;
					while (this.parentObject.childObjectMap[k] != undefined && this.parentObject.childObjectMap[k] != this) {
						k = newObjectKey + "DUP_" + dupCount;
						dupCount++;
					}
					this.parentObject.childObjectMap[k] = this;
					
					// avoid duplicate entries
					if(k != oldObjectKey) {
						if(this.parentObject.orderedChildObjectKeys.indexOf(k) == -1) {
							this.parentObject.orderedChildObjectKeys[keyIndex] = k;
						}
						else {
							this.parentObject.orderedChildObjectKeys.splice(keyIndex, 1);
						}
					}

					newObjectKey = k;
				}
				
				this.setAttribute("objectKey", newObjectKey);

				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var keyIndex = o.orderedChildObjectKeys.indexOf(oldObjectKey);
					delete o.childObjectMap[oldObjectKey];
					o.childObjectMap[newObjectKey] = this;
					
					// avoid duplicate entries
					if(newObjectKey != oldObjectKey) {
						if(o.orderedChildObjectKeys.indexOf(newObjectKey) == -1) {
							o.orderedChildObjectKeys[keyIndex] = newObjectKey;
						}
						else {
							o.orderedChildObjectKeys.splice(keyIndex, 1);
						}
					}
				}
				
				this.updateReferenceObjectIds();
			}

			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateObjectId");
			}					
			]]>
		</method>
		
		<!---
			@keywords private
			Update all the reference objects' IDs that have derived ids
		-->
		<method name="updateReferenceObjectIds">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateReferenceObjectIds");
			}

			for (var key in this.referenceMap) {
				var o = this.referenceMap[key];
				if (!o.pendingDelete && o.objectDefinition.reference && o.objectDefinition.derivedId) {
					var propertyName = o.objectDefinition.idProperty;
					if (o.getPropertyValue(propertyName) != this.objectId) {
						var property = o.propertyMap[propertyName];
						if (property) {
							property.setAttribute("value", this.objectId);
						}
						else {
							var rawData = o.rawDataPropertyMap[propertyName];
							if (!rawData) {
								rawData = {};
								o.rawDataPropertyMap[propertyName] = rawData;
								rawData.propertyReadOnly = false;
								rawData.trimmed = false;
							}
							rawData.propertyValue = this.objectId;
							o.updateObjectId();
						}
					}
				}
			}

			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateReferenceObjectIds");
			}					
			]]>
		</method>

		<!---
			@keywords private
			Updates the long display name.  The long display name property is defined in the object definition.
		-->
		<method name="updateLongDisplayName" args="e=null">
			<![CDATA[
			this.updateLongDisplayNameDel.unregisterAll();
			var longDisplayName = null;

			if (this.objectDefinition.referencedDefinitions != null) {
				var o = this.getReferencedObject();
				if (o != null) {
					longDisplayName = o.objectLongDisplayName;
					this.updateLongDisplayNameDel.register(o, "onobjectLongDisplayName");
				}
			}
			else if (this.objectDefinition.longDisplayNameProperty) {
				var prop = this.getProperty(this.objectDefinition.longDisplayNameProperty, this.objectDefinition.longDisplayNameObjectPath);
				if (prop){
					longDisplayName = prop.value;
					this.updateLongDisplayNameDel.register(prop, "onvalue");
				}
				else if (this.objectDefinition.longDisplayNameObjectPath) {
					this.updateLongDisplayNameDel.register(this, "onchildObjects");
				}
				
				if (longDisplayName == null || longDisplayName == "") {
					if (this.newObject && typeof(this.objectDefinition["newDisplayName"]) != "undefined") {
						longDisplayName = this.objectDefinition.newDisplayName;
						this.updateLongDisplayNameDel.register(this.objectDefinition, "onnewDisplayName");
						this.updateLongDisplayNameDel.register(this, "onnewObject");
					}
					else if (typeof(this.objectDefinition["displayName"]) == "undefined") {
						longDisplayName = this.objectType + "_" + this.objectId;
					}
					else {
						longDisplayName = this.objectDefinition.displayName;
						this.updateLongDisplayNameDel.register(this.objectDefinition, "ondisplayName");
					}
				}

			} else {
				longDisplayName = this.objectDisplayName;
				this.updateLongDisplayNameDel.register(this, "onobjectDisplayName");
			}
			
			if (longDisplayName != this.objectLongDisplayName) {
				this.setAttribute("objectLongDisplayName", longDisplayName);
			}
			]]>
		</method>

		
		<!---
			@keywords private
			Updates the display name. If this object has reference definition, the display name will be retrieved from the
			reference definition. Otherwise, the display name property in the object definition will be attempted. If null
			or empty string is found, a new display name will be generated.
		-->
		<method name="updateDisplayName" args="e=null">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateDisplayName");
			}
			*/
			this.updateDisplayNameDel.unregisterAll();

			var displayName = null;
			if (this.objectDefinition.referencedDefinitions != null) {
				var o = this.getReferencedObject();
				if (o != null) {
					displayName = o.objectDisplayName;
					this.updateDisplayNameDel.register(o, "onobjectDisplayName");
				}
			}
			else if (this.objectDefinition.displayNameProperty) {
				var prop = this.getProperty(this.objectDefinition.displayNameProperty,this.objectDefinition.displayNameObjectPath);
				if(prop){
					displayName = prop.value;
					this.updateDisplayNameDel.register(prop, "onvalue");
				}
				else if (this.objectDefinition.displayNameObjectPath) {
					this.updateDisplayNameDel.register(this, "onchildObjects");
				}
			}
			if (displayName == null || displayName == "") {
				if (this.newObject && typeof(this.objectDefinition["newDisplayName"]) != "undefined") {
					displayName = this.objectDefinition.newDisplayName;
					this.updateDisplayNameDel.register(this.objectDefinition, "onnewDisplayName");
					this.updateDisplayNameDel.register(this, "onnewObject");
				}
				else if (typeof(this.objectDefinition["displayName"]) == "undefined") {
					displayName = this.objectType + "_" + this.objectId;
				}
				else {
					displayName = this.objectDefinition.displayName;
					this.updateDisplayNameDel.register(this.objectDefinition, "ondisplayName");
				}
			}
			if (this.objectDefinition.primary && this.objectVersionId != "" && this.objectVersionId != null && displayName != null && displayName != "") {
				var prop = this.getProperty("objectVersionNumber");
				var objectVersionNumber = prop.value;
				this.updateDisplayNameDel.register(prop, "onvalue");
				if (objectVersionNumber != null && objectVersionNumber != "") {
					displayName = foundationResources.replaceValues("versionedObjectDisplayText", [displayName, objectVersionNumber]);
					this.updateDisplayNameDel.register(foundationResources.versionedObjectDisplayText, "onstring");
				}
			}
			if (this.objectDefinition.primary && this.isContextReadOnly() && displayName != null && displayName != "") {
				var workSpace = wcfContextUtil.findContextValue(this, "workspaceName");
				if (workSpace != null) {
					this.updateDisplayNameDel.register(workSpace, "onvalue");
					if (workSpace.value != null && workSpace.value != "") {
						displayName = foundationResources.replaceValues("workspaceObjectDisplayText", [displayName, workSpace.value]);
						this.updateDisplayNameDel.register(foundationResources.workspaceObjectDisplayText, "onstring");
					} else {
						displayName = foundationResources.replaceValues("approvedContentObjectDisplayText", [displayName]);
						this.updateDisplayNameDel.register(foundationResources.approvedContentObjectDisplayText, "onstring");
					}
				}
			}
			
			if (displayName != this.objectDisplayName) {
				this.lowerCaseDisplayName = displayName.toLowerCase();
				this.setAttribute("objectDisplayName", displayName);
			}
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateDisplayName");
			}
			*/				
			]]>
		</method>
		
		<!---
			@keywords private
			Returns the icon for this wcfModelObject instance
		-->
		<method name="getIcon">
			<![CDATA[
			var icon;
			if (this.objectDefinition["icon"]) {
				icon = this.objectDefinition.icon;
			} else if (this.getReferencedObject() && this.getReferencedObject().objectDefinition["icon"]) {
				icon = this.getReferencedObject().objectDefinition.icon;
			}
			return icon;
			]]>
		</method>

		<!---
			@keywords private
			Returns the formula icon for this wcfModelObject instance.
		-->
		<method name="getFormulaIcon">
			<![CDATA[
				var formulaIcon;
				if (this.objectDefinition["formulaIcon"]) {
					formulaIcon = this.objectDefinition.formulaIcon;
				}
				else if (this.getReferencedObject() && this.getReferencedObject().objectDefinition["formulaIcon"]) {
					formulaIcon = this.getReferencedObject().objectDefinition.formulaIcon;
				}
				return formulaIcon;
			]]>
		</method>

		<!---
			@keywords private
			Returns the type display name of the business object
			@param lz.Delegate del optional, if passed to this method it will register the delegate to the "ondisplayName" event of the resolved object definition.
		-->
		<method name="getTypeDisplayName" args="del">
			<![CDATA[
			var oDef = (this.objectDefinition["displayName"])? this.objectDefinition : this.getReferencedObject().objectDefinition;
			if (del) {
				del.register(oDef, "ondisplayName");
			}
			return oDef.displayName;
			]]>
		</method>
		
		<!---
			@keywords private
			Finds a property based on given property name and object path.  Returns null if there is no object
			along the object path.
			@param String propertyName the name of the property to be found.
			@param String objectPath the path that points to the parent object of the property to be found
			@return a property whose name is the given propertyName, and whose parent object has the given objectPath
		 -->
		<method name="getProperty" args="propertyName, objectPath=null">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getProperty(propertyName, objectPath, createObject)", [propertyName, objectPath, createObject]);
			}
			*/
			var property = null;
			var o = this;
			if(objectPath && objectPath!=""){
				o = this.getObject(objectPath, false);
			}
			if (o) {
				property = o.propertyMap[propertyName];
				if (typeof(property) == "undefined") {
					property = wcfModelUtil.createModelProperty(o, propertyName);
				}
			}
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getProperty(propertyName, objectPath, createObject)", property);
			}
			*/				
			return property;
			]]>
		</method>
		
		<!---
			@keywords private
			Gets a map that contains all of the property values associated with this model object.
			@param Object map the map object to populate with the property values
			@param boolean getDirty only get the dirty properties
			@param boolean getSend only get the sendable properties
			@param string keyPrefix a prefix that will be applied to the property names before setting them
				in the map
			@param boolean trim trim the trimmable property values
			@return Object a map whose keys are property names, and values are the current property values
		-->
		<method name="getPropertyValues" args="map=null,getDirty=false,getSend=false,keyPrefix=null,trim=false">
			<![CDATA[
			var propertyValues = map ? map : {};
			
			if (!getDirty) {
				for (var propertyName in this.rawDataPropertyMap) {
					var rawData = this.rawDataPropertyMap[propertyName];
					var pDef = this.objectDefinition.getPropertyDefinition(this, propertyName);
					var isEnabled = true;
					
					if(!pDef && this.objectDefinition.propertyDefinitions[propertyName]) {
						isEnabled = false;
					}
					
					if (isEnabled && (!getSend || !pDef || pDef.send)) {
						if (trim && !rawData.trimmed && pDef && pDef.trim) {
							rawData.propertyValue = wcfStringUtil.trim(rawData.propertyValue);
							rawData.trimmed = true;
						}
						var key = propertyName;
						if (keyPrefix) {
							key = keyPrefix + key;
						}
						propertyValues[key] = rawData.propertyValue;
					}
				}
			}
			for (var propertyName in this.propertyMap) {
				var prop = this.propertyMap[propertyName];
				var pDef = prop.propertyDefinition;
				
				if (prop.enabled && (!getSend || !pDef || pDef.send)) {
					if (!getDirty || prop.dirty) {
						if (trim && !prop.trimmed && pDef && pDef.trim) {
							prop.trim();
						}
						var key = propertyName;
						if (keyPrefix) {
							key = keyPrefix + key;
						}
						propertyValues[key] = prop.value;
					}
				}
			}
			return propertyValues;
			]]>
		</method>
		
		<!---
			@keywords private
			Gets an array of properties objects that match the specified property name and
			object path.
			@param string propertyName the property name
			@param string objectPath the object path of the property's parent object
			@return array an array of wcfModelProperty objects
		-->
		<method name="getProperties" args="propertyName, objectPath">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getProperties(propertyName, objectPath)", [propertyName, objectPath]);
			}
			var properties = [];
			var objects = this.getObjects(objectPath);
			for (var i = 0; i < objects.length; i++) {
				var o = objects[i];
				var prop = o.propertyMap[propertyName];
				if (typeof(prop) == "undefined") {
					prop = wcfModelUtil.createModelProperty(o, propertyName);
				}
				properties.push(prop);
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getProperties(propertyName, objectPath)", properties);
			}				
			return properties;
			]]>
		</method>

		<!---
			@keywords private
			Discards any unsaved changes for this object.
		-->		
		<method name="discardChanges">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "discardChanges");
			}
			if (this.newObject) {
				wcfModelUtil.releaseModelObject(this);
			}
			else {
				for (var key in this.propertyMap) {
					this.propertyMap[key].restore();
				}
				var updateChildObjects = false;
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject()) {
						if (o.pendingDelete) {
							if (this.openGroupObject.messagesLogged) {
								this.addPropertyLogMessages();
							}
							o.pendingDelete = false;
							updateChildObjects = true;
						}
						o.discardChanges();
					}
				}
				if (updateChildObjects) {
					this.childObjectListsStale = true;
					this.updateChildObjects();
				}
				var updateReferences = false;
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject()) {
						if (o.newObject) {
							wcfModelUtil.releaseModelObject(o);
						} else {

							for (var key in o.propertyMap) {
								o.propertyMap[key].restore();
							}
																			
							if (o.pendingDelete) {
								if (this.openGroupObject.messagesLogged) {
									this.addPropertyLogMessages();
								}
								o.pendingDelete = false;
								updateReferences = true;
								if (o.parentObject != null) {
									o.parentObject.childObjectListsStale = true;
									o.parentObject.updateChildObjects();
								}
							}
						}
	
					}
				}				
				if (this.isOpenGroupObject()) {				
					this.openGroupObject.setAttribute("openGroupDirty", false);					
				}
				if (updateReferences) {
					this.referenceListsStale = true;
					this.updateReferences();
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "discardChanges");
			}				
			]]>
		</method>
		
		<!---
			Gets the value of a property with the given property name and object path to its parent object.
			@param String propertyName the name of the proprety whose value is to be found
			@param String objectPath the path of the property's parent object
			@param boolean trim trim the property value before returning it
			@return Object The value of the found property. If the property is not {@link wcfModelProperty#enabled enabled}, an empty string is returned.
		 -->
		<method name="getPropertyValue" args="propertyName, objectPath=null, trim=false">
			<![CDATA[
			var value = null;
			var o = this;
			if(objectPath && objectPath!=""){
				o = this.getObject(objectPath, false);
			}
			if (o) {
				if (o.propertyMap[propertyName]) {
					var prop = o.propertyMap[propertyName];
					if (trim && !prop.trimmed && prop.propertyDefinition && prop.propertyDefinition.trim) {
						prop.trim();
					}
					value = (prop.enabled) ? prop.value : "";
				}
				else if (o.rawDataPropertyMap[propertyName]) {
					var rawData = o.rawDataPropertyMap[propertyName];
					var pDef = o.objectDefinition.getPropertyDefinition(o, propertyName); 
					if (trim && !rawData.trimmed && pDef && pDef.trim) {
						rawData.propertyValue = wcfStringUtil.trim(rawData.propertyValue);
						rawData.trimmed = true;
					}
					var isEnabled = true;
					
					if(!pDef && o.objectDefinition.propertyDefinitions[propertyName]) {
						isEnabled = false;
					}
					value = (isEnabled) ? rawData.propertyValue : "";
				}
				else {
					value = "";
				}
			}
			return value;
			]]>
		</method>

		<!---
			Sets the value of the property that matches the given property name and path to its parent object.
			@param String propertyName the name of the property whose value is to be set
			@param String objectPath the path to the property's parent object
			@param String value the value to be set to the property
		 -->
		<method name="setPropertyValue" args="propertyName, objectPath, value">
			<![CDATA[
			var property = this.getProperty(propertyName, objectPath);
			property.change(value);
			]]>
		</method>
		
		<!---
			@keywords private
			For all properties defined in this object's definition, apply the default values
			to this object if they have been specified by {@link wcfPropertyValue#isDefault}.
		-->
		<method name="setDefaultPropertyValues" args="e=null">
			<![CDATA[
			this.setDefaultPropertyValuesDel.unregisterAll();
			for (var key in this.objectDefinition.propertyDefinitions) {
				var propDef =  this.objectDefinition.getPropertyDefinition(this, key);
				var defaultValue = propDef ? propDef.getDefaultPropertyValue(this, this.setDefaultPropertyValuesDel) : null;
				if (defaultValue != null && defaultValue.value != "") {
					var property = this.propertyMap[propDef.propertyName];
					if (property) {
						if (!property.dirty && property.value == "") {
							property.setAttribute("value", defaultValue.value);
						}
					}
					else {
						var rawData = this.rawDataPropertyMap[propDef.propertyName];
						if (!rawData) {
							rawData = {};
							this.rawDataPropertyMap[propDef.propertyName] = rawData;
							rawData.propertyReadOnly = null;
							rawData.trimmed = false;
							
							rawData.propertyValue = defaultValue.value;
							if (this["propertyChanged"]) {
								this.propertyChanged.sendEvent();
							}
						}						
					}
				}
			}
			]]>
		</method>
		
		<!---
			Gets the boolean value indicating if a property is read only for the property with the given 
			property name and object path to its parent object.
			@param String propertyName the name of the proprety whose value is to be found
			@param String objectPath the path of the property's parent object		
			@return boolean The boolean value of the found property's read only state. 
		 -->
		<method name="getPropertyReadOnly" args="propertyName, objectPath=null">
			<![CDATA[			
			var readOnly = false;
			
			var o = this;
			if(objectPath && objectPath!=""){
				o = this.getObject(objectPath, false);
			}
			if (o) {
				if (o.readOnly) {
					readOnly = true;
				}
				else {
					
					if (o.propertyMap[propertyName]) {
						var prop = o.propertyMap[propertyName];	
						readOnly = prop.propertyReadOnly == "true";
					}
					else if (o.rawDataPropertyMap[propertyName]) {
						var rawData = o.rawDataPropertyMap[propertyName];
						readOnly = rawData.propertyReadOnly == "true";	
						
						var isEnabled = true;
					
						if(o.objectDefinition.propertyDefinitions[propertyName] && !o.objectDefinition.getPropertyDefinition(o, propertyName)) {
							isEnabled = false;								
						}
						
						readOnly = !isEnabled || readOnly; 				
					}												
				} 
			} //else
	
			return readOnly;
			
			]]>
		</method>	
		
		<!---
			Gets the child object that matches the specified object path. This method allows the optional creation of new object if no existing
			object matches the given object path.
			@param string objectPath the object path that the returned object matches. If objectPath is null, this model object will be returned.
			@param boolean create if "true", then create object if object is not found for objectPath.
			@param wcfModelObject descendant optional object instance used to choose between multiple possible objects paths. The resulting object must be an ancestor of this decendant if it is not null.
			@param lz.Delegate delegate Optional {@link lz.Delegate delegate instance}. If this delegate and the given objectPath are not null, register this delegate to the event onchildObjects to each object found when seaching down the given objectPath.
			@return wcfModelObject the first matching object
		-->
		<method name="getObject" args="objectPath,create=false,descendant=null,delegate=null">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getObject(objectPath,create)", [objectPath,create]);
			}
			*/
			
			var o = null;
			
			var objects = this.getObjects(objectPath, delegate, descendant, true);
			if (objects.length > 0) {
				o = objects[0];
			}
			else if (create) {
				if (delegate) {
					delegate.disable();
				}
				
				var o = this;
				var newObjects = false;
				var types = objectPath.split("/");
				for (var i = 0; i < types.length && o != null; i++) {
					var type = types[i];
					var parentO = o;
					
					if (newObjects && delegate) {
						delegate.register(parentO, "onchildObjects");
					}
					o = null;
					if (!newObjects) {
						o = parentO.getObject(type, false, descendant);
					}
					
					if (o == null) {
						newObjects = true;
						var pathSelector = wcfModelUtil.getPathSelectors(type)[0];
						var objectDef = this.model.getObjectDefinition(parentO, pathSelector.type);
						if (objectDef && !objectDef.primary && !objectDef.reference) {
							o = this.model.createNewObject(objectDef, parentO, true, null, true);
							wcfModelUtil.applySelectors(o, pathSelector.selectors);
						}
					}
				}
				
				if (delegate) {
					delegate.enable();
				}
			}
			
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getObject(objectPath,create)", o);
			}
			*/				
			return o;
			]]>
		</method>
		
		<!---
			Gets all the child objects that match the specified object path.
			@param string objectPath the object path
			@param lz.Delegate delegate Optional {@link lz.Delegate delegate instance}. If this delegate and the given objectPath are not null, register this delegate to the event onchildObjects to each object found when seaching down the given objectPath.
			@param wcfModelObject descendant optional object instance used to choose between multiple possible objects paths. The resulting object must be an ancestor of this decendant if it is not null.
			@param boolean defaultLanguage: if "true", if the child object is not language sensitive, and if there are no selectors in the path selector,
											then the default language child object is returned
			@return wcfModelObject[] an array of wcfModelObject instances that match the specified object path
		-->
		<method name="getObjects" args="objectPath, delegate=null, descendant=null, defaultLanguage=false">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getObjects(parentObject, pathSelector, descendant, defaultLanguage)", [parentObject, pathSelector, descendant, defaultLanguage]);
			}
			
			if (delegate) {
				delegate.disable();
			}
			
			var matchingObjects = [];
			if (objectPath) {
				matchingObjects.push(this);
				var pathSelectors = wcfModelUtil.getPathSelectors(objectPath);
				for (var i = 0; i < pathSelectors.length; i++) {
					var pathSelector = pathSelectors[i];
					var parentObjects = matchingObjects;
					matchingObjects = [];
					for (var j = 0; j < parentObjects.length; j++) {
						if (delegate) {
							delegate.register(parentObjects[j], "onchildObjects");
						}
						if (parentObjects[j].unparsedObjects != null) {
							parentObjects[j].parseObjects(true, pathSelector.type);
						}
						var objects = this.model.getObjects(parentObjects[j], pathSelector, descendant, defaultLanguage);
						while (objects.length > 0) {
							matchingObjects.push(objects.shift());
						}
					}
					if (descendant != null && matchingObjects.length == 0) {
						descendant = null;
						for (var j = 0; j < parentObjects.length; j++) {
							var objects = this.model.getObjects(parentObjects[j], pathSelector, null, defaultLanguage);
							while (objects.length > 0) {
								matchingObjects.push(objects.shift());
							}
						}
					}
				}
			}
			else {
				matchingObjects.push(this);
			}
			
			if (delegate) {
				delegate.enable();
			}
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getObjects(parentObject, pathSelector, descendant, defaultLanguage)", matchingObjects);
			}				
			return matchingObjects;
			]]>
		</method>

		<!---
			Gets the parent primary object for this object. The parent primary object
			is the closest primary object in the current object's hierarchy.
			If "parentType" is specified, then the search will continue until
			a matching primary object is found.
			@param string parentType optional parent object type.
			@param lz.Delegate del optional, if passed to this method it will register the delegate to the "onreferencesLoaded" event and load references
			@return wcfModelObject the parent primary object
		-->
		<method name="getParentPrimaryObject" args="parentType=null, del=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getParentPrimaryObject()");
			}
			var o = null;
			if (this.parentObject != null) {
				o = this.parentPrimaryObject;
			}
			else {
				var isVersionObject = this.getIsVersionObject();
				for (var key in this.referenceMap) {
					var ref = this.referenceMap[key];
					if (!ref.pendingDelete && ref.objectDefinition.parentReference && (isVersionObject || !ref.getIsVersionObject())) {
						o = ref;
						break;
					}
				}
				if (del) { del.register(this, "onreferences"); }
				if (o != null) {
					o = o.getParentPrimaryObject(null, del);
				}
			}
			if (o != null && parentType != null && !o.objectDefinition.matchesType(parentType)) {
				o = o.getParentPrimaryObject(parentType, del);
			}
			else if (o == null && !this.referencesLoaded && del) {
				del.register(this, "onreferencesLoaded");
				this.loadReferences();
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getParentPrimaryObject()", [o]);
			}				
			return o;
			]]>
		</method>
		
		<!---
			Gets all the parent primary objects linked by collection reference to this object. 
			@return wcfModelObject[] an array of wcfModelObject instances
		-->
		<method name="getCollectionPrimaryObjects">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getCollectionPrimaryObjects()");
			}
			
			var collectionObjects = [];
			
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.referenceMap) {
				var ref = this.referenceMap[key];
				if (!ref.pendingDelete && ref.objectDefinition.collectionReference && (isVersionObject || !ref.getIsVersionObject())) {
					collectionObjects.push(ref.getParentPrimaryObject());
				}
			}
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getCollectionPrimaryObjects()");
			}				
			return collectionObjects;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if all the references are loaded up to a certain parent type if it is there.
			@param string parentType optional parent object type or object group.
			@return boolean "true" if all the references are loaded
		-->
		<method name="isParentLoaded" args="parentType">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "isParentLoaded()");
			}
			
			var allReferencesLoaded = false;
			
			if (this.referencesLoaded && parentType) {
				var o = null;
				if (this.parentObject != null) {
					o = this.parentObject;
					while (o.parentObject != null) {
						o = o.parentObject;
					}
				}
				else {
					var isVersionObject = this.getIsVersionObject();
					for (var key in this.referenceMap) {
						var ref = this.referenceMap[key];
						if (!ref.pendingDelete && ref.objectDefinition.parentReference && (isVersionObject || !ref.getIsVersionObject())) {
							o = ref;
							break;
						}
					}
					if (o != null) {
						o = o.getParentPrimaryObject();
					}
				}
				if (o == null || o.objectDefinition.matchesType(parentType)) {
					allReferencesLoaded = true;
				}
				else {
					allReferencesLoaded = o.isParentLoaded(parentType);
				}
			}
			else if (this.referencesLoaded) {
				allReferencesLoaded = true;
			}
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "isParentLoaded()", [allReferencesLoaded]);
			}				
			return allReferencesLoaded;
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the open attribute of this model object to the given new state.
			@param newState the new state to assign to the open attribute
			@event onopen will be sent if this event exists
		 -->
		<method name="setOpen" args="newState">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "setOpen(newState)", [newState]);
			}
			if (this.testObject) {
				this.open = false;
			}
			else if (typeof(this["open"]) == "undefined" || this.open != newState) {
				this.open = newState;
				if (this["onopen"]) {
					this.onopen.sendEvent(this);
				}
				if (this.parentObject != null) {
					// Update open child counter of the parent object
					var po = this.getParentPrimaryObject();
					if (this.open) {
						po.openChildCount++;
						if (wcfLogger.enabled) {
							wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "setOpen(newState)", "Model object: Object key=" + this.objectKey + ". Increment open child count for: Object key=" + po.objectKey + ", new open child count=" + po.openChildCount);
						}
					}
					else {
						po.openChildCount--;
						if (wcfLogger.enabled) {
							wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "setOpen(newState)", "Model object: Object key=" + this.objectKey + ". Decrement open child count for: Object key=" + po.objectKey + ", new open child count=" + po.openChildCount);
						}
					}
				}
				this.loadLanguageSensitiveChildrenDel.unregisterAll();
				if (this.open) {
					this.setHasReleasableChildren();
					this.lastViewedTime = (new Date()).getTime();
					this.model.addOpenObject(this);
					wcfContextUtil.findContextValue(this, "inputLanguageIds", this.loadLanguageSensitiveChildrenDel);
				}
				else {
					this.viewState = "";
					this.viewed = false;
					this.lastViewedTime = 0;
					this.model.removeOpenObject(this);
				}
				this.updateLogMessages();
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "setOpen(newState)");
			}				
			]]>
		</method>
		
		<!---
			@keywords private
			Loads this object's language sensitive children when the selected input languages change.
		-->
		<method name="loadLanguageSensitiveChildren" args="e=null">
			<![CDATA[
			this.loadChildren(this.objectDefinition.getOpenGroupObjectDefinitions());
			]]>
		</method>

		<!---
			@keywords private
			Adds the specified object to the list of objects that reference
			this object.
			@param wcfModelObject o the new reference object to be added
			@param boolean update trigger update of all the reference objects if "true". The default is "true".
		-->
		<method name="addReference" args="o, update=true">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "addReference(o, update)", [o, update]);
			}
			var key = o.getUID();
			var isVersionObject = this.getIsVersionObject();
			if (this.referenceMap[key] != o) {
				this.referenceMap[key] = o;
				var oDef = o.objectDefinition;
				if (oDef.parentReference || oDef.collectionReference) {
					for (var mapKey in this.referenceMap) {
						var ref = this.referenceMap[mapKey];
						if (o == ref || !ref.objectDefinition.parentReference || (!isVersionObject && o.getIsVersionObject())) {
							continue;
						}
						var refParent = ref.parentObject;
						if (o.newObject) {
							if (!ref.newObject) {
								// adding new parent so the existing parent needs to
								// be marked for delete
								ref.setAttribute("pendingDelete", true);
							} else {
								// adding a new parent so the existing new parent
								// should be replaced
								delete this.referenceMap[mapKey];
								wcfModelUtil.releaseModelObject(ref);
							}
						} else {
							if (!ref.newObject) {
								// the new (non newObject) parent needs to replace
								// the existing parent and inherit the pending delete flag
								o.setAttribute("pendingDelete", ref.pendingDelete);
								delete this.referenceMap[mapKey];
								wcfModelUtil.releaseModelObject(ref);
							} else {
								// cause the new parent to be pendingDelete
								o.setAttribute("pendingDelete", true);
							}
						}
						refParent.childObjectListsStale = true;
						refParent.updateChildObjects();
					}
					o.initOpenGroupObject();
					if (o.newObject && o.openGroupObject != null) {
						o.openGroupObject.setAttribute("open", true);
						o.openGroupObject.setAttribute("openGroupDirty", true);
					}
				}
				
				this.referenceListsStale = true;
				
				if (update) {
					this.updateReferences();
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "addReference(o, update)");
			}				
			]]>
		</method>
		
		<!---
			@keywords private
			Removes the specified object from the list of objects that reference
			this object.
			@param wcfModelObject o The object to remove.
			@param boolean update Trigger update of all the reference objects if "true". The default is "true" if undefined.
		-->
		<method name="removeReference" args="o, update=true">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "removeReference(o, update)", [o, update]);
			}
			delete this.referenceMap[o.getUID()];
			
			this.referenceListsStale = true;
			this.referencesStale = true;
			
			if (update) {
				this.updateReferences();
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "removeReference(o, update)");
			}				
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the list of objects that reference this object.
			@param boolean immediate "true" to update the references immediately without a deferred callback
		-->
		<method name="updateReferences" args="immediate=false">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateReferences");
			}
			*/

			if (this.referenceListsStale && this.lockCount == 0) {
				if (this.updateReferencesListsCallbackCount > 0) {
					wcfCallbackUtil.cancelCallback(this.updateReferencesListsDel);
					this.updateReferencesListsCallbackCount--;
				}

				this.updateReferencesListsCallbackCount++;				
				if (immediate) {
					this.updateReferencesLists();
				}
				else {
					wcfCallbackUtil.addDeferredCallback(this.updateReferencesListsDel);
				}
			}
			
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateReferences");
			}
			*/				
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the list of objects that reference this object immediately
			@event onreferences
		-->
		<method name="updateReferencesLists" args="e=null">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateReferencesLists");
			}
			*/
			
			this.updateReferencesListsCallbackCount--;

			if (this.referenceListsStale) {
				this.references = [];
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					if (!o.pendingDelete && (o.parentPrimaryObject == null || o.parentPrimaryObject.objectVersionId == null || o.parentPrimaryObject.objectVersionId == "")) {
						this.references.unshift(o);
					}
				}
				var bindings = this.referenceListBindings;
				for (var i = 0; i < bindings.length; i++) {
					this.updateReferenceListBinding(bindings[i]);
				}
				
				this.referenceListsStale = false;
				
				if (this["onreferences"]) {
					this.onreferences.sendEvent(this.references);
				}
	
				this.validate(false);
				this.checkErrors();
				this.checkOpenGroupReadOnly();
			}
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateReferencesLists");
			}
			*/				
			]]>
		</method>
		
		<!---
			@keywords private
			Get the list of references that match the specified type.
			@param string type: the object type
			@return array: array of wcfModelObject instances
		-->
		<method name="getReferences" args="type">
			<![CDATA[
			var matchingObjects = [];
			for (var i = 0; i < this.references.length; i++) {
				var o = this.references[i];
				if (o.objectDefinition.matchesType(type)) {
					matchingObjects.push(o);
				}
			}
			return matchingObjects;
			]]>
		</method>
		
		<!---
			@keywords private
			This method is called when an intermediate object associated with a reference list binding triggers its "onreferences"
			event. This means that the reference lists for this object need to be recalculated.
			@param wcfModelObject o: the model object to release
		-->
		<method name="updateIntermediateReferences" args="e=null">
			<![CDATA[
			this.referenceListsStale = true;
			this.updateReferences();
			]]>
		</method>
		
		<!---
			@keywords private
			Release the specified intermediate object associated with a reference list binding.
			@param wcfModelObject o: the model object to release
		-->
		<method name="releaseIntermediateObject" args="o">
			<![CDATA[
			var bindings = this.referenceListBindings;
			for (var i = 0; i < bindings.length; i++) {
				var binding = bindings[i];
				binding.updateIntermediateReferencesDel.unregisterAll();
				binding.releaseIntermediateObjectDel.unregisterAll();
				var objects = binding.intermediateObjects;
				for (var j = 0; j < objects.length; j++) {
					if (objects[j] == o) {
						o.referenceCount--;
						objects.splice(j, 1);
						j--;
					}
					else {
						binding.updateIntermediateReferencesDel.register(objects[j], "onreferences");
						binding.releaseIntermediateObjectDel.register(objects[j], "beingDestroyed");
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Release all the intermediate objects for the specified reference list binding.
			@param wcfModelObject o: the model object to release
		-->
		<method name="releaseIntermediateObjects" args="binding">
			<![CDATA[
			binding.updateIntermediateReferencesDel.unregisterAll();
			binding.releaseIntermediateObjectDel.unregisterAll();
			var objects = binding.intermediateObjects;
			while (objects.length > 0) {
				var o = objects.shift();
				o.referenceCount--;
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Refreshes a list view that is bound to this object's references.
		-->
		<method name="updateReferenceListBinding" args="binding">
			<![CDATA[
			this.releaseIntermediateObjects(binding);
			var intermediateObjects = [];
			var listObjects = [];
			var statusObject = null;
			if (binding['paths']) {
				for (var i = 0; i < binding.paths.length; i++) {
					var types = binding.paths[i];
					if (statusObject == null) {
						for (var j = 0; j < this.loadReferencesStatusObjects.length; j++) {
							var messageObject = this.loadReferencesStatusObjects[j];
							if (messageObject.service.matchesObjectTypes(this.objectDefinition,types)) {
								statusObject = messageObject;
								break;
							}
						}
					}
					if (types.length > 0) {
						var type = types[0];
						var matchingObjects = this.getReferences(type);
						for (var j = 1; j < types.length; j++) {
							type = types[j];
							var childObjects = matchingObjects;
							matchingObjects = [];
							for (var k = 0; k < childObjects.length; k++) {
								var o = childObjects[k];
								if (o.parentObject != null) {
									if (o.parentObject.objectDefinition.matchesType(type)) {
										if (type == "*") {
											var nextType = j + 1 < types.length ? types[j + 1] : null;
											while (true) {
												if (nextType != null && o.parentObject.objectDefinition.matchesType(nextType)) {
													matchingObjects.push(o);
													break;
												}
												o = o.parentObject;
												if (o.parentObject == null) {
													matchingObjects.push(o);
													break;
												}
											}
										}
										else {					
											matchingObjects.push(o.parentObject);
										}
									}
								}
								else {
									if (j < types.length - 1 && intermediateObjects.indexOf(o) == -1) {
										intermediateObjects.push(o);
										o.referenceCount++;
										binding.updateIntermediateReferencesDel.register(o, "onreferences");
										binding.releaseIntermediateObjectDel.register(o, "beingDestroyed");
										o.loadReferences();
										if (statusObject == null && o.loadReferencesStatusObjects.length > 0) {
											var intermediateObjectTypes = types.slice(j);
											for (var l = 0; l < o.loadReferencesStatusObjects.length; l++) {
												if (o.loadReferencesStatusObjects[l].service.matchesObjectTypes(o.objectDefinition,intermediateObjectTypes)) {
													statusObject = o.loadReferencesStatusObjects[l];
													break;
												}
											}
										}
									}
									var parentObjects = o.getReferences(type);
									while (parentObjects.length > 0) {
										matchingObjects.push(parentObjects.shift());
									}
								}
							}
						}
						while (matchingObjects.length > 0) {
							var o = matchingObjects.shift();
							if (listObjects.indexOf(o) == -1) {
								listObjects.push(o);
							}
						}
					}
				}
			}
			binding.intermediateObjects = intermediateObjects;
			binding.list.setAttribute("modelObjects", listObjects);
			binding.list.setAttribute("statusObject", statusObject);
			]]>
		</method>
		
		<!---
			Gets the object being referenced by this reference object. Null will be returned if no reference is found, or if
			this model object is not a reference object.
			@return wcfModelObject the model object referenced by this model object.
		-->
		<method name="getReferencedObject">
			<![CDATA[
			var o = this.referencedObject;
			if (o == null && this.objectDefinition != null) {
				o = this;
				if (this.objectDefinition.referencedDefinitions != null) {
					var i = 0;
					var referencedObject = null;
					while (!referencedObject && i < this.objectDefinition.referencedDefinitions.length) {
						referencedObject = o.getObject(this.objectDefinition.referencedDefinitions[i].objectType);
						i++;
					}
					o = referencedObject;
				}
				this.referencedObject = o;
			}
			return o;
			]]>
		</method>

		<!---
			@keywords private
			Makes a new lz.wcfModelObject that is a copy of this with the specified parent.
			@param wcfModelObject parent optional parent object for the newly created copy
			@return wcfModelObject A copy of this with the specified parent.
		-->
		<method name="copy" args="parent">
			return this.model.createNewObject(this.objectDefinition, parent, false, this);			
		</method>
		
		<!---
			@keywords private
			Adds the specified transaction to the list of pending transactions.
			@param wcfServiceTransaction t Pending Transaction
		-->
		<method name="addPendingTransaction" args="t">
			<![CDATA[
			if (wcfLogger.enabled) {
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "addPendingTransaction", t.service.url);			
			}
			t.deferred = true;
			this.pendingTransactions.push(t);
			]]>
		</method>
		
		<!---
			@keywords private
			Triggers any pending transactions.
		-->
		<method name="triggerPendingTransactions">
			<![CDATA[
			if (wcfLogger.enabled) {
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModel", "triggerPendingTransactions", this.objectType+this.objectId);					
			}
			var transactions = this.pendingTransactions;
			this.pendingTransactions = [];
			while (transactions.length > 0) {
				wcfServiceTransactionUtil.addPendingTransaction(transactions.shift());
			}
			]]>
		</method>

		<!---
			@keywords private
			Gets the language sensitive child object that matches
			the default language.
			@return wcfModelObject the default language object
		-->
		<method name="getDefaultLanguageObject">
			<![CDATA[
			if (this.defaultLanguageObject == null) {
				var defaultLanguageIdContext = wcfContextUtil.findContextValue(this, "defaultLanguageId");
				var defaultLanguageId = ((defaultLanguageIdContext != null) ? defaultLanguageIdContext.value : "");
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (!o.pendingDelete && o.objectDefinition.languageSensitive) {
						var languageId = o.getPropertyValue("languageId");
						if (languageId != "" && languageId == defaultLanguageId) {
							this.defaultLanguageObject = o;
							break;
						}
					}
				}
			}
			return this.defaultLanguageObject;
			]]>
		</method>
		
		<!---
			@keywords private
			Discards and rolls back any pending transactions.
		-->
		<method name="discardPendingTransactions">
			<![CDATA[
			var transactions = this.pendingTransactions;
			this.pendingTransactions = [];
			while (transactions.length > 0) {
				var t = transactions.shift();
				wcfServiceTransactionUtil.rollback(t);
			}
			]]>
		</method>
		
		<!---
			Load the specified page of child objects.
		-->
		<method name="doLoadPage" args="args">
			<![CDATA[
			this.model.refreshDescendants(this, true, args.oList.getChildObjectDefinitions(), args.pageNum);
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if the specified object is an ancestor of this object.
			@return "true" if the object is an ancestor. False otherwise.
		-->
		<method name="isAncestor" args="o">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "isAncestor(o)", [o]);
			}
			var ancestor = false;
			if (o!= null && this != o) {
				var parentO = this.parentObject ? this.parentObject : this.getParentPrimaryObject();
				while (parentO != null) {
					if (parentO == o) {
						ancestor = true;
						break;
					}
					parentO = parentO.parentObject ? parentO.parentObject : parentO.getParentPrimaryObject();
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "isAncestor(o)", ancestor);
			}				
			return ancestor;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if the specified object is a descendant of this object.
			@return "true" if the object is a descendant. False otherwise.
		-->
		<method name="isDescendant" args="o">
			<![CDATA[
			return o.isAncestor(this);
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if the specified object is a sibling of this object.
			@return "true" if the object is a sibling. False otherwise.
		-->
		<method name="isSibling" args="o">
			<![CDATA[
			var sibling = false;
			if (o != null && this != o) {
				if (this.parentObject != null) {
					sibling = this.parentObject == o.parentObject;
				}
				else {
					sibling = this.getParentPrimaryObject() == o.getParentPrimaryObject();
				}
			}
			return sibling;
			]]>
		</method>
		
		<!---
			@keywords private
			Checks if the object is referenced already in this model object.
			@param wcfObjectDefinition refDef the referenced definition checked against
			@param wcfModelObject o source object to be checked
		-->
		<method name="isDuplicateReference" args="refDef, o">
			<![CDATA[
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.childObjectMap) {
				var childObject = this.childObjectMap[key];
				if (childObject.objectDefinition == refDef && childObject.getReferencedObject() == o && !childObject.pendingDelete && (isVersionObject || !childObject.getIsVersionObject())) {
					return true;
				}
			}
			
			return false;
			]]>
		</method>
		
		<!---
			@keywords private
			Checks if the object's context is read only.
		-->
		<method name="isContextReadOnly">
			<![CDATA[
			return this.localContext != null && this.localContext != this.model.oEditor.localContext;
			]]>
		</method>
		
		<!---
			@keywords private
			Closes this object. A closed object will be released for reuse.
			@param boolean prompt Prompt the user if the object has unsaved changes. The default is false.
		-->
		<method name="closeObject" args="prompt=false">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "closeObject(prompt)", [prompt]);
			}
			var dirty = this.openGroupObject && this.openGroupObject.openGroupDirty;
			if (prompt && dirty) {
				var ancestorHasErrors = false;
				if (this.isOpenGroupObject()) {
					var unsavedOpenAncestors = this.getUnsavedOpenAncestors();
					for (var i = 0; i < unsavedOpenAncestors.length; i++) {
						if (unsavedOpenAncestors[i].hasErrors(true)) {
							ancestorHasErrors = true;
							break;
						}
					}
				}
				if (ancestorHasErrors || this.hasErrors(true)) {
					wcfCloseWithErrorConfirmationDialog.openCloseWithErrorConfirmationDialog(this);
				} else {
					wcfCloseConfirmationDialog.openCloseConfirmationDialog(this);
				}
			}
			else {
				if (this.newObject && !this.creating) {
					wcfModelUtil.releaseModelObject(this);
				}
				else {			
					if (dirty && !this.hasTransaction()) {		
						this.discardChanges();
					}
					this.setAttribute("open", false);
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "closeObject(prompt)");
			}				
			]]>
		</method>
		
		<!---
			@keywords private
			Saves and closes this object.
			@param boolean prompt if "true", the user will be prompted if the object has errrors.
		 -->
		<method name="saveAndCloseObject" args="prompt">
			<![CDATA[
			if(typeof(prompt) == "undefined"){
				prompt = false;
			}
											
			if (prompt && this.isOpenGroupObject() && this.hasErrors(true)) {
					wcfSaveAndCloseConfirmationDialog.openSaveAndCloseConfirmationDialog(this);							
			} else {			
				this.saveObject(false);
				this.closeObject(false);
			}
			
			]]>
		</method>


		<!---
			@keywords private
			Retrieves all ancestors for this object that have unsaved changes
			@return Array list of objects
		-->
		<method name="getUnsavedOpenAncestors">
			<![CDATA[
			var currentOpenObjects = this.model.openObjects;
			var unsavedOpenAncestors = [];
			
			var saveableParentPrimaryObject = this.getSaveableParentPrimaryObject();
			
			for (var i = 0; i < currentOpenObjects.length; i++) {
			
				var o = currentOpenObjects[i];
				if (o.openGroupDirty && this.isAncestor(o) && (saveableParentPrimaryObject == null || saveableParentPrimaryObject.openGroupObject != o)) {
					unsavedOpenAncestors.push(o);
				}
			}

			wcfModelUtil.sortObjectsBySaveOrder(unsavedOpenAncestors);
			
			return unsavedOpenAncestors;
			]]>
		</method>

		<!---
			@keywords private
			Refreshes this object with data from the server. Unsaved changes may be discarded if user allows or if the user is not prompt.
			This object's children and references will be refershed too.
			
			@param boolean prompt Prompt the user if the object has unsaved changes. The default is false.
		-->
		<method name="refreshObject" args="prompt=false">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "refreshObject(prompt)", [prompt]);
			}
			var hasUnsavedChildren = false;
			for (var i = 0; i < this.model.openObjects.length; i++) {
				var o = this.model.openObjects[i];
				if (!o.objectDefinition.primary && this.isDescendant(o) && o.openGroupObject.openGroupDirty) {
					hasUnsavedChildren = true;
					break;
				}
			}
			var refreshableParent = null;
			if (this.objectDefinition.saveParentPrimaryObject && this.viewed) {
				refreshableParent = this.getParentPrimaryObject();
				if (refreshableParent && this.openGroupObject == refreshableParent.openGroupObject) {
					refreshableParent = null;
				}
			}
			var dirty = hasUnsavedChildren ||
						(this.openGroupObject != null && this.openGroupObject.openGroupDirty) ||
						(refreshableParent != null && refreshableParent.openGroupObject != null && refreshableParent.openGroupObject.openGroupDirty);
			if (prompt && dirty) {
				wcfRefreshConfirmationDialog.openRefreshConfirmationDialog(this);
			}
			else {
				if (refreshableParent != null) {
					refreshableParent.refreshObject();
				}
				this.clearServiceErrors();
				this.discardChanges();
				if (this.objectDefinition.refreshService != null && !this.refreshing) {

					if (this.objectDefinition.propertyDefinitions) {
						for (var propertyName in this.objectDefinition.propertyDefinitions) {
							if (propertyName.indexOf(this.objectDefinition.userDataPrefix) == 0) {
								if (this.propertyMap[propertyName]) {
									var prop = this.propertyMap[propertyName];
									prop.setAttribute("value", "");
								}
								else if (this.rawDataPropertyMap[propertyName]) {
									delete this.rawDataPropertyMap[propertyName];
								}
							}
						}
					}
					this.refreshing = true;
					this.objectDefinition.refreshService.doRequest(this);
				}				
				refreshReferences();
				refreshChildren();
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "refreshObject(prompt)");
			}				
			]]>
		</method>
		
		<!---
			@keywords private
			Refreshes this object's children from the server.
			@param [wcfObjectDefinition] oDefs: Optional parameter to load services with specified object definitions
			@param number pageNum: The page number to be loaded.
		-->
		<method name="refreshChildren" args="oDefs=null,pageNum=null">
			<![CDATA[
			if (oDefs != null && oDefs.length == 0) {
				oDefs = null;
			}
			if (oDefs != null) {
				for (var i = 0; i < oDefs.length; i++) {
					this.setGetChildrenServicesStale(oDefs[i], false);
				}
			}
			var checkLoadedChildrenRequired = false;
			if (this.loadChildrenStatusObjects.length > 0) {
				this.childObjectListsStale = true;
				if (pageNum == null) {
					checkLoadedChildrenRequired = true;
					this.loadChildrenStatusObjects = [];
				}
				else {
					for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
						var statusObject = this.loadChildrenStatusObjects[i];
						if (oDefs == null || statusObject.service.matchesObjectDefinitions(this.objectDefinition, oDefs)) {
							statusObject.message = "";
							statusObject.messageForTree = null;
							if (statusObject.serviceObjectList != null) {
								statusObject.serviceObjectList = null;
								checkLoadedChildrenRequired = true;
							}
						}
					}
				}
			}
			if (checkLoadedChildrenRequired) {
				this.checkLoadedChildren();
			}
			var childObjectMapList = [];
			for (var key in this.childObjectMap) {
				childObjectMapList.push(this.childObjectMap[key]);
			}
			
			var isVersionObject = this.getIsVersionObject();
			for (var i = 0; i < childObjectMapList.length; i++) {
				var o = childObjectMapList[i];
				if (oDefs == null || oDefs.indexOf(o.objectDefinition) != -1) {
					if (o.parentObject == this) {
						// If this object is a primary object, remove its children from model.
						// Do not remove the parent or collection reference if it points to an open object
						if (!((o.objectDefinition.parentReference || o.objectDefinition.collectionReference) && o.getReferencedObject().open) && (isVersionObject || !o.getIsVersionObject()) &&
						    (o.openGroupObject != this.openGroupObject || !o.hasUnsavedChanges())) {
						    o.beingDestroyed.sendEvent(o);
						    this.removeChild(o, false);
						    wcfModelUtil.releaseModelObject(o);
						}
					}else if(this.objectDefinition.organizational && !o.newObject && !o.objectDefinition.organizational){
						// If this is an organizational object, we delink its child from it only if its child is not organizational
						// or not new. The child object will not be removed from the model because it could be opened under other
						// objects.
						this.removeChild(o, false);
					}
				}
			}
			
			this.loadChildren(oDefs, false, oDefs == null, false, pageNum);

			this.updateChildObjects();
			
			if (this.modelInitializationIdentifier == this.model.initializationIdentifier) {
				this.model.removeNotReferencedObjects();
			}
			]]>
		</method>

		<!---
			@keywords private
			Refreshes this object's references from the server.
		-->
		<method name="refreshReferences">
			<![CDATA[
			if (this.loadReferencesStatusObjects.length > 0) {
				this.referenceListsStale = true;
				this.loadReferencesStatusObjects = [];
			}
			var referenceMapList = [];
			for (var key in this.referenceMap) {
				referenceMapList.push(this.referenceMap[key]);
			}
			var isVersionObject = this.getIsVersionObject();
			for (var i = 0; i < referenceMapList.length; i++) {
				var o = referenceMapList[i];
				if (o.getReferencedObject() == this) {
					var referenceObjParentObject = o.getParentPrimaryObject();
					if((!referenceObjParentObject.open || o.objectDefinition.parentReference || o.objectDefinition.collectionReference) && (isVersionObject || !o.getIsVersionObject())){
						referenceObjParentObject.setGetChildrenServicesStale(o.objectDefinition);
						wcfModelUtil.releaseModelObject(o);
					}
				}
			}
			if (this.referencesLoaded) {
				this.referencesLoaded = false;
				this.referencesStale = true;
				this.loadReferences();
			}
			
			this.updateReferences(true);
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the hasAccessRight flag.
		-->
		<method name="updateAccessRight" args="e=null">
			<![CDATA[
			if (this["updateAccessRightDel"]) {
				this.updateAccessRightDel.unregisterAll();
			} else {
				this.updateAccessRightDel = new lz.Delegate(this, "updateAccessRight");
			}
			
			// If objectStore is specified, the model object is read-only if the user does not have access right to the object store.
			var storeId = this.getObjectStoreId(this.updateAccessRightDel);
			if (storeId.length > 0){
				var usage = this.getWriteUsage();
				var objectStore = wcfModelUtil.objectStoreMap[storeId + usage];
				if (objectStore == null) {
					// Object store with the usage is not in the object store map. Need to retrieve the information and add it to the object store map.
					objectStore = wcfModelUtil.createObjectStore({
						storeId: storeId,
						usage: usage
					});
					wcfModelUtil.objectStoreMap[storeId + usage] = objectStore;
				}		
				
				var accessRightChanged = false;
				if (objectStore.accessRightChecked){
					// Object store information is already available in the object store map.
					if (this.hasAccessRight != objectStore.hasAccessRight) {
						accessRightChanged = true;
					}
					this.setAttribute("hasAccessRight", objectStore.hasAccessRight);
				} else {
					// Don't know the access right yet.
					if (this.hasAccessRight) {
						accessRightChanged = true;
					}
					this.setAttribute("hasAccessRight", false);
					this.updateAccessRightDel.register(objectStore, "onaccessRightChecked");
				}
				if (accessRightChanged) {
					this.checkOpenGroupPartiallyEditable();
				}
			}	
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the readOnly flag.
		-->
		<method name="updateReadOnly" args="e=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateReadOnly", [this.objectKey, this.readOnly]);
			}
			
			this.updateReadOnlyDel.unregisterAll();

			var newReadOnly = false;
			if (this.isContextReadOnly()
				|| (this.model.oEditor.respectWorkspaceContext && wcfContextUtil.findContextValue(null, "readOnlyMode", this.updateReadOnlyDel).value == "true")
				|| this.getObjectReadOnly(this.updateReadOnlyDel)
				|| !this.getChangeControlModifiable(this.updateReadOnlyDel)
				|| !this.getHasAccessRight(this.updateReadOnlyDel)
				|| this.getIsVersionObject()
				) {

				newReadOnly = true;
			}
			
			if (this.readOnly != newReadOnly) {
				this.setAttribute("readOnly", newReadOnly);
				this.checkOpenGroupReadOnly();
			}
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "updateReadOnly", [this.readOnly]);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if objectReadOnly flag is set to "true".
			@param lz.Delegate del optional, if passed to this method it will register the delegate to the "onobjectReadOnly" event of this object or its inherit object.
		-->
		<method name="getObjectReadOnly" args="del=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getObjectReadOnly(del)", [this.objectKey, del, this.objectReadOnly]);
			}
			var isObjectReadOnly = false;
			
			if (this.objectReadOnly == null) {
				// Check the objectReadOnly from its parent or reference object
				if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null) {
						isObjectReadOnly = referencedObject.getObjectReadOnly(del);
					}
				} else {
					if (this.parentObject != null) {
						isObjectReadOnly = this.parentObject.getObjectReadOnly(del);
					}
				}
			} else if (this.objectReadOnly == "true") {
				isObjectReadOnly = true;
			}
			if (isObjectReadOnly && this.newObject && !this.implicitNewObject) {
				isObjectReadOnly = false;
				if (del) {
					del.register(this, "onnewObject");
					del.register(this, "onimplicitNewObject");
				}
			}

			if (del) {
				del.register(this, "onobjectReadOnly");
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getObjectReadOnly(del)", [isObjectReadOnly]);
			}
			return isObjectReadOnly;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if this object is a version object.
		-->
		<method name="getIsVersionObject">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getIsVersionObject", [this.objectKey]);
			}
			var isVersionObject = this.objectVersionId != null && this.objectVersionId != "";
			if (!isVersionObject && this.parentPrimaryObject != null) {
				isVersionObject = this.parentPrimaryObject.objectVersionId != null && this.parentPrimaryObject.objectVersionId != "";
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getIsVersionObject", [isVersionObject]);
			}
			return isVersionObject;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if this object is deletable
			@param lz.Delegate del optional, if passed to this method it will register the delegate
		-->
		<method name="isDeletable" args="del=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "isDeletable(del)", [this.objectKey, del, this.objectDeletable]);
			}
			var deletable = false;
			if (!this.objectDefinition.organizational && (!this.objectDefinition.primary || this.objectDefinition.deleteService != null)) {
				if (del) {
					del.register(this, "onobjectDeletable");
				}
				if (this.objectDeletable == "true") {
					deletable = true;
					if (this.isContextReadOnly()) {
						deletable = false;
					}
					if (deletable && this.model.oEditor.respectWorkspaceContext && (wcfContextUtil.findContextValue(null, "readOnlyMode", del).value == "true")) {
						deletable = false;
					}
					if (deletable) {
						if (!this.getChangeControlModifiable(del)) {
							deletable = false;
						}
						else if (!this.getHasAccessRight(del)) {
							deletable = false;
						}
						else if (this.getIsVersionObject()) {
							deletable = false;
						}
					}
				}
				else if (this.objectDeletable == "false") {
					deletable = false;
				}
				else {
					if (del) {
						del.register(this, "onreadOnly");
					}
					deletable = !this.readOnly;
				}
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "isDeletable(del)", [deletable]);
			}
			return deletable;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if changeControlModifiable flag is set to "true".
			@param lz.Delegate del optional, if passed to this method it will register the delegate to the "onchangeControlModifiable" event of this object or its inherit object.
		-->
		<method name="getChangeControlModifiable" args="del=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getChangeControlModifiable(del)", [this.objectKey, del, this.changeControlModifiable]);
			}
			var isChangeControlModifiable = true;
			
			// check if the object is modifiable by this user (this object may not be modifiable if
			// it is locked by other workspace, task group or task depending on the locking policy
			if (this.changeControlModifiable == null) {
				// Check the changeControlModifiable from its parent or reference object
				if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null) {
						isChangeControlModifiable = referencedObject.getChangeControlModifiable(del);
					}
				} else {
					if (this.parentObject != null) {
						isChangeControlModifiable = this.parentObject.getChangeControlModifiable(del);
					}
				}
			} else if (this.changeControlModifiable == "false") {
				isChangeControlModifiable = false;
			}
			if (!isChangeControlModifiable && this.newObject && !this.implicitNewObject) {
				isChangeControlModifiable = true;
				if (del) {
					del.register(this, "onnewObject");
					del.register(this, "onimplicitNewObject");
				}
			}
			
			if (del) {
				del.register(this, "onchangeControlModifiable");
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getChangeControlModifiable(del)", [isChangeControlModifiable]);
			}
			return isChangeControlModifiable;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if hasAccessRight flag is true.
			@param lz.Delegate del optional, if passed to this method it will register the delegate to the "onhasAccessRight" event of this object.
		-->
		<method name="getHasAccessRight"  args="del=null">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getHasAccessRight(del)", [this.objectKey, del, this.hasAccessRight, this.objectStoreId]);
			}
			var hasAccessRight = this.hasAccessRight;
			if (!hasAccessRight && this.newObject && !this.implicitNewObject) {
				hasAccessRight = true;
				if (del) {
					del.register(this, "onnewObject");
					del.register(this, "onimplicitNewObject");
				}
			}
			
			if (del) {
				del.register(this, "onhasAccessRight");
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "getHasAccessRight(del)", [hasAccessRight]);
			}
			return hasAccessRight;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns object store id.
			@param lz.Delegate del optional, if passed to this method it will register the delegate to the "onobjectStoreId" event of this object or its inherit object.
		-->
		<method name="getObjectStoreId" args="del=null">
			<![CDATA[
			var storeId = this.objectStoreId;			
			if (storeId.length == 0) {
				// Check the objectStoreId from its parent or reference object
				if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null) {
						storeId = referencedObject.getObjectStoreId(del);
					}
				}
				else {
					if (this.parentObject != null) {
						storeId = this.parentObject.getObjectStoreId(del);
					}
				}
			}
			
			if (del) {
				del.register(this, "onobjectStoreId");
			}
			return storeId;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns write usage.
		-->
		<method name="getWriteUsage">
			<![CDATA[
			var usage = this.objectDefinition.writeUsage;			
			if (usage == null) {
				// Check the writeUsage from its parent or reference object
				if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null) {
						usage = referencedObject.getWriteUsage();
					}
				}
				else {
					if (this.parentObject != null) {
						usage = this.parentObject.getWriteUsage();
					}
				}
			}
			
			if (usage == null) {
				usage = this.model.oEditor.usage;
			}
			return usage;
			]]>
		</method>
		
		<!---
			@keywords private
			Check the openGroupPartiallyEditable flag.
		-->
		<method name="checkOpenGroupPartiallyEditable">
			if (this.openGroupObject != null) {
				var newOpenGroupPartiallyEditable = false;
				if (!this.openGroupObject.openGroupReadOnly) {
					newOpenGroupPartiallyEditable = this.openGroupObject.isPartiallyEditable();
				}
				if (this.openGroupObject.openGroupPartiallyEditable != newOpenGroupPartiallyEditable) {
					this.openGroupObject.setAttribute("openGroupPartiallyEditable", newOpenGroupPartiallyEditable);
				}
			}
		</method>
		
		<!---
			@keywords private
			Check the openGroupReadOnly flag.
		-->
		<method name="checkOpenGroupReadOnly" args="e=null">
			<![CDATA[
			if (this.openGroupObject != null) {
				this.openGroupObject.checkOpenGroupReadOnlyDel.unregisterAll();
				var newOpenGroupReadOnly = !this.openGroupObject.isEditable(this.openGroupObject.checkOpenGroupReadOnlyDel);
				if (this.openGroupObject.openGroupReadOnly != newOpenGroupReadOnly) {
					this.openGroupObject.setAttribute("openGroupReadOnly", newOpenGroupReadOnly);
					this.checkOpenGroupPartiallyEditable();
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Checks if any component of this object is is not accessible or not modifiable by checking
			the hasAccessRight and changeControlModifiable attribute.  This method recursively searches through
			the open group.
			@return boolean true if there is a component of the object is not accessible or not modifiable, false otherwise
		-->
		<method name="isPartiallyEditable">
			<![CDATA[
			var partiallyEditable = !this.hasAccessRight || this.changeControlModifiable == "false";
			if (!partiallyEditable) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject() && o.isPartiallyEditable()) {
						partiallyEditable = true;
						break;
					}
				}
			}
			if (!partiallyEditable) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (!o.hasAccessRight || o.changeControlModifiable == "false") && !o.getIsVersionObject()) {
						partiallyEditable = true;
						break;
					}
				}
			}
			return partiallyEditable;
			]]>
		</method>

		<!---
			@keywords private
			Checks if any component of this object is editable. This method recursively searches through
			the open group to find at least one editable object or property. It also checks child object definitions
			to see if it is possible to create child objects.
			@param lz.Delegate isCreatableDelegate: An optional parameter with a delegate that will be registered with the isCreatable method
												 when checked
			@return boolean "true" if there is a component of the object which is not read only, false otherwise.
		-->
		<method name="isEditable" args="isCreatableDelegate">
			<![CDATA[
			var editable = this.isObjectEditable(isCreatableDelegate);
			if (!editable) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && o.isEditable(isCreatableDelegate) && !o.getIsVersionObject()) {
						editable = true;
						break;
					}
				}
			}
			if (!editable) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject() && o.isObjectEditable(isCreatableDelegate)) {
						editable = true;
						break;
					}
				}
			}
			return editable;
			]]>
		</method>
		
		<!---
			@keywords private
			Checks the current object to see if it has any editable properties or it has any child
			object definitions that allow the creation of new child objects.
			@param lz.Delegate isCreatableDelegate: An optional parameter with a delegate that will be registered with the isCreatable method
												 when checked
			@return boolean "true" if the current object is editable
		-->
		<method name="isObjectEditable" args="isCreatableDelegate">
			<![CDATA[
			var editable = !this.readOnly;
			if (!editable) {
				var propertyMap = this.propertyMap;
				for (var key in propertyMap) {
					if (!propertyMap[key].readOnly) {
						editable = true;
						break;
					}
				}
			}
			if (!editable) {
				var definitions = this.objectDefinition.objectDefinitions;
				for (var i = 0; i < definitions.length; i++) {
					var childDef = definitions[i].objectDefinition;
					if (!childDef.parentReference && !childDef.collectionReference && !childDef.openGroupTop && childDef.isCreatable(this, null, isCreatableDelegate)) {
						editable = true;
						break;
					}
				}
			}
			return editable;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if this object can be opened.
			@param lz.Delegate del: An optional delegate that will be registered with events that may effect the isOpenEnabled state.
			@return boolean "true" if the current object can be opened
		-->
		<method name="isOpenEnabled" args="del=null">
			<![CDATA[
			var openEnabled = false;
			if (this.objectDefinition.openHandler) {
				openEnabled = this.objectDefinition.openHandler.isEnabled(this, del);
			}
			else {
				var po = this.getReferencedObject();
				if (po.openGroupObject != null && po.openGroupObject == po &&
					(po.openGroupObject.objectDefinition.propertiesClass != null || po.openGroupObject.objectDefinition.defaultNavigationList != null)) {
					openEnabled = true;
				}
			}
			return openEnabled;
			]]>
		</method>

		<!---
			@keywords private
			Opens this object
			@param boolean select: select the newly opened object if set to true
		-->
		<method name="doOpen" args="select=true">
			<![CDATA[
			if (this.isOpenEnabled()) {
				if (this.objectDefinition.openHandler) {
					this.objectDefinition.openHandler.open(this, select);
				}
				else {
					var po = this.getReferencedObject();
					po.openGroupObject.setAttribute("open", true);
					if (select) {
						po.model.oEditor.selectOpenObject(po.openGroupObject);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if this object can be opened in the compare view.
			@param lz.Delegate del: An optional delegate that will be registered with events that may effect the isOpenEnabled state.
			@return boolean "true" if the current object can be opened
		-->
		<method name="isOpenInCompareViewEnabled" args="del=null">
			<![CDATA[
			var openEnabled = false;
			if (this.objectDefinition.openHandler) {
				openEnabled = this.objectDefinition.openHandler.isOpenInCompareViewEnabled(this, del);
			}
			else {
				var po = this.getReferencedObject();
				if (po.openGroupObject != null && po.openGroupObject == po && po.openGroupObject.objectDefinition.propertiesClass != null) {
					openEnabled = true;
				}
			}
			return openEnabled;
			]]>
		</method>

		<!---
			@keywords private
			Opens this object in the compare view.
		-->
		<method name="doOpenInCompareView">
			<![CDATA[
			if (this.isOpenInCompareViewEnabled()) {
				if (this.objectDefinition.openHandler) {
					this.objectDefinition.openHandler.openInCompareView(this);
				}
				else {
					var po = this.getReferencedObject();
					var compareViewTreeNode = this.model.oEditor.navigationTree.compareViewTree;
					if (compareViewTreeNode.compareObject1Cache == null) { 
						compareViewTreeNode.setAttribute("compareObject1Cache", this);
					} else if (compareViewTreeNode.compareObject2Cache == null) { 
						compareViewTreeNode.setAttribute("compareObject2Cache", this);
					}
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Locks this model object. A model object will not be updated if it is locked.
		-->
		<method name="lock">
			<![CDATA[
			this.lockCount++;
			this.model.lock();
			]]>
		</method>
		
		<!---
			@keywords private
			Unlock a model object. A model object will be available for update after it is unlocked.
			@param boolean immediateUpdate "true" to immediately update the children and references
		-->
		<method name="unlock" args="immediateUpdate=false">
			<![CDATA[
			if (this.lockCount > 0) {
				this.lockCount--;
				if (this.lockCount == 0) {
					this.updateChildObjects(immediateUpdate);
					this.updateReferences(immediateUpdate);
				}
				this.model.unlock();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Increments the reference count of this object by 1 if it is a primary object, otherwise
			increments the reference count of its parent primary object by 1.
		-->
		<method name="incrementReferenceCount">
			<![CDATA[
				if (wcfLogger.enabled) {
					wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "incrementReferenceCount");				
				}
				if (this.objectDefinition.primary) {
					// Increment the reference count of this object
					this.referenceCount++;
					if (wcfLogger.enabled) {
						wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "incrementReferenceCount", "Increment reference count: object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
					}
				} else if (!this.objectDefinition.organizational) {
					// Increment the reference count of its parent primary object
					var parent = this.getParentPrimaryObject();
					if (parent != null) {
						parent.referenceCount++;
						if (wcfLogger.enabled) {
							wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "incrementReferenceCount", "Increment reference count of the parent: object key=" + parent.objectKey + ", new reference count=" + parent.referenceCount);
						}
					}
				}
				if (wcfLogger.enabled) {
					wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "incrementReferenceCount");
				}
			]]>
		</method>
		
		<!---
			@keywords private
			Decrements the reference count of this object by 1 if it is a primary object, otherwise
			decrements the reference count of its parent primary object by 1.
		-->
		<method name="decrementReferenceCount">
			<![CDATA[
				if (wcfLogger.enabled) {
					wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "decrementReferenceCount");				
				}
				if(this["objectDefinition"]){
					if (this.objectDefinition.primary) {
						// Decrement the reference count of this object
						this.referenceCount--;
						if (wcfLogger.enabled) {
							wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "decrementReferenceCount", "Decrement reference count: object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
						}
					} else if (!this.objectDefinition.organizational) {
						// Decrement the reference count of of its parent primary object
						var parent = this.getParentPrimaryObject();
						if (parent != null) {
							parent.referenceCount--;
							if (wcfLogger.enabled) {
								wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObject", "decrementReferenceCount", "Decrement reference count of the parent: object key=" + parent.objectKey + ", new reference count=" + parent.referenceCount);
							}
						}
					}
				}
				if (wcfLogger.enabled) {
					wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObject", "decrementReferenceCount");
				}
			]]>
		</method>
		
		<!---
			Returns a string suitable for representing this object in a log message.
			@return string the description of the object to be logged
		-->
		<method name="logString">
			<![CDATA[
			return this.toString() + "type=" + this.objectType + " id=" + this.objectId + " version id=" + this.objectVersionId + " objectDisplayName=" + this.objectDisplayName;
			]]>
		</method>
		
		<!---
			@keywords private
			Logs the current object.
		-->
		<method name="logObject">
			<![CDATA[
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "--- " + this.logString() + " ---");
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "objectKey = " + this.objectKey);
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "newObject = " + this.newObject);
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "pendingDelete = " + this.pendingDelete);												
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "errorInOpenGroup = " + this.errorInOpenGroup);
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "openGroupDirty = " + this.openGroupDirty);
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "changeToDirtyTime = " + this.changeToDirtyTime);
			
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "PropertyMap for " + this.logString());
			for (var propertyName in this.propertyMap){
				var p = this.propertyMap[propertyName];
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "propertyName = " + propertyName);
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "value = " + p.value);								
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "dirty = " + p.dirty);
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "enabled = " + p.enabled);
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "readOnly = " + p.readOnly);
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "has Validation Error = " + p.hasValidationError());
			}
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "Raw data property map for " + this.logString());
			for (var propertyName in this.rawDataPropertyMap){
				var p = this.rawDataPropertyMap[propertyName];
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "propertyName = " + propertyName);
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "propertyValue = " + p.propertyValue);
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "propertyReadOnly = " + p.propertyReadOnly);
			}
			
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "ChildObject Map for " + this.logString());	
			for (var key in this.childObjectMap){
				var co = this.childObjectMap[key];			
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", co.logString());
			}
							
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", "Reference Map for " + this.logString());	
			for (var key in this.referenceMap){
				var ro = this.referenceMap[key];			
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "wcfModelObject", "logObject", ro.logString());
			}
			wcfLogger.flush();
			]]>
		</method>
		
		<!---
			@keywords private
			Logs all of the objects in this object's open group.
		-->
		<method name="logObjectGroup">
			<![CDATA[
			this.logObject();
			for (var key in this.childObjectMap) {
				var o = this.childObjectMap[key];
				if (o.parentObject == this && o.openGroupObject == this.openGroupObject) {
					o.logObjectGroup();
				}
			}
			for (var key in this.referenceMap) {
				var o = this.referenceMap[key];
				var oDef = o.objectDefinition;
				if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject) {
					o.logObject();
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			@return wcfParentReferenceObject the parent reference object (return null if not found or it is pending to delete)
		-->
		<method name="getParentReferenceObject">
			<![CDATA[
			var parentReferenceObject = null;
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.referenceMap) {
				var ro = this.referenceMap[key];
				if (!ro.pendingDelete && ro.objectDefinition.parentReference && (isVersionObject || !ro.getIsVersionObject())) {
					parentReferenceObject = ro;
				}
			}
			return parentReferenceObject;
			]]>
		</method>
		
		<!---
			@keywords private
			Set the openGroupDirty attribute of this model object to the given new state.
			@param newState the new state to assign to the openGroupDirty attribute
			@event onopenGroupDirty will be sent if this event exists
		 -->
		<method name="setOpenGroupDirty" args="newState">
			<![CDATA[
			if (this["openGroupDirty"] != newState) {
				this.openGroupDirty = newState;
				
				if (this.openGroupDirty) {
					this.changeToDirtyTime = (new Date()).getTime();					
				} else {
					this.changeToDirtyTime = 0;					
				}
				
				if (this["onopenGroupDirty"]) {
					this.onopenGroupDirty.sendEvent(this);
				}
			}			
			]]>
		</method>
		
		<!---
			@keywords private
			Mark this object as having releaseable children. This will be used by releaseReleasableChildren
			to release child objects for closed objects.
		-->
		<method name="setHasReleasableChildren">
			<![CDATA[
			if (!this.hasReleasableChildren) {
				this.hasReleasableChildren = true;
				var isVersionObject = this.getIsVersionObject();
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.setHasReleasableChildren();
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Release this objects releasable children
			@return boolean true if all the objects children have been released
		-->
		<method name="releaseReleasableChildren">
			<![CDATA[
			var allChildrenReleased = true;
			var releasableChildren = [];
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.childObjectMap) {
				var o = this.childObjectMap[key];
				
				if (!isVersionObject && o.getIsVersionObject()) {
					continue;
				}
				
				var releasable = false;
				if (o.objectDefinition.reference) {
					var referencedObject = o.getReferencedObject();
					if (referencedObject != null && referencedObject.referenceCount == 0 && !referencedObject.open) {
						releasable = true;
					}
				}
				else if (!isOpenGroupObject() || (!o.open && !o.hasTransaction())) {
					releasable = o.releaseReleasableChildren();
				}
				if (releasable && !o.objectDefinition.releaseWhenClosed) {
					if (o.objectDefinition.languageSensitive) {
						if (o == this.getDefaultLanguageObject()) {
							releasable = false;
						}
					}
					else {
						releasable = false;
					}
				}
				if (!o.hasReleasableChildren && releasable) {
					releasableChildren.push(o);
				}
				else {
					allChildrenReleased = false;
				}
			}
			while (releasableChildren.length > 0) {
				var o = releasableChildren.shift();
				this.setGetChildrenServicesStale(o.objectDefinition);
				wcfModelUtil.releaseModelObject(o);
			}
			return allChildrenReleased;
			]]>
		</method>
		
		<!---
			@keywords private
			Release this object's releasable properties. The property value will be
			returned to the raw data map.
			@return boolean true if any properties were released
		-->
		<method name="releaseReleasableProperties">
			<![CDATA[
			var propertiesReleased = false;
			var releaseProperties = [];
			for (var key in this.propertyMap) {
				if (this.propertyMap[key].isReleaseCandidate()) {
					releaseProperties.push(this.propertyMap[key]);
				}
			}
			if (releaseProperties.length > 0) {
				for (var i = 0; i < releaseProperties.length; i++) {
					var property = releaseProperties[i];
					if (property.value != "" || property.propertyReadOnly) {
						var rawData = {};
						this.rawDataPropertyMap[property.propertyName] = rawData;
						rawData.propertyValue = property.value;
						rawData.propertyReadOnly = property.propertyReadOnly;
						rawData.trimmed = property.trimmed;
					}
					wcfModelUtil.releaseModelProperty(property);
				}
				propertiesReleased = true;
			}
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.childObjectMap) {
				var o = this.childObjectMap[key];
				if (o.parentObject == this && (isVersionObject || !o.getIsVersionObject())) {
					if (o.releaseReleasableProperties()) {
						propertiesReleased = true;
					}
				}
			}
			return propertiesReleased;
			]]>
		</method>
		
		<!---
			Gets the business object editor this object belongs to.
			@return wcfBusinessObjectEditor the business object editor
		-->
		<method name="getBusinessObjectEditor">
			<![CDATA[
			return this.model.oEditor;
			]]>
		</method>
		
		<!---
			@keywords private 
			Check the objects that were loaded by get children services. This method is called when objects are deleted.
			@param wcfModelObject destroyedObject: the object that is being destroyed
		-->
		<method name="checkLoadedChildren" args="destroyedObject=null">
			<![CDATA[
			this.checkLoadedChildrenDel.unregisterAll();
			for (var i=0; i< this.loadChildrenStatusObjects.length; i++) {
				var statusObject = this.loadChildrenStatusObjects[i];
				if (statusObject.serviceObjectList != null) {
					var objectList = statusObject.serviceObjectList;
					if (objectList != null) {
						for (var j = 0; j < objectList .length; j++) {
							var o = objectList[j];
							if (o == destroyedObject) {
								objectList.splice(j, 1);
								statusObject.totalRecords--;
								statusObject.deleteCount++;
								j--;
							}
							else {
								this.checkLoadedChildrenDel.register(o, "beingDestroyed");
							}
						}
					}
				}
			}
			]]>
		</method>
		
		<!--- 
			@keywords private 
			Add the specified object to the list of objects that were loaded by the specified service.
			@param wcfGetChildrenService service: the service that loaded the object
			@param wcfModelObject o: the child object that was loaded
		-->
		<method name="addLoadedChild" args="service, o">
			<![CDATA[
			var statusObject = null;
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				if (this.loadChildrenStatusObjects[i].service == service) {
					statusObject = this.loadChildrenStatusObjects[i];
					break;
				}
			}
			if (statusObject == null) {
				statusObject = {
					service: service,
					message: null,
					messageForTree: null,
					hasError: null,
					startIndex: 0,
					totalRecords: 0,
					currPageNum: -1,
					lastPageNum: -1,
					deleteCount: 0,
					serviceObjectList: null
				};
				this.loadChildrenStatusObjects.push(statusObject);
			}
			if (statusObject.serviceObjectList == null) {
				statusObject.serviceObjectList = [];
			}
			statusObject.serviceObjectList.push(o);
			this.checkLoadedChildrenDel.register(o, "beingDestroyed");
			]]>
		</method>	
		
		
	</class>


	<!---
		A model object property is the representation of a business object property. A property should be used to model a single
		value of a business object. For example, the name of a product should be represented as model object property.
		The characteristics of a model property can be specified in a {@link wcfPropertyDefinition wcfPropertyDefinition instance}.
		
		<p>
		 A {@link wcfModelObject model object} aggregates a set of model properties to describe its values. In Management Center, a price object
		contains both currency and monetary value as its properties. A property's value must be able to be represented by a string because it
		needs to be transferred to the server.A property in a model object is should be created once if needed and only once. Therefore, a
		property instance should not be instantiated directly. The framework will instantiate and destroy instances of this class as required.
		
		<p>
		A property can be implicitly created based on values returned by server. In that case, a property definition is not needed.
		
		<p>
		The property description below describes the characteristics of a property for weight measurement. The property's name will
		be xprop_weightMeasure, and it has three values to choose, KGM for kilogram, LBR for milligram, and C62 for "1 Unit".
		
		@START_CODE	
			<PropertyDefinition propertyName="xprop_weightMeasure">
				<PropertyValue displayName="Kilogram" value="KGM"/>
				<PropertyValue displayName="milligram" value="LBR"/>
				<PropertyValue displayName="1 Unit" value="C62"/>
			</PropertyDefinition>
		@END_CODE
		
		@see wcfPropertyDefinition
	-->
	<class name="wcfModelProperty" extends="node">
		<!---
			Parent model object of this property
			@type wcfModelObject
		-->
		<attribute name="o" value="null"/>
		
		<!---
			The value for this property.
		-->
		<attribute name="value" type="string" value=""/>
		
		<!---
			The name of this property.
		-->
		<attribute name="propertyName" type="string" value="${null}"/>
		
		<!---
			Indicates that the property has been changed and needs to be saved.
		-->
		<attribute name="dirty" type="boolean" value="false"/>
		
		<!---
			Indicates that the property is enabled.
		-->
		<attribute name="enabled" type="boolean" value="true"/>
		
		<!---
			@keywords private
			Property's Read Only State, if explicitely set
		-->
		<attribute name="propertyReadOnly" value="null"/>
		
		<!---
			Property's Read Only State, either explicitly set or inherited. If this attribute is
			"true", this model object including its properties and child objects can not be modified.
		-->
		<attribute name="readOnly" type="boolean" value="false"/>
		
		<!---
			@keywords private
			The restore value for the property. This value is used to restore
			the original property value if the object is closed without being saved.
		-->
		<attribute name="restoreValue" type="string"/>
		
		<!---
			@keywords private
			This attribute indicates whether this property can be "redone".
		-->
		<attribute name="redoable" type="boolean" value="false"/>
		
		<!---
			@keywords private
			The redo value for the property. This value is used by the {@link wcfModelProperty#redo redo} method to redo an undone change.		
		-->
		<attribute name="redoValue" type="string"/>
		
		<!---
			The property definition for this property instance.
			@type wcfPropertyDefinition
		-->
		<attribute name="propertyDefinition"/>
		
		<!---
			@keywords private
			The service transaction object associated with this property. A transaction
			object will be created for service requests that are persisting the current
			state of a model object. If this value is null, it indicates that there
			is no active transaction request for this property.
		-->
		<attribute name="transaction" value="null"/>
		
		<!---
			@keywords private
			An array of client validation errors. Validation errors are stored as objects that contain two properties:
			"message" and "validator".
		-->
		<attribute name="clientErrors" value="${[]}"/>
		<!---
			@keywords private
			An array of server validation errors for this property. Server validation errors are stored as
			strings. Each element of the array is a string that represents a error message.
		-->
		<attribute name="serverErrors" value="${[]}"/>
		
		<!---
			@keywords private
			Indicates that this property value has been trimmed.
		-->
		<attribute name="trimmed" type="boolean" value="false"/>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelProperty", "init");
			}
			*/
			super.init();
			this.updateEnablementDel = new lz.Delegate(this, "updateEnablement");
			this.updateReadOnlyDel = new lz.Delegate(this, "updateReadOnly");
			this.updatePropertyDefDel = new lz.Delegate(this, "updatePropertyDefinition");
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelProperty", "init");
			}
			*/				
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.updateEnablementDel.unregisterAll();
			delete this.updateEnablementDel;
			
			this.updateReadOnlyDel.unregisterAll();
			delete this.updateReadOnlyDel;
			
			this.updatePropertyDefDel.unregisterAll();
			delete this.updatePropertyDefDel;
			
			wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "SEVERE", "wcfModelProperty", "destroy", "Unexpected wcfModelProperty destroy.");
			
			super.destroy();
			]]>
		</method>

		<!---
			@keywords private
			Gets and updates this property's property definition.
		-->
		<method name="updatePropertyDefinition" args="e=null">
			<![CDATA[
				var def = this.o.objectDefinition.getPropertyDefinition(this.o, this.propertyName, this.updatePropertyDefDel);
				if (typeof(def) == "undefined") {
					def = null;
				}
				if (this.propertyDefinition != def) {
					this.setAttribute("propertyDefinition", def);
				}
			]]>
		</method>

		<!---
			@keywords private
			Initializes this property definition.
			@param wcfModelObject o the parent model object of this property
			@param string propertyName the name of this property
		-->
		<method name="initializeProperty" args="o,propertyName">
			<![CDATA[
			this.o = o;
			this.propertyName = propertyName;
			o.propertyMap[propertyName] = this;
			
			this.updatePropertyDefinition();

			var rawData = o.rawDataPropertyMap[this.propertyName];
			if (rawData) {
				this.value = rawData.propertyValue;
				this.propertyReadOnly = rawData.propertyReadOnly;
				this.trimmed = rawData.trimmed;
				delete o.rawDataPropertyMap[this.propertyName];
			}
			else {
				this.value = "";
			}
			
			this.updateEnablement();
			
			if (typeof(propertyReadOnly) == "undefined") {
				propertyReadOnly = null;
			}
			
			this.updateReadOnlyDel.register(this, "onpropertyReadOnly");
			this.updateReadOnlyDel.register(o, "onreadOnly");
			this.updateReadOnly();
			]]>
		</method>

		<!---
			@keywords private
			Releases this property instance so it can be reused.
		-->
		<method name="release">
			<![CDATA[
			this.updatePropertyDefDel.unregisterAll();
			this.updateEnablementDel.unregisterAll();
			this.updateReadOnlyDel.unregisterAll();
			if (this.propertyName != null && this.o != null) {
				delete this.o.propertyMap[this.propertyName];
			}
			this.o = null;
			this.propertyName = null;
			this.value = "";
			this.dirty = false;
			this.enabled = true;
			this.propertyReadOnly = null;
			this.readOnly = false;
			this.restoreValue = undefined;
			this.redoValue = undefined;
			this.redoable = false;
			this.propertyDefinition = null;
			this.transaction = null;
			if (this.transaction != null) {
				wcfServiceTransactionUtil.removeSaveProperty(this.transaction, this);
				this.transaction = null;
			}
			this.clientErrors = [];
			this.serverErrors = [];
			this.trimmed = false;
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the value of the readOnly attribute
			@event onreadOnly
		-->
		<method name="updateReadOnly" args="e=null">
			<![CDATA[
			var newReadOnly = this.o.readOnly;
			if (!newReadOnly && this.propertyReadOnly != null && this.propertyReadOnly == "true") {
				newReadOnly = true;
			}
			if (this.readOnly != newReadOnly) {
				this.setAttribute("readOnly", newReadOnly);
				if (this.propertyReadOnly != null) {
					this.o.checkOpenGroupReadOnly();
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates whether this property is enabled based on the current value of the
			enablement condition.
		-->
		<method name="updateEnablement" args="e=null">
			<![CDATA[
			this.updateEnablementDel.unregisterAll();
			this.updateEnablementDel.register(this, "onpropertyDefinition");
			var newEnabled = true;
			if (this.propertyDefinition && this.propertyDefinition["enablementCondition"]) {
				this.propertyDefinition.enablementCondition.registerDelegate(this.o, this.updateEnablementDel);
				newEnabled = this.propertyDefinition.enablementCondition.isEnabled(this.o);
			}
			if (newEnabled != this.enabled) {
				this.setAttribute("enabled", newEnabled);
			}
			this.validate();
			]]>
		</method>
		
		<!---
			Changes this property's value to the given new value. The value will be set only if this
			property is dirty and its value is different from this new value. If the property is changed,
			the open group object that owns this property will be dirty.
			
			@param string newValue the new property value to set to this property
			@event onvalue if the value is actually changed
		-->
		<method name="change" args="newValue">
			<![CDATA[
			if (newValue != this.value) {
				if (!this.propertyDefinition || this.propertyDefinition.markDirtyOnChange) {
					if (!this.dirty) {
						this.restoreValue = this.value;
						this.setAttribute("dirty", true);					
					}
					this.redoValue = undefined;
					this.redoable = false;								
				
					if (this.o.openGroupObject != null) {
						if (!this.o.openGroupObject.open) {
							this.o.openGroupObject.setAttribute("open", true);
						}
						if (!this.o.openGroupObject.openGroupDirty) {
							this.o.openGroupObject.setAttribute("openGroupDirty", true);
						}
					}					
				}
				this.setAttribute("value", newValue);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Restores this property to its original value before any
			changes were made.
		-->
		<method name="restore">
			<![CDATA[
			if (this.dirty) {
				this.setAttribute("value", this.restoreValue);
				this.reset();
				this.o.checkUnsavedChanges();
			}
			]]>
		</method>
		
		<!---
			Resets the "dirty" indicator to false. The current value will
			become the new restore value.
		-->
		<method name="reset">
			<![CDATA[
			if (this.dirty) {
				this.setAttribute("dirty", false);
				this.restoreValue = undefined;				
			}
			this.redoValue = undefined;
			this.redoable = false;
			]]>
		</method>
		
		<!---
			@keywords private
			Undoes the changes to the property, and remembers the value that was entered by the user
			before this operation.
		-->
		<method name="undo">
			<![CDATA[
			var newRedoValue = this.value;
			this.change(this.restoreValue);
			this.redoValue = newRedoValue;
			this.redoable = true;
			]]>
		</method>
		
		<!---
			@keywords private
			Redoes the changes to the property, setting the value to what was entered by the user
			before the undo operation.
		-->
		<method name="redo">
			<![CDATA[
			this.change(this.redoValue);
			]]>
		</method>
		
		<!---
			@keywords private
			Updates object Id, validates this property, and removes this property from the saved property list of its transaction.
			@event propertyChanged. This property will be sent along the event
		-->
		<handler name="onvalue">
			<![CDATA[
			if (this.propertyName == this.o.objectDefinition.idProperty && this.value && !this.o._parsing) {
				this.o.updateObjectId();
			}
			this.trimmed = false;
			this.validate();
			if (this.propertyDefinition != null && this.propertyDefinition.forceParentValidation) {
				this.o.parentObject.validate();
			}
			
			if (this.o["propertyChanged"]) {
				this.o.propertyChanged.sendEvent(this);
			}
			if (this.transaction != null && !this["trimming"]) {
				wcfServiceTransactionUtil.removeSaveProperty(this.transaction, this);
			}
			]]>
		</handler>
		
		<!---
			@keywords private
			Validates this property. Optionally validates the parent object of this property.
			@param validateObject "true" if the parent object of this property should be validated. False or undefined otherwise.
		-->
		<method name="validate" args="validateObject=true">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelProperty", "validate");
			}
			*/
			if (validateObject) {
				this.o.validate(false);
			}
			if (!this.o.testObject && this.o.openGroupObject != null && !this.o.openGroupObject.refreshing && this.propertyDefinition != null && !global["noValidation"]) {
				var validators = this.propertyDefinition.validators;
				for (var i = 0; i < validators.length; i++) {
					var validator = validators[i];
					if (this.enabled) {
						validator.validate(this.o, this);
					}
					else {
						this.clearValidationError(validator);
					}
				}
			}
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelProperty", "validate");
			}
			*/				
			]]>
		</method>
		
		<!---
			Registers a validation error to this property for the specified validator. Each
			validator can only register one error message.
			@param wcfValidator validator validator that generates the given error message
			@param string errorMsg the error message of the validation error to be registered
			@event onvalidationErrors if the error is added and the event onvalidationErrors exists
		-->
		<method name="addValidationError" args="validator, errorMsg">
			<![CDATA[
			var update = false;
			if (validator != null) {
				var error = null;
				for (var i = 0; i < this.clientErrors.length; i++) {
					if (this.clientErrors[i].validator == validator) {
						error = this.clientErrors[i];
						if (error.message != errorMsg) {
							error.message = errorMsg;
							update = true;
						}
						break;
					}
				}
				// Create a new error if the given error message is new
				if (error == null) {
					error = {message:errorMsg, validator:validator};
					this.clientErrors.push(error);
					update = true;
				}
			}
			else {
				this.serverErrors.push(errorMsg);
				if (this.serverErrors.length == 1 && this.o.openGroupObject.messagesLogged) {
					for (var i = 0; i < this.clientErrors.length; i++) {
						messageLogger.clearValidationError(this.o, this, this.clientErrors[i].validator);
					}
				}
				update = true;
			}
			
			if (update) {
				if (this.o.openGroupObject) {
					this.o.checkErrors();
					if (this.o.openGroupObject.messagesLogged && (validator == null || this.serverErrors.length == 0)) {
						messageLogger.logValidationError(errorMsg, this.o, this, validator);
					}
				}
				if (this["onvalidationErrors"]) {
					this.onvalidationErrors.sendEvent();
				}
			}
			]]>
		</method>

		<!---
			Returns the array of the validation errors in this property. If there are any service errors, all
			the client-side validation errors will be suppressed.
			@return String[] an array of a validation errors in this property. This array contains either
				service errors or client-side errors. An empty array if no validation errors. A validation
				error describes what this error is, and is NL-enabled.
		-->
		<method name="getValidationErrors">
			<![CDATA[
			var errors = this.serverErrors;
			if (errors.length == 0) {
				errors = [];
				for (var i = 0; i < this.clientErrors.length; i++) {
					var error = this.clientErrors[i];
					errors.push(error.message);
				}
			}
			return errors;
			]]>
		</method>
		
		<!---
			Returns "true" if this property has any validation errors.
			@param boolean ignoreServiceErrors if "true", ignore errors reported by service requests. False otherwise.
			@return boolean "true" if there are validation errors. False otherwise.
		-->
		<method name="hasValidationError" args="ignoreServiceErrors=false">
			<![CDATA[
			var hasError = false;
			if (ignoreServiceErrors) {
				hasError = this.clientErrors.length > 0;
			}
			else {
				hasError = this.clientErrors.length > 0 || this.serverErrors.length > 0;
			}
			return hasError;
			]]>
		</method>

		<!---
			Removes the validator error for the specified validator.
			@param wcfValidator validator the validator that generated the validation error to be removed
			@event onvalidationErrors if validation error is cleared and the event exists
		-->
		<method name="clearValidationError" args="validator">
			<![CDATA[
			var update = false;
			if (validator != null) {
				for (var i = 0; i < this.clientErrors.length; i++) {
					if (this.clientErrors[i].validator == validator) {
						update = true;
						this.clientErrors.splice(i, 1);
						i--;
					}
				}
			}
			else {
				if (this.serverErrors.length > 0) {
					this.serverErrors = [];
					update = true;
				}
				if (this.o.openGroupObject && this.o.openGroupObject.messagesLogged) {
					for (var i = 0; i < this.clientErrors.length; i++) {
						var error = this.clientErrors[i];
						messageLogger.logValidationError(error.message, this.o, this, error.validator);
					}
				}
			}
			
			if (update) {
				this.o.checkErrors();
				if (this.o.openGroupObject && this.o.openGroupObject.messagesLogged) {
					messageLogger.clearValidationError(this.o, this, validator);
				}
				if (this["onvalidationErrors"]) {
					this.onvalidationErrors.sendEvent();
				}
			}
			]]>
		</method>
		
		<!---
			Trim the property value.
		-->
		<method name="trim">
			<![CDATA[
			if (!this.trimmed) {
				var newPropertyValue = wcfStringUtil.trim(this.value);
				if (newPropertyValue != this.value) {
					this.trimming = true;
					this.setAttribute("value", newPropertyValue);
					this.trimming = false;
				}
				this.trimmed = true;
			}
			]]>
		</method>
		
		<!---
			Check if this property can be released back into the raw data map. Properties
			can be released if they have not been changed, they have no validation errors and
			they are not bound to any widgets.
		-->
		<method name="isReleaseCandidate">
			<![CDATA[
			return !this.dirty &&
				this.transaction == null &&
				!this.hasValidationError() &&
				(!this["onvalue"] || this.onvalue.getDelegateCount() == 1);
			]]>
		</method>
	</class>
	
	<!---
		@keywords private
		
		A filtered list of model objects. A model object list is bound to
		a single view and provides a filtered view on an underlying
		list of objects.
	-->
	<class name="wcfModelObjectList" extends="node">
		<!---
			The view to which this model object list is bound.
		-->
		<attribute name="v" value="null"/>
		<!---
			@keywords private
			A base filter for this list. If specified it will always apply.
		-->
		<attribute name="baseFilter" value="null"/>
		<!---
			A list of filters for this list. If this list is empty and
			no "objectDefinitions" is null, then
			the model object list will include all of the objects
			found in the underlying list of model objects.
		-->
		<attribute name="filterList" value="${[]}"/>
		<!---
			Array of valid object selectors for this object list.
			Objects that don't match this list of definitions and their corresponding selectors will be
			filtered out of the list. If this value is null, then the model object list will include all
			of the objects found in the underlying list of model objects.  When an object definition is found
			for an object selector, it must match all the propertyName, propertyValue constraints within that
			object selector.
		-->
		<attribute name="objectSelectors" value="null"/>
		<!---
			The underlying array of model objects.
		-->
		<attribute name="modelObjects" value="null" setter="this.setModelObjects(modelObjects)"/>
		<!---
			The filtered list of model objects.
		-->
		<attribute name="filteredObjects" value="null"/>
		<!---
			The sort comparator
		-->
		<attribute name="sortComparator" value="${null}"/>
		<!---
			Indicates that the list is currently sorted in ascending order.
		-->
		<attribute name="sortAscending" type="boolean" value="true"/>
		<!---
			The row index this object model list starts from for its associated view.
		-->
		<attribute name="fromIndex" type="number" value="0"/>
		<!---
			The row index this object model list ends for its associated view.
		-->
		<attribute name="toIndex" type="number" value="0"/>
		<!---
			@keywords private
			When rows are rendered, the rendering starts at this index.  Furthermore, the pivotIndex
			is always rendered.
		-->
		<attribute name="pivotIndex" type="number" value="0"/>
		<!---
			@keywords private
			The incremement value that the model object list uses from the pivot, 1 or -1.  The
			model object list starts at the pivot index and renders rows based on this increment.
		-->
		<attribute name="increment" type="number" value="1"/>
		<!---
			@keywords private
			The index offset where the object views based on objects in the list start.  Some views
			can be created before the objects are rendered.
		-->
		<attribute name="objectViewOffset" type="number" value="0"/>
		<!---
			@keywords private
			The immediate parent of the object views being used and created.
		-->
		<attribute name="objectViewsImmediateParent" value="${null}"/>
		<!---
			Ignore reference count.
		-->
		<attribute name="ignoreReferenceCount" type="boolean" value="false"/>
		<!---
			Indicates that the list of model objects includes at least one destroyed object. All requests
			to refresh the list of objects will be ignored until the list of model objects is updated.
		-->
		<attribute name="hasDestroyedObjects" type="boolean" value="false"/>
		<!---
			Status object associated with this model object list. It contains the following properties:
			service - the service associated with this status object
			message - the message to display to the user
			messageForTree - the status message that will be displayed to the user (on browse object tree)
			hasError - indicates that the status message is an error
			totalRecords - recordSetTotal returned from service.
			currPageNum - the current page number.
			lastPageNum - the last page number.
		-->
		<attribute name="statusObject" value="${null}"/>
		<!---
			Indicates that a deferred refreshFilteredObjects callback has been added to the list of deferred callbacks.
		-->
		<attribute name="deferredRefreshAdded" type="boolean" value="false"/>
		<!---
			The index of the object that should be given focus. This value
                       is only used when one of the views already has focus.
                       If the object is not rendered, then focus will be given to the
                       closest rendered object.
		-->
		<attribute name="focusObjectIndex" type="number" value="-1"/>
		
		<!---
			@keywords private
			The map of state of the views that are bound to the model objects.
		-->
		<attribute name="viewStateMap" value="${{}}"/>
		<!---
			@keywords private
			A map of object unique IDs to views.
		-->
		<attribute name="viewMap" value="${{}}"/>
		<event name="onreset"/>

		<!--- @keywords private -->
		<method name="init">
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "init");
			}
			*/
			super.init();
			this.v.setAttribute("oList", this);
			this.refreshFilteredObjects();
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "init");
			}
			*/	
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "destroy");
			   wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObjectList", "destroy", "view=" + this.v);
			}
			if (this["updateAvailableHeightDel"]) {
				this.updateAvailableHeightDel.unregisterAll();
				delete this.updateAvailableHeightDel;
			}
			if (this["objectViewsHeightChangedDel"]) {
				this.objectViewsHeightChangedDel.unregisterAll();
				delete this.objectViewsHeightChangedDel;
			}
			if (this.v["oList"] == this) {
				this.v.setAttribute("oList", null);
			}
			if (this["objectDestroyedDel"]) {
				this.objectDestroyedDel.unregisterAll();
				delete this.objectDestroyedDel;
			}
			if (this["deferredRefreshFilteredObjectsDel"]) {
				this.deferredRefreshFilteredObjectsDel.unregisterAll();
				delete this.deferredRefreshFilteredObjectsDel;
			}
			if (this["refreshFilteredObjectsDel"]) {
				delete this.refreshFilteredObjectsDel;
			}
			
			this.setModelObjects(null);
			super.destroy();
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "destroy");
			}	
			]]>
		</method>

		<!---
			Set the model objects for this model object list.
			@param array objects an array of wcfModelObject instances
			@event onmodelObjects
		-->
		<method name="setModelObjects" args="objects">
			<![CDATA[
			if (wcfLogger.enabled) {
				wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "setModelObjects(objects)", [objects]);
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObjectList", "setModelObjects(objects)", "view=" + this.v);
			}
			var originalModelObjectsLength = 0;
			var newListLength = objects ? objects.length : 0;
			var firstChangeIndex = 0;
			var noChange = true;
			
			if (typeof(this.modelObjects) != "undefined"  && this.modelObjects != null) {
				originalModelObjectsLength = this.modelObjects.length;
				if (!this.ignoreReferenceCount) {
				   	for (var i=0; i<originalModelObjectsLength; i++) {
						// Decrement reference count for old model object
						var obj = this.modelObjects[i];
						if (noChange && newListLength > i && obj == objects[i]) {
							firstChangeIndex++;
						}
						else {
							noChange = false;
							if (obj != null) {
								// Get the referenced object
								obj = obj.getReferencedObject();
								if (obj != null) {
									obj.referenceCount--;
									if (wcfLogger.enabled) {
										wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObjectList", "setModelObjects(objects)", "Old list: Object key=" + this.modelObjects[i].objectKey + ". Decrement counter for: Object key=" + obj.objectKey + ", new reference count=" + obj.referenceCount);
									}
								}
							}
						}
					}
				}
			}
			
			var isAppending = false;
			if (typeof(objects) != "undefined"  && objects != null) {
				isAppending = this["filteredObjects"] && !this.hasDestroyedObjects && !this.deferredRefreshAdded && originalModelObjectsLength > 0 && objects.length > originalModelObjectsLength;
				this.hasDestroyedObjects = false;
				if (!this["objectDestroyedDel"]) {
					this.objectDestroyedDel = new lz.Delegate(this, "objectDestroyed");
				}
				else {
					this.objectDestroyedDel.unregisterAll();
				}	
				var newObjects = [];
				for (var i=0; i<objects.length; i++) {
					var obj = objects[i];
					if (isAppending && i < originalModelObjectsLength && obj != this.modelObjects[i]) {
						isAppending = false;
					}
					this.objectDestroyedDel.register(obj, "beingDestroyed");
					newObjects.push(obj);
					if (!this.ignoreReferenceCount && i >= firstChangeIndex) {
						// Increment reference count for new model object
						// Get the referenced object
						obj = obj.getReferencedObject();
						if (obj != null) {
							obj.referenceCount++;					
							if (wcfLogger.enabled) {						
								wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObjectList", "setModelObjects(objects)", "New list: Object key=" + objects[i].objectKey + ". Increment counter for: Object key=" + obj.objectKey + ", new reference count=" + obj.referenceCount);
							}
						}
					}
				}
				// Set to the new model object list
				this.modelObjects = newObjects;
			}
			else {
				this.modelObjects = null;
			}
			if (isAppending) {
				for (var i=originalModelObjectsLength; i<this.modelObjects.length; i++) {
					var o = this.modelObjects[i];
					if (!o.isDeleting(this.deferredRefreshFilteredObjectsDel)) {
						wcfModelUtil.objectSelectorsRegisterDelegate(o, this.objectSelectors, this.deferredRefreshFilteredObjectsDel);
						if (this.baseFilter) {
							this.baseFilter.registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
						}
						for (var j = 0; this.filterList != null && j < this.filterList.length; j++) {
							this.filterList[j].registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
						}
						if (this.matchesFilters(o)) {
							if (this.sortComparator != null && this.v["activeSort"] && this.sortComparator["registerDelegate"]) {
								this.sortComparator.registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
							}
							this.filteredObjects.push(o);
						}
					}			
				}
				this.applySort(this.filteredObjects);
				this.setAttribute("filteredObjects", this.filteredObjects);
			} else {
				this.refreshFilteredObjects();
			}
			if (this["onmodelObjects"]) {
				this.onmodelObjects.sendEvent(this);
			}
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "setModelObjects(objects)");				
			}	
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="objectDestroyed" args="o">
			<![CDATA[
			this.hasDestroyedObjects = true;
			var key = o.getUID();
			if (typeof(this.viewStateMap[key]) != "undefined") {
				delete this.viewStateMap[key];
			}
			var index = this.modelObjects.indexOf(o);
			if (index != -1) {
				this.modelObjects[index] = null;
				if (!this.ignoreReferenceCount) {
					// Decrement reference count for old model object
					// Get the referenced object
					var po = o.getReferencedObject();
					if (po != null) {
						po.referenceCount--;
					}
					if (wcfLogger.enabled) {
						wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObjectList", "objectDestroyed", "Object key=" + o.objectKey + ". Decrement counter for: Object key=" + po.objectKey + ", new reference count=" + po.referenceCount);
					}
				}
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="matchesFilters" args="o">
			<![CDATA[
			var match = wcfModelUtil.matchesObjectSelectors(o, this.objectSelectors);
			if (match && this.baseFilter) {
				match = this.baseFilter.matchesFilter(o);
			}			
			var numFilters = this.filterList != null ? this.filterList.length : 0;
			if (match && numFilters > 0) {
				for (var j=0; j < numFilters; j++) {
					var curFilter = this.filterList[j];	
					match = curFilter.matchesFilter(o);
					if (match == false) {
						break;
					}	
				}
			}
			return match;
			]]>
		</method>
		
		<!--- @keywords private -->
		<handler name="onbaseFilter">
			<![CDATA[
			this.loadChildren();
			this.refreshFilteredObjects();
			]]>
		</handler>
		
		<!--- @keywords private -->
		<handler name="onfilterList">
			<![CDATA[
			this.refreshFilteredObjects();
			]]>
		</handler>

		<!--- @keywords private -->
		<method name="getMatchingModelObjects">
			<![CDATA[
			var modelObjectsList = [];
			if (this.modelObjects) {
				var objects = this.modelObjects;
				for (var i = 0; i < objects.length; i++) {
					var o = objects[i];
					if (wcfModelUtil.matchesObjectSelectors(o, this.objectSelectors) && (!this.baseFilter || this.baseFilter.matchesFilter(o))) {
						modelObjectsList.push(o);
					}
				}
			}
			
			return modelObjectsList;
			]]>
		</method>

		<!--- @keywords private -->
		<method name="deferredRefreshFilteredObjects" args="e=null">
			<![CDATA[
			if (!this.deferredRefreshAdded) {
				this.deferredRefreshAdded = true;
				if (!this["refreshFilteredObjectsDel"]) {
					this.refreshFilteredObjectsDel = new lz.Delegate(this, "refreshFilteredObjects");
				}
				wcfCallbackUtil.addDeferredCallback(this.refreshFilteredObjectsDel, null, wcfCallbackUtil.PRIORITY_FOREGROUND);
			}
			]]>
		</method>

		<!--- @keywords private -->
		<method name="refreshFilteredObjects" args="e=null">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "refreshFilteredObjects");
			}
			*/
			this.deferredRefreshAdded = false;
			if (this["deferredRefreshFilteredObjectsDel"]) {
				this.deferredRefreshFilteredObjectsDel.unregisterAll();
			}
			else {
				this.deferredRefreshFilteredObjectsDel = new lz.Delegate(this, "deferredRefreshFilteredObjects");
			}
			var newList = [];
			var newViewStateMap = {};
			var focusView = null;
			var viewsLength = this.getViewsLength();
			for (var j = 0; j < viewsLength; j++) {
				var view = this.getView(j);
				if (wcfViewUtil.containsView(view, lz.Focus.getFocus())) {
					focusView = view;
				}
			}
			this.focusObjectIndex = -1;
			var focusObject = null;
			if (this.modelObjects) {
				var objects = this.modelObjects;
				for (var i = 0; i < objects.length; i++) {
					var o = objects[i];
					if (o != null && !o.isDeleting(this.deferredRefreshFilteredObjectsDel)) {
						wcfModelUtil.objectSelectorsRegisterDelegate(o, this.objectSelectors, this.deferredRefreshFilteredObjectsDel);
						if (this.baseFilter) {
							this.baseFilter.registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
						}
						for (var j = 0; this.filterList != null && j < this.filterList.length; j++) {
							this.filterList[j].registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
						}
						if (this.matchesFilters(o)) {
							if (this.sortComparator != null && this.v["activeSort"] && this.sortComparator["registerDelegate"]) {
								this.sortComparator.registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
							}
							newList.push(o);
							if (focusView != null && o == focusView.o) {
								focusObject = o;
							}
							var key = o.getUID();
							if (this.viewStateMap != null && typeof(this.viewStateMap[key]) != "undefined") {
								newViewStateMap[key] = this.viewStateMap[key];
							}
						}
					}
				}
			}
			this.viewStateMap = newViewStateMap;
			this.applySort(newList);
			if (focusObject != null) {
				this.focusObjectIndex = newList.indexOf(focusObject);
			}
			if (this.focusObjectIndex == -1 && focusView != null) {
				var oldIndex = focusView._objectIndex;
				var oldLength = this.filteredObjects.length;
				while (oldIndex + 1 < oldLength) {
					var o = this.filteredObjects[oldIndex + 1];
					var newIndex = newList.indexOf(o);
					if (newIndex == -1) {
						oldIndex++;
					}
					else {
						this.focusObjectIndex = newIndex;
						break;
					}
				}
				if (this.focusObjectIndex == -1) {
					while (oldIndex > 0) {
						var o = this.filteredObjects[oldIndex - 1];
						var newIndex = newList.indexOf(o);
						if (newIndex == -1) {
							oldIndex--;
						}
						else {
							this.focusObjectIndex = newIndex;
							break;
						}
					}
				}
			}
			this.setAttribute("filteredObjects", newList);
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "refreshFilteredObjects");
			}
			*/	
			]]>
		</method>
		
		<!--- @keywords private -->
		<handler name="onfilteredObjects">
			<![CDATA[
			this.updateObjectViews();
			]]>
		</handler>
		
		<!---
			@keywords private
			This method finds the index of a given object in its filtered objects and shows this object in the view
			by setting the fromIndex or toIndex.  If the objectIndex is within the current fromIndex or toIndex,
			then it is allready displayed and no update is required to the views.  If the objectIndex is less than
			the fromIndex, then we must pivot against the fromIndex so that the object is displayed at the beginning.
			If the objectIndex is greater than the toIndex, then we must pivot against the toIndex so that the object
			is displayed at the end.  In both these scenarios we do the least amount of the scrolling.
		-->
		<method name="showObjectInView" args="o">
			<![CDATA[
			var objectIndex = -1;
			
			var objects = this.filteredObjects;
			for (var i = 0; i < objects.length; i++) {
				if (objects[i] == o) {
					objectIndex = i;
					break;
				}
			}
			
			if (objectIndex >= 0) {
				if (objectIndex < this.fromIndex) {
					this.setFromIndex(objectIndex);
				}
				else if (objectIndex > this.toIndex) {
					this.setToIndex(objectIndex);
				}
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="updateAvailableHeight" args="e=null">
			this.updateObjectViews();
		</method>
		
		<!---
			@keywords private
			This method listens for the object views height to change and determines whether the updateObjectViews method should
			be called.  The threshold for when to trigger the updateObjectViews re-rendering algorithm is that we try to render
			one object view that is rendered past the available height if they can fit. This occurs in the following
			two circumstances.
			<ul>
				<li>The last object view's ending co-ordinate (objectView.y + objectView.height) is less than the availableHeight and
				there are more filtered objects that can be rendered.  This means we have more vertical space or available height to show
				more rows, and we should add rows until the first row passes the available height as described above.</li>
				<li>The second last object view's ending co-ordinate (objectView.y + objectView.height) is greater than the available height.
				This means that we have atleast one row that isn't within the available height, meaning we have too many rows rendered.</li>
			</ul>
			
			This method acts as a constraint in a feedback loop.  The error that is determined to be significant is the scenario defined above.
			When the error is significant as defined above, then it will recall the updateObjectViews method, rendering the object views.
		-->
		<method name="objectViewsHeightChanged" args="e=null">
			<![CDATA[		
			if (this["_objectViewsHeightChangedLock"]) {
				return;
			}
			this._objectViewsHeightChangedLock = true;
			
			var updateObjectViewsInvoked = false;
			var viewsLength = this.getViewsLength();
			var objectView = this.getView(viewsLength-1);
			if ((objectView.y + objectView.height) < this.v.availableHeight && viewsLength < this.filteredObjects.length) {
				this.updateObjectViews();
				updateObjectViewsInvoked = true;
			}
			else if (viewsLength >= 2) {
				objectView = this.getView(viewsLength-2);
				if ((objectView.y + objectView.height) > this.v.availableHeight) {
					this.updateObjectViews();
					updateObjectViewsInvoked = true;
				}
			}

			if (!updateObjectViewsInvoked && this["objectViewsUpdated"]) {
				this.objectViewsUpdated.sendEvent();
			}
			
			this._objectViewsHeightChangedLock = false;
			]]>
		</method>
		
		<!---
			@keywords private
			This method sets the index where the object list will start rendering.  This
			means that it sets the pivot index to the given fromIndex and sets the increment
			value to 1.
			
			It is advisable that this method is used for paging down and when scrolling up one
			item at a time.  The fromIndex is the appropriate pivot in these cases.  When
			paging down, we want the fromIndex to pivot because we have a starting point for
			a new page.  When scrolling up we want the fromIndex to be the pivot point, because
			we want to make sure we see the next item that is scrolled into view.
		-->
		<method name="setFromIndex" args="newFromIndex">
			<![CDATA[
			this.pivotIndex = newFromIndex;
			this.increment = 1;
			this.updateObjectViews();
			]]>
		</method>
		
		<!---
			@keywords private
			This method sets the index where the object list will stop rendering.  This
			means that it sets the pivot index to the given toIndex and sets the increment
			value to -1.
			
			It is advisable that this method is used for paging up and when scrolling down one
			item at a time.  The toIndex is the appropriate pivot in these cases.  When
			paging up, we want the toIndex to pivot because we have an ending point for
			a new page.  When scrolling down we want the toIndex to be the pivot point, because
			we want to make sure we see the next item that is scrolled into view.
		-->
		<method name="setToIndex" args="newToIndex">
			<![CDATA[
			this.pivotIndex = newToIndex;
			this.increment = -1;
			this.updateObjectViews();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="updateObjectViewOffset">
			<![CDATA[
			if (this.v["_objectViewsImmediateParent"]) {
				for (var i = 0; i < this.v._objectViewsImmediateParent.subviews.length; i++) {
					var subview = this.v._objectViewsImmediateParent.subviews[i];
					if (subview["parentOList"] == this) {
						this.objectViewOffset = i;
						break;
					}
				}
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getView" args="index">
			<![CDATA[
			if (this.v["_objectViewsImmediateParent"]) {
				var views = this.v._objectViewsImmediateParent.layouts[0].subviews;
				var visibleIndex = -1;
				for (var i = this.objectViewOffset; i < views.length; i++) {
					var v = views[i];
					if (v.visible) {
						visibleIndex++;
						if (visibleIndex == index) {
							return v;
						}
					}
				}
			}
			return null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getFirstView">
			<![CDATA[
			var views = this.v._objectViewsImmediateParent.layouts[0].subviews;
			for (var i = 0; i < views.length; i++) {
				var v = views[i];
				if (v["parentOList"] == this && !v._used) {
					return v;
				}
			}
			return null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getLastView">
			<![CDATA[
			var views = this.v._objectViewsImmediateParent.layouts[0].subviews;
			for (var i = (views.length - 1); i > -1; i--) {
				var v = views[i];
				if (v["parentOList"] == this && !v._used) {
					return v;
				}
			}
			return null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getAnyView">
			<![CDATA[
			var views = this.v._objectViewsImmediateParent.subviews;
			for (var i = this.objectViewOffset; i < views.length; i++) {
				var v = views[i];
				if (!v._used) {
					return v;
				}
			}
			return null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getViewsLength">
			<![CDATA[
			var len = 0;
			if (this.v["_objectViewsImmediateParent"]) {
				var views = this.v._objectViewsImmediateParent.subviews;
				for (var i = this.objectViewOffset; i < views.length; i++) {
					if (views[i].visible) {
						len++;
					}
				}
			}
			return len;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="setViewPosition" args="view">
			<![CDATA[
			if (!this.v["_objectViewsImmediateParent"]) {
				this.v._objectViewsImmediateParent = view.immediateparent;
				this.v._objectViewsImmediateParent.layouts[0].lock();
				this.updateObjectViewOffset();
			}
			
			var objectViewLayout = this.v._objectViewsImmediateParent.layouts[0];
			var objectViewSubviews = this.v._objectViewsImmediateParent.subviews;
			
			var beforeView = null;
			for (var i = this.objectViewOffset; i < objectViewSubviews.length; i++) {
				var v = objectViewSubviews[i];
				if (v._used) {
					if (view._objectIndex > v._objectIndex) {
						if (beforeView == null || beforeView._objectIndex < v._objectIndex) {
							beforeView = v;
						}
					}
				}
			}
			
			if (beforeView == null && this.objectViewOffset > 0) {
				beforeView = objectViewSubviews[this.objectViewOffset-1];
			}
			
			if (beforeView != null) {
				objectViewLayout.setLayoutOrder(beforeView, view);
				this.reorderSubviews(objectViewSubviews, beforeView, view);
			}
			else {
				objectViewLayout.setLayoutOrder("first", view);
				this.reorderSubviews(objectViewSubviews, "first", view);
			}
			]]>
		</method>
		
		<!---
			Move the second view right after the first view in the specifed list of subviews. If the first view has a value
			of "first", the second view will be moved to the beginning of the list of subviews. If the first view has a value
			of "last", the second view will be moved to the end of the list of subviews.
			@param subviews the list of subviews where views will be reorderd
			@param view1 v the view where the second view will be moved after, it can also have a value of "first" or "last"
			@param view2 v the view to be moved right after the first view
		-->
		<method name="reorderSubviews" args="subviews, view1, view2">
			<![CDATA[
			var len = subviews.length;			
			var startIndex = -1;
			if (view1 == "first") {
				// move view2 to the beginning of the list of subviews
				startIndex = 0;
			} else if (view1 == "last") {
				// move view2 to the end of the list of subviews
				startIndex = len;
			}
			
			var view2Index = -1;
			var i = 0;
    		while ((i < len) && (startIndex < 0 || view2Index < 0)) {
    			if (startIndex < 0 && subviews[i] == view1) {
    				// locate view1 in the subviews
    				startIndex = i + 1;
    			}
    			if (view2Index < 0 && subviews[i] == view2) {
    				// locate view2 in the subviews
    				view2Index = i;
    			}
    			i++;
    		}
    		
    		if (startIndex > -1 && view2Index > -1 && startIndex != view2Index) {
            	// remove view2 in the subviews
            	subviews.splice(view2Index, 1);
            	if (view2Index < startIndex) {
            		// view2 is being removed before the location of view1 in the list, need to adjust the index for re-inserting back the view
            		startIndex = startIndex - 1;
            	}
            	
            	// add view2 right after location of view1 in the subviews
            	subviews.splice(startIndex, 0 , view2);
        	}
			]]>
		</method>
		
		<!---
			@keywords private
			This method will setup object views for each object in this model object list.  If the attributes availableHeight and maxObjectViews
			are not set for this model object list's view, then all matching objects and filtered in objects are attempted to be rendered.  This method
			starts at the pivot index and renders new views based on the increment.  It will stop when the maxObjectViews limit has been reached, or
			if the when the available height has been reached.
			
			This algorithm reuses object views.  It will attempt to reuse the same object view for a given object if that object is to be displayed
			in this list and it allready is rendered, otherwise it will attempt to reuse another object view before creating new ones.  It never
			destroys object views, but pools them when we do not need them.
			
			This method is called when the pivotIndex for this object list has changed, and it can be called when the availableHeight or objectViews
			height has changed.  The object list uses a feedback loop through the method objectViewsHeightChanged.  The model object list monitors
			whether the object views have changed and the objectViewsHeightChanged method is called, this method determines whether we should call
			this method.  The reason for this is that this method can be very expensive, and the object views height may have changed but it may not
			be a significant change.  The criteria for what a significant change in height is outlined in the objectViewsHeightChanged method.
		-->
		<method name="updateObjectViews">
			<![CDATA[			
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "updateObjectViews");
			}
			*/
			if (!this.hasDestroyedObjects) {
				if (this.v["_objectViewsImmediateParent"]) {
					this.v._objectViewsImmediateParent.layouts[0].lock();
				}
				this.updateObjectViewOffset();
				
				var focusView = null;
				var viewsLength = this.getViewsLength();
				for (var j = 0; j < viewsLength; j++) {
					var view = this.getView(j);
					if (wcfViewUtil.containsView(view, lz.Focus.getFocus())) {
						focusView = view;
						if (this.focusObjectIndex == -1) {
							this.focusObjectIndex = focusView._objectIndex;
						}
					}
					view._used = false;
					if (view["o"]) {
						view.o.unregisterObjectView(view);
					}
				}
				if (focusView == null) {
					this.focusObjectIndex == -1;
				}
	
				// Calculate the available height, a null availableHeight means there is no contraint on the height of the object views.
				var availableHeight = null;
				if (typeof(this.v["availableHeight"]) != "undefined") {
					if (!this["updateAvailableHeightDel"]) {
						this.updateAvailableHeightDel = new lz.Delegate(this, "updateAvailableHeight");
					}
					else {
						this.updateAvailableHeightDel.unregisterAll();
					}
	
					availableHeight = this.v.availableHeight;
				}
	
				if (availableHeight != null) {
					if (!this["objectViewsHeightChangedDel"]) {
						this.objectViewsHeightChangedDel = new lz.Delegate(this, "objectViewsHeightChanged");
					}
					else {
						this.objectViewsHeightChangedDel.unregisterAll();
					}
				}
				
				// Calculate the maximumn number of object views, a null maxObjectViews means there is no contraint on the number of object views.
				var maxObjectViews = null;
				if (typeof(this.v["maxObjectViews"]) != "undefined") {
					maxObjectViews = this.v.maxObjectViews;
				}
				
				var objects = this.filteredObjects;
				if (objects) {				
					//Normalize the pivotIndex if it is out of range		
					if (this.pivotIndex > (objects.length - 1)) {
						this.pivotIndex = objects.length - 1;
					}
					if (this.pivotIndex < 0) {
						this.pivotIndex = 0;
					}
				}
				if (objects && objects.length > 0) {
					var targetFocusView = null;
					var newHeight = 0;
					
					//Start the fromIndex and toIndex equal to the pivotIndex, before we start selecing object views.
					this.fromIndex = this.pivotIndex;
					this.toIndex = this.pivotIndex;
					
					// Then assign or create views for any new views, we break from the loop below, if the height of the views that
					//   we have assigned exceeds the available height or if the number of views that we have assigned to objects exceeds
					//   the maximumn number of object views.
					var viewCount = 0;
					var i = this.pivotIndex;
					while ((availableHeight == null || newHeight < availableHeight) && (maxObjectViews == null || viewCount < maxObjectViews)) {
			
						// Below we determine whether we are going forward, and what the objectIndex is, the if statement below handles the case
						//  where we can still render object views but our objectIndex has gone past the edges (< 0 or > objects.length), in this case
						//  we normalize the objectIndex so that we take the next visible element.
						var objectIndex = i;
						var forward = this.increment > 0;
						if (objectIndex < 0 || objectIndex > (objects.length - 1) ) {
							if (forward) {
								objectIndex = this.pivotIndex - (i - objects.length + 1);
							}
							else {
								objectIndex = this.pivotIndex - i;
							}
							forward = !forward;
						}
						
						// Below we determine the instance of wcfModelObject that we are setting with an object view.  We will break if the objectIndex
						//   has gone out of range, meaning at this point that all the objects in the list have been assigned to a view and rendered.
						var o = null;
						if (objectIndex < 0 || objectIndex > (objects.length - 1) ) {
							break;
						}
						else {
							o = objects[objectIndex];
						}
						
						// Adjust i by the increment.
						i = i + this.increment;
						
						// Below we get the objectView that will be assigned to the current object.
						var objectView = null;
	
						// We reuse an objectView if it already has this object assigned to it, so that it will not have to be re-rendered.
						viewsLength = this.getViewsLength();					
						for (var j = 0; j < viewsLength; j++) {
							var view = this.getView(j);
							if (view["o"] == o) {
								objectView = view;
								break;
							}
						}
						
						// We attempt reuse an objectView of another object.  If we are going forward we get the last available view, as it is more
						//   likely to not be re-used by the same object.  If we are not going forward we get the first available view, as it is more
						//   likely to not be re-used by the same object.  This is because when we scroll down, we will use set the toIndex to be
						//   the pivotIndex and go backward, so that it is likely that the first view is the one that will not have the same object
						//   associated with it or within view.  Similarly when we scroll up, we will set the fromIndex and be the pivotIndex and
						//   go forward.
						if (objectView == null && this.v["_objectViewsImmediateParent"]) {
							if (forward) {
								objectView = this.getLastView();
							}
							else {
								objectView = this.getFirstView();
							}
							if (objectView == null) {
								objectView = this.getAnyView();
							}
						}

						// If all objectViews are used, we create a new one.
						if (objectView == null) {
							objectView = new lz[this.v.objectClass](this.v, {parentOList: this});
						}
						
						// Register the object view to the object, and set the object with its associated objectView, if it is a different object.
						//    Then mark the object as viewed
						o.registerObjectView(objectView);
						if (objectView["o"] != o) {
							objectView.setAttribute("o", o);
							if (!objectView.visible) {
								objectView.setAttribute("visible", true);
							}
						}
						objectView._objectIndex = objectIndex;
						objectView._used = true;
						
						// Calculate the new height
						newHeight += objectView.height;
						
						// Update the appropriate fromIndex/toIndex.
						if (forward) {
							this.toIndex = objectIndex;
						}
						else {
							this.fromIndex = objectIndex;
						}
						// Set the new objectView's sorted position
						this.setViewPosition(objectView);
						viewCount++;
						
						if (focusView != null) {
							if (targetFocusView == null) {
								targetFocusView = objectView;
							}
							else if (this.focusObjectIndex != -1 && targetFocusView._objectIndex != this.focusObjectIndex) {
								if ((targetFocusView._objectIndex > objectIndex && this.focusObjectIndex <= objectIndex) ||
									(targetFocusView._objectIndex < objectIndex && this.focusObjectIndex >= objectIndex)) {
									targetFocusView = objectView;
								}
							}
						}
					}
				}

				if (focusView != null) {
					if (targetFocusView == null) {
						if (this.parent["restoreFocus"]) {
							this.parent.restoreFocus();
						}
						else {
							lz.Focus.setFocus(this.parent);
						}
					}
					else if (targetFocusView != focusView) {
						var o = targetFocusView.o;
						var objectIndex = targetFocusView._objectIndex;
						if (focusView._used) {
							focusView._used = false;
							focusView.o.unregisterObjectView(focusView);
							focusView.o.registerObjectView(targetFocusView);
							targetFocusView.setAttribute("o", focusView.o);
							targetFocusView._objectIndex = focusView._objectIndex;
							this.setViewPosition(targetFocusView);
						}
						else {
							targetFocusView._used = false;
						}
						o.unregisterObjectView(targetFocusView);
						o.registerObjectView(focusView);
						focusView._used = true;
						focusView.setAttribute("o", o);
						focusView._objectIndex = objectIndex;
						this.setViewPosition(focusView);
					}
				}


				// Set null objects with all the unused views and pool these subviews.
				this.viewMap = {};
				if (this.v["_objectViewsImmediateParent"]) {
					var views = this.v._objectViewsImmediateParent.subviews;
					for (var i = this.objectViewOffset; i < views.length; i++) {
						var view = views[i];
						if (!view._used) {
							if (view.visible) {
								view.setAttribute("visible", false);
							}
							if (view.o != null) {
								view.setAttribute("o", null);
							}
						}
						else {
							this.viewMap[view.o.getUID()] = view;
						}
					}
				}

				this.focusObjectIndex = -1;
			
				if (this.v["_objectViewsImmediateParent"]) {
					this.v._objectViewsImmediateParent.layouts[0].unlock();
				}

				// Listen to the objectViews total height to change, this will check the objectViewsHeightChanged constraint method which will
				//   feedback into this method if the change is significant
				if (availableHeight != null) {
					if (this.getViewsLength() > 0) {
						this.objectViewsHeightChangedDel.register(this.v._objectViewsImmediateParent, "onheight");
					}
					this.updateAvailableHeightDel.register(this.v, "onavailableHeight");
				}

				if (this["objectViewsUpdated"]) {
					this.objectViewsUpdated.sendEvent();
				}
			}
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "updateObjectViews");
			}
			*/	
			]]>		
		</method>
		
		<!--- Sort the list based on the specified sort comparator 
			@param object comparator The sort comparator.
			@param boolean overrideAscending A flag to indicate whether to override the list's current {@link wcfModelObjectList#sortAscending sortAscending} value. When this is true, the list will always be sorted into ascending order. The default value is false.
		-->
		<method name="doSort" args="comparator,overrideAscending=false">
			<![CDATA[
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "doSort(comparator)", [comparator]);
			}

			if (!overrideAscending && comparator == this.sortComparator) {
				this.sortAscending = !this.sortAscending;
				this.filteredObjects.reverse(); //the reversed list should be nearly sorted therefore will be sorted faster
			}
			else {
				this.sortAscending = true;
			}
			this.sortComparator = comparator;
			
			this.applySort(this.filteredObjects);
			this.setAttribute("filteredObjects", this.filteredObjects);
			
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "doSort(comparator)");
			}	
			]]>
		</method>
		
		<!--- Sort the list based on the stored specified sort comparator -->
		<method name="applySort" args="unsortedObjects">
			<![CDATA[
			/*
			if (wcfLogger.enabled) {
			   wcfLogger.entering("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "applySort(unsortedObjects)", [unsortedObjects]);
			}
			*/
			
			for (var i = 0; i < unsortedObjects.length; i++) {
				unsortedObjects[i]["_compareValue"] = null;
			}
			if (this.sortComparator != null) {
				wcfSortUtil.sort(unsortedObjects, this); //ActionScript's own array sort is very slow
			}
						
			/*
			if (wcfLogger.enabled) {
				wcfLogger.exiting("com.ibm.commerce.lobtools.foundation.model", "wcfModelObjectList", "applySort(unsortedObjects)");
			}
			*/	
			]]>
		</method>

		<!--- Compare function for the list using the sort comparator -->		
		<method name="compare" args="o1,o2">
			<![CDATA[	
			var result = this.sortComparator.compare(o1,o2,this.sortAscending);
			if (wcfLogger.enabled) {
				wcfLogger.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "wcfModelObjectList", "compare(o1,o2)", "o1=" + o1.objectDisplayName + ",o2=" + o2.objectDisplayName + ",result=" + result);						
			}	
			return result;
			]]>
		</method>
		
		<!---
			@keywords private
			Loads the children associated for this model object list
		-->	
		<method name="loadChildren">
			<![CDATA[
			if (this["v"] && this.v["parentO"]) {
				this.v.parentO.loadChildren(this.getChildObjectDefinitions());
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Get the child object definitions associated with this model object list.
		-->
		<method name="getChildObjectDefinitions">
			<![CDATA[
			var objectDefinitions = null;
			if (this["v"] && this.v["parentO"]) {
				var oSelectors = null;
				if (this.objectSelectors) {
					oSelectors = this.objectSelectors;
				}
				else if (this.baseFilter && this.baseFilter instanceof lz.wcfObjectTypeFilter && this.baseFilter.objectTypes) {
					oSelectors = this.v.parentO.model.getObjectSelectors(this.v.parentO, this.baseFilter.objectTypes);
				}
				if (oSelectors != null) {
					objectDefinitions = [];
					for (var i = 0; i < oSelectors.length; i++) {
						if (objectDefinitions.indexOf(oSelectors[i].objectDefinition) < 0) {
							objectDefinitions.push(oSelectors[i].objectDefinition);
						}
					}
				}
			}
			return objectDefinitions;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getViewState" args="o">
			<![CDATA[
			return this.viewStateMap[o.getUID()];
			]]>
		</method>

		<!--- @keywords private -->
		<method name="setViewState" args="o,viewState">
			<![CDATA[
			this.viewStateMap[o.getUID()] = viewState;
			]]>
		</method>
	
		<!--- @keywords private -->
		<method name="getObjectView" args="o">
			<![CDATA[
			return this.viewMap[o.getUID()];
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="doLoadPage" args="pageNum">
			<![CDATA[
			if (this.statusObject && this.statusObject.pageController) {
				if (this.v["deselectAll"]) {
					this.v.deselectAll();
				}
				this.statusObject.pageController.doLoadPage({oList: this, pageNum: pageNum});
			}
			]]>
		</method>		
	</class>
	
	<!---
		@keywords private
		
		Selection manager for a view that is controlled by a model object list.
	-->
	<class name="wcfModelObjectListSelectionManager" extends="node">
		<!---
			The model object list.
		-->
		<attribute name="oList"/>
		<!---
			Array of currently selected objects.
		-->
		<attribute name="selectedObjects" value="${[]}"/>
		<!--- @keywords private -->
		<attribute name="multiSelect" type="boolean" value="true"/>
		<!---
			The onselectedObjects event is triggered when the selection changes.
		-->
		<event name="onselectedObjects" />
		
		<!---  @keywords private -->
		<method name="init">
			<![CDATA[
			super.init();
			this.unselectObjectDel = new lz.Delegate(this, "unselectObject");
			this.pruneSelectionDel = new lz.Delegate(this, "pruneSelection");
			]]>
		</method>
		
		<!---  @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.pruneSelectionDel.unregisterAll();
			delete this.pruneSelectionDel;
			this.unselectObjectDel.unregisterAll();
			delete this.unselectObjectDel;
			super.destroy();
			]]>
		</method>
		
		<!---
			Handle new model object list.
		-->
		<handler name="onoList">
			<![CDATA[
			this.pruneSelectionDel.unregisterAll();
			if (this.oList) {
				this.pruneSelectionDel.register(this.oList, "onfilteredObjects");
			}
			else {
				this.selectedObjects = [];
				this.selectionChanged();
			}
			]]>
		</handler>
		
		<!---
			Prune the selected objects list by removing
			entries that aren't being displayed
		-->
		<method name="pruneSelection" args="e=null">
			<![CDATA[
			var change = false;
			for (var i = 0; i < this.selectedObjects.length; i++) {
				if (this.oList.filteredObjects.indexOf(this.selectedObjects[i]) == -1) {
					this.selectedObjects.splice(i, 1);
					i--;
					change = true;
				}
			}
			if(!this.multiSelect && this.selectedObjects.length == 0 && this.oList.filteredObjects.length > 0){
				this.selectedObjects.push(this.oList.filteredObjects[0]);
				this.setViewSelection(this.oList.filteredObjects[0], true);
				change = true;
			}
			if (change) {
				this.selectionChanged();
			}
			]]>
		</method>
		
		<!---
			Handle change to the list of selected objects.
		-->
		<method name="selectionChanged">
			<![CDATA[
			this.unselectObjectDel.unregisterAll();
			var objects = this.selectedObjects;
			for (var i = 0; i < objects.length; i++) {
				this.unselectObjectDel.register(objects[i], "beingDestroyed");
			}
			this.onselectedObjects.sendEvent();
			]]>
		</method>

		<!---
			Select the specified object view.
			@param view v the view
		-->		
		<method name="select" args="v">
			<![CDATA[
			this.selectObject(v["o"]);
			]]>
		</method>
		
		<!---
			Deselect the specified object view.
			@param view v the view
		-->
		<method name="unselect" args="v">
			<![CDATA[
			this.unselectObject(v["o"]);
			]]>
		</method>

		<!---
			Select the specified object.
			@param wcfModelObject o the model object
		-->
		<method name="selectObject" args="o">
			<![CDATA[
			if (this.isRangeSelect()) {
				var firstSelectedObject = this.selectedObjects[0];
				var i1 = this.oList.filteredObjects.indexOf(firstSelectedObject);
				var i2 = this.oList.filteredObjects.indexOf(o);
				
				this.clearSelection();

				if (i2 > i1) {
					for (var i = i1; i <= i2; i++) {
						this.selectedObjects.push(this.oList.filteredObjects[i]);
						this.setViewSelection(this.oList.filteredObjects[i], true);
					}
				}
				else {
					for (var i = i1; i >= i2; i--) {
						this.selectedObjects.push(this.oList.filteredObjects[i]);
						this.setViewSelection(this.oList.filteredObjects[i], true);
					}
				}
			}
			else if (this.isMultiSelect() && this.isSelectedObject(o)){
				this.unselectObject(o);
			}
			else if (this.isMultiSelect()){
				this.selectedObjects.push(o);
				this.setViewSelection(o, true);
			}
			else {
				this.clearSelection();
				this.selectedObjects.push(o);
				this.setViewSelection(o, true);
			}
			this.selectionChanged();
			]]>
		</method>

		<!---
			Deselect the specified model object.
			@param wcfModelObject o the model object
		-->		
		<method name="unselectObject" args="o">
			<![CDATA[
			this.setViewSelection(o, false);
			var i = this.selectedObjects.indexOf(o);
			if (i >= 0) {
           		this.selectedObjects.splice(i, 1);
           		if (!this["_clearSelection"]) {
           			this.selectionChanged();
				}
			}
			]]>
		</method>
		
		<!---
			Set the view selection for the specified object.
			@param wcfModelObject o the model object
			@param boolean isSelected "true" if the object is to be selected, false otherwise
		-->
		<method name="setViewSelection" args="o, isSelected">
			<![CDATA[
			var viewsLength = this.oList.getViewsLength();					
			
			for (var i = 0; i < viewsLength; i++) {
				var view = this.oList.getView(i);
				if (view["o"] == o) {
					view.setSelected(isSelected);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			Returns "true" if the specified object view is selected.
			@param view v the object view
			@return boolean "true" if selected
		-->
		<method name="isSelected" args="v">
			<![CDATA[
			return this.isSelectedObject(v["o"]);
			]]>
		</method>
		
		<!---
			Returns tru
		-->
		<method name="isSelectedObject" args="o">
			<![CDATA[
			return this.selectedObjects.indexOf(o) >= 0;
			]]>
		</method>
		
		<method name="clearSelection">
			<![CDATA[
			this["_clearSelection"] = true;
			while (this.selectedObjects.length > 0) {
				this.unselectObject(this.selectedObjects[0]);
			}
			this["_clearSelection"] = false;
			this.selectionChanged();
			]]>
		</method>
		
		<method name="selectAllObjects">
			<![CDATA[
			this.clearSelection();
			for (var i = 0; i < this.oList.filteredObjects.length; i++) {
				this.selectedObjects.push(this.oList.filteredObjects[i]);
				this.setViewSelection(this.oList.filteredObjects[i], true);
			}
			this.selectionChanged();
			]]>
		</method>
		
		<method name="getSelection">
			<![CDATA[
				var selectedViews = [];
				
				var viewsLength = this.oList.getViewsLength();					
				
				for (var i = 0; i < viewsLength; i++) {
					var view = this.oList.getView(i);
					if (view["selected"]) {
						selectedViews.push(view);
					}
				}
				
				return selectedViews;
			]]>
		</method>
		
		<method name="getObjectView" args="o">
			<![CDATA[
			return this.oList.getObjectView(o);
			]]>
		</method>
		
		<method name="getSelectedObjects">
			<![CDATA[
			return this.selectedObjects;
			]]>
		</method>
		
		<method name="isRangeSelect">
			<![CDATA[
			return lz.Keys.isKeyDown("shift") && this.selectedObjects.length > 0 && !lz.Keys.isKeyDown("enter") && !lz.Keys.isKeyDown("tab");
			]]>
		</method>
		
		<method name="isMultiSelect">
			<![CDATA[
			return this.multiSelect && lz.Keys.isKeyDown("control");
			]]>
		</method>
		
	</class>

	<!---
		@keywords private

		This class defines the sort comparator to sort a list of objects by the given sequence property. This will be used when
		the value of the sequencePropertyName attribute is defined.
	-->
	<class name="wcfSequenceSortComparator" extends="node">
		<!--- @keywords private -->
		<attribute name="sequencePropertyName" type="string" value="${null}" />

		<!--- @keywords private -->
		<attribute name="sequencePropertyPath" type="string" value="${null}" />

		<!--- @keywords private -->
		<method name="getSortOrder" args="o">
			<![CDATA[
				var value = o.getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath);
				value = Number(value);
				if (isNaN(value)) {
					value = null;
				}
				return value;
			]]>
		</method>

		<!---
			The compare function used to sort the list of objects.

			@param wcfModelObject o1 The first model object to compare.
			@param wcfModelObject o2 The second model object to compare.
			@param boolean sortAscending A boolean indicator of whether the required sort is into ascending order.
			@return number If sortAscending is true, this method will return 1 when the value of o1 is greater than
			the value of o2 and -1 otherwise. If sortAscending is false, the comparison will return 1 if
			the value of o1 is less than the value of o2 and -1 otherwise. If the value of o1 is equal to the
			value of o2, this method will return 0.
		-->
		<method name="compare" args="o1, o2, sortAscending">
			<![CDATA[
				var result = 0;

				var v1 = this.getSortOrder(o1);
				var v2 = this.getSortOrder(o2);

				if (v1 > v2) {
					result = sortAscending ? 1 : -1;
				}
				else if (v1 < v2) {
					result = sortAscending ? -1 : 1;
				}

				return result;
			]]>
		</method>

		<!---
			@keywords private
			Register a delegate to be executed when the resolved value changes for the specified model object.
			@param wcfModelObject o: the model object
			@param lz.Delegate del: the delegate
		-->
		<method name="registerDelegate" args="o, del">
			<![CDATA[
				if (this.sequencePropertyPath) {
					o = o.getObject(this.sequencePropertyPath, false, null, del);
				}
				del.register(o.getProperty(sequencePropertyName), "onvalue");
			]]>
		</method>
	</class>

</library>

