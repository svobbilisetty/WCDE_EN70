<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2007, 2012 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<library>
	<resource name="datePickerTopLeft">
		<frame src="resources/datepicker/datepicker_top_left.png"/>
	</resource>
	
	<resource name="datePickerTop">
		<frame src="resources/datepicker/datepicker_top.png"/>
	</resource>
	<resource name="datePickerTopRight">
		<frame src="resources/datepicker/datepicker_top_right.png"/>
	</resource>
	<resource name="datePickerLeft">
		<frame src="resources/datepicker/datepicker_left.png"/>
	</resource>
	<resource name="datePickerRight">
		<frame src="resources/datepicker/datepicker_right.png"/>
	</resource>
	<resource name="datePickerBottomLeft">
		<frame src="resources/datepicker/datepicker_bottom_left.png"/>
	</resource>
	<resource name="datePickerBottom">
		<frame src="resources/datepicker/datepicker_bottom.png"/>
	</resource>
	<resource name="datePickerBottomRight">
		<frame src="resources/datepicker/datepicker_bottom_right.png"/>
	</resource>


	<resource name="datePickerDayCellBackground">
		<frame src="resources/datepicker/datepicker_blank.png"/>
		<frame src="resources/datepicker/datepicker_active.png"/>
		<frame src="resources/datepicker/datepicker_hover.png"/>
		<frame src="resources/datepicker/datepicker_pressed.png"/>
	</resource>	
	
	<resource name="datePickerYearLeftArrow">
		<frame src="resources/datepicker/datepicker_year_arrow_left.png"/>
		<frame src="resources/datepicker/datepicker_year_arrow_left_hover.png"/>
		<frame src="resources/datepicker/datepicker_year_arrow_left_press.png"/>
	</resource>

	<resource name="datePickerYearRightArrow">
		<frame src="resources/datepicker/datepicker_year_arrow_right.png"/>
		<frame src="resources/datepicker/datepicker_year_arrow_right_hover.png"/>
		<frame src="resources/datepicker/datepicker_year_arrow_right_press.png"/>
	</resource>
	
	<resource name="datePickerYearLeftArrowInvert">
		<frame src="resources/datepicker/datepicker_year_arrow_left_invert.png"/>
		<frame src="resources/datepicker/datepicker_year_arrow_left_hover_invert.png"/>
		<frame src="resources/datepicker/datepicker_year_arrow_left_press_invert.png"/>
	</resource>

	<resource name="datePickerYearRightArrowInvert">
		<frame src="resources/datepicker/datepicker_year_arrow_right_invert.png"/>
		<frame src="resources/datepicker/datepicker_year_arrow_right_hover_invert.png"/>
		<frame src="resources/datepicker/datepicker_year_arrow_right_press_invert.png"/>
	</resource>

	<resource name="datePickerMonthLeftArrow">
		<frame src="resources/datepicker/datepicker_month_left.png"/>
		<frame src="resources/datepicker/datepicker_month_left_hover.png"/>
		<frame src="resources/datepicker/datepicker_month_left_pressed.png"/>
	</resource>

	<resource name="datePickerMonthRightArrow">
		<frame src="resources/datepicker/datepicker_month_right.png"/>
		<frame src="resources/datepicker/datepicker_month_right_hover.png"/>
		<frame src="resources/datepicker/datepicker_month_right_pressed.png"/>
	</resource>
	
	<resource name="datePickerButtonLeft">
		<frame src="resources/datepicker/datepicker_b_left.png"/>
		<frame src="resources/datepicker/datepicker_b_left_hover.png"/>
		<frame src="resources/datepicker/datepicker_b_left_pressed.png"/>
	</resource>

	<resource name="datePickerButtonCenter">
		<frame src="resources/datepicker/datepicker_b_center.png"/>
		<frame src="resources/datepicker/datepicker_b_center_hover.png"/>
		<frame src="resources/datepicker/datepicker_b_center_pressed.png"/>
	</resource>
		
	<resource name="datePickerButtonRight">
		<frame src="resources/datepicker/datepicker_b_right.png"/>
		<frame src="resources/datepicker/datepicker_b_right_hover.png"/>
		<frame src="resources/datepicker/datepicker_b_right_pressed.png"/>
	</resource>
	
	<resource name="calendarButton">
		<frame src="resources/datepicker/date.png"/>
		<frame src="resources/datepicker/date_hover.png"/>
		<frame src="resources/datepicker/date_pressed.png"/>
		<frame src="resources/datepicker/date_disabled.png"/>
	</resource>
	
	<!---
		@keywords private
	-->
	<class name="wcfValueSelectorValue" extends="node">
		<attribute name="displayName" type="string" value=""/>
		<attribute name="value" value="null"/>
		
		<handler name="oninit">
			<![CDATA[
			parent.addValue(this);
			]]>
		</handler>
	</class>
	

	<!---
		@keywords private
		A selector that allows users to select a month for this date picker. It is used internally by
		the date picker. This selector uses {@link wcfMonthDropDown} to provide a dropdown menu from which
		users select a valid month.
	-->
	<class name="wcfMonthSelector">
		<!---
			The selected month ranging from 0 to 11, where 0 means January, and 11 means December.
		-->
		<attribute name="selectedMonth" type="number" value="${null}"/>
		
		<wcfCenterLayout axis="y"/>
		<wcfMonthDropDown name="monthDropDown" width="${classroot.width}"/>

		<!---
			@keywords private
			Sets the selected month of this selector to the user selected month
		-->
		<handler name="onselectedValue" reference="monthDropDown"><![CDATA[
			this.setAttribute("selectedMonth", monthDropDown.selectedValue.value);
			]]>
		</handler>
		
		<!---
			Sets the selector value to the given month
			@param Number month the month to be set
			@event onselectedMonth
		-->
		<method name="setMonth" args="month"><![CDATA[
			this.monthDropDown.setMonth(month);
			this.setAttribute("selectedMonth", getSelectedMonth());
			]]>
		</method>

		<!---
			Changes the displayed selected month to the given value. This method will ensure
			the selected value is the given month, but will not trigger the event onselectedMonth.
			@param Number month the new month to be displayed
		-->
		<method name="changeDisplayedMonth" args="month"><![CDATA[
			this.selectedMonth = month;
			monthDropDown.changeDisplayedMonth(month);
			]]>
		</method>
		
		<!---
			Gets the month selected by the user from the month drop down.
			@return Number the month selected by the user. If no selection is made, null will be returned.
		 -->
		<method name="getSelectedMonth"><![CDATA[
			if(!this.monthDropDown['selectedValue']){
				return null;
			}
			
			if(!this.monthDropDown.selectedValue['value']){
				return null;
			}
			return this.monthDropDown.selectedValue.value;
			]]>
		</method>
		
		<!---
			@keywords private
			Checks if the mouse cursor is on this selector including its dropdown menu.
			@return true if the mouse cursor is on this selector or on its dropdown when the dropdown is open. False otherwise.
		-->
		<method name="containsMouse"><![CDATA[
			if(this.containsPt(this.getMouse("x"), this.getMouse("y"))){
				return true;
			}
			
			return monthDropDown.containsMouse();
			]]>
		</method>
	</class>
	
	<!---
		@keywords private
		A dropdown menu specialized in displaying months. It is used internally by {@link wcfMonthSelector}.
	-->
	<class name="wcfMonthDropDown" extends="wcfValueSelector" dropDownButtonAtLeft="true">
		<wcfValueSelectorValue value="0" displayName="${foundationResources.datePickerJan.string}"/>
		<wcfValueSelectorValue value="1" displayName="${foundationResources.datePickerFeb.string}"/>
		<wcfValueSelectorValue value="2" displayName="${foundationResources.datePickerMar.string}"/>
		<wcfValueSelectorValue value="3" displayName="${foundationResources.datePickerApr.string}"/>
		<wcfValueSelectorValue value="4" displayName="${foundationResources.datePickerMay.string}"/>
		<wcfValueSelectorValue value="5" displayName="${foundationResources.datePickerJun.string}"/>
		<wcfValueSelectorValue value="6" displayName="${foundationResources.datePickerJul.string}"/>
		<wcfValueSelectorValue value="7" displayName="${foundationResources.datePickerAug.string}"/>
		<wcfValueSelectorValue value="8" displayName="${foundationResources.datePickerSep.string}"/>
		<wcfValueSelectorValue value="9" displayName="${foundationResources.datePickerOct.string}"/>
		<wcfValueSelectorValue value="10" displayName="${foundationResources.datePickerNov.string}"/>
		<wcfValueSelectorValue value="11" displayName="${foundationResources.datePickerDec.string}"/>
		
		<!---
			@keywords private
			Selects the month equal to the month in the current system date.
		-->
		<method name="selectCurrentMonth"><![CDATA[
			var date = wcfDateUtil.getCurrentDate();
			this.setAttribute("selectedValue", this.values[date.getMonth()]);
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the selected month to the given value.
			@param Number month the new month to be set.
		 -->
		<method name="setMonth" args="month"><![CDATA[
			this.setAttribute("selectedValue", this.values[month]);
			]]>
		</method>
		
		<!---
			@keywords private
			Changes the displayed month to the given month
			@param Number month a given month to be displayed
		-->
		<method name="changeDisplayedMonth" args="month"><![CDATA[
			if(!this.values || !this.values[month]){
				this.selectedValue = null;
			}else{
				this.selectedValue = this.values[month];
			}
			this.updateSelectedValue();
			]]>
		</method>
		
		<!---
			@return Number the currently selected month
		 -->
		<method name="getMonth"><![CDATA[
			return this.selectedValue;
			]]>
		</method>
		
		<!---
			@keywords private
			When the dropdown is initialized, populate its months, and sets the current system
			date's month as the selected month.
		-->
		<handler name="oninit"><![CDATA[
			this.selectCurrentMonth();
			]]>
		</handler>
		
		<!--- @keywords private -->
		<method name="_applystyle" args="s">
			<![CDATA[
			if (this.style != null) {
				this.selectedValueText.setAttribute("fgcolor", s.datepickermonthtextcolor);
				this.selectedValueText.setAttribute("fontsize", s.datepickermonthtextsize);
			}
			]]>
	    </method>

		<!---
			@keywords private
			Handles keyboard shortcuts. Overwrites the default behaviour.
		-->
		<method name="callOnKeyDown" args="k">
			<![CDATA[
			if (k == 38) { // up arrow
				if(this.selectedValue.value > 0){
					this.setMonth(this.selectedValue.value - 1);
				}
			}else if (k == 40) { // down arrow
				if(this.selectedValue.value < 11){
					this.setMonth(this.selectedValue.value + 1);
				}
			}
			]]>
		</method>

	</class>
	
	<!---
		@keywords private
		A selector that allows users to selects a year for this date picker. It uses a dropdown to provide
		valid years for users to choose. This selector is internally used by {@link wcfDatePicker} for
		year selection.
	-->
	<class name="wcfYearSelector">
		<!---
			The currently selected year
		-->
		<attribute name="selectedYear" type="number"/>
		
		<wcfCenterLayout axis="y"/>
		<simplelayout axis="x" spacing="0"/>
		<view name="leftArrow" resource="datePickerYearLeftArrow" onmouseover="this.setAttribute('frame', 2)" onmouseout="this.setAttribute('frame', 1)">
			<handler name="onclick"><![CDATA[
				classroot.yearDropDown.updateYear(-1);
				]]>
			</handler>
		</view>
		
		<wcfYearDropDown name="yearDropDown" width="${classroot.width - classroot.leftArrow.width - classroot.rightArrow.width}"/>
		
		<!---
			@keywords private
			When a value is selected from this selector's dropdown, set the value of this
			selector to the selected year.
		-->
		<handler name="onselectedValue" reference="yearDropDown"><![CDATA[
			this.setAttribute("selectedYear", yearDropDown.selectedValue.value); 	
			]]>
		</handler>
		
		<view name="rightArrow" resource="datePickerYearRightArrow" onmouseover="this.setAttribute('frame', 2)" onmouseout="this.setAttribute('frame', 1)">
			<handler name="onclick"><![CDATA[
				classroot.yearDropDown.updateYear(1);
				]]>
			</handler>
		</view>
		
		<!---
			@keywords private
			Sets the selected year to the given value.
			@param Number year The year to be set
			@event onselectedYear
		-->
		<method name="setYear" args="year"><![CDATA[
			this.yearDropDown.setYear(year);
			this.setAttribute("selectedYear", year);
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the displayed year to the given value. The selector's value
			will be changed, but no onselectYear event will be sent out.
			@param Number year the new value to be displayed
		-->
		<method name="changeDisplayedYear" args="year"><![CDATA[
			this.yearDropDown.changeDisplayedYear(year);
			this.selectedYear = year;
			]]>
		</method>
		
		<!---
			@keywords private
			Gets the selected year in this selector.
			@return Number the currently selected year in this selector
		-->
		<method name="getSelectedYear"><![CDATA[
			return this.selectedYear;
			]]>
		</method>
		
		<!---
			Determines if this selector including its dropdown contains the mouse cursor.
			@return true if the mouse cursor is contained in this selector or its dropdown when the dropdown is open.
				False otherwise.
		-->
	    <method name="containsMouse"><![CDATA[
	    	if(this.containsPt(this.getMouse("x"), this.getMouse("y"))){
				return true;
			}
			
			return this.yearDropDown.containsMouse();
	    	]]>
	    </method>
	</class>
	
	<!---
		@keywords private
		A dropdown specialized in displaying years for {@link wcfYearSelector}
	-->
	<class name="wcfYearDropDown" extends="wcfValueSelector" showDropDownButton="false" centerText="true">
		<!---  The available years will range from current year - yearRange to current year + yearRange -->
		<attribute name="yearRange" value="5"/>
		
		<!---
			@keywords private
			When this dropdown is initialized, populates years available to choose, and selects the year
			in the current system time.
		-->
		<handler name="oninit"><![CDATA[
			populateYears();
			selectCurrentYear();
			]]>
		</handler>
		
		<!---
			@keywords private
			Gets the year in the current system time in full format. For example, 1984 instead of 84.
			@return Number the full year in the current system time.
		-->
		<method name="getCurrentYear"><![CDATA[
			return (wcfDateUtil.getCurrentDate()).getFullYear();
			]]>
		</method>
		
		<!---
			@keywords private
			Populates years available to choose. There will be 2 x {@link wcfYearDropDown#yearRange} years
			available, starting from current year minus year range, and ending with current year plus year
			range.
		-->
		<method name="populateYears"><![CDATA[
			var currentYear = getCurrentYear();
			
			for(var i = -this.yearRange; i <= this.yearRange; ++i){
				var year = currentYear + i;
				new lz.wcfValueSelectorValue(this, {displayName: year, value: year});
			}		
			]]>
		</method>
		
		<!---
			@keywords private
			
			Updates the selected year by the given delta.
			@param delta the difference to be added to the currently selected value. To decrease the selected
			value, use a negative delta.
		-->
		<method name="updateYear" args="delta"><![CDATA[
			var newYear = this.selectedValue.value + delta;
			
			this.setYear(newYear);
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the values in a drop-down list, making sure when the list is open,
			the year value starts from currently selected year - yearRange, and ends with
			currently selected year + yearRage.
		-->
		<method name="updateYearsInDropDown"><![CDATA[
			var currentYear = this.selectedValue.value;
			for(var i = 0, len = 2 * this.yearRange; i <= len; ++i){
				var year = currentYear + i - this.yearRange;
				var value = this.values[i];
				value.setAttribute("displayName", year);
				value.setAttribute("value", year);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Handles keyboard shortcuts. Overwrites the default behaviour.
		-->
		<method name="callOnKeyDown" args="k">
			<![CDATA[
			if (k == 37) { // left arrow
				this.updateYear(-1);
			}else if (k == 39) { // right arrow
				this.updateYear(1);
			}
			]]>
		</method>

		<!---
			@keywords private
			Opens this dropdown, ensuring correct years are populated.
		-->
		<method name="openList"><![CDATA[
			this.updateYearsInDropDown();
			super.openList();
			this.bringToFront();
			]]>
		</method>
		
		<!---
			@keywords private
			Selects the current year as the dropdown's value.
			@event onselectedValue
		-->
		<method name="selectCurrentYear"><![CDATA[
			this.setAttribute("selectedValue", this.values[this.yearRange]);
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the value of this dropdown to the given year.
			@param Number year the year to be set to.
		-->
		<method name="setYear" args="year"><![CDATA[
			this.selectedValue.value = year;
			this.selectedValue.displayName = year;
			this.onselectedValue.sendEvent();
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the the displayed year to the given value. This dropdown's value will
			be updated, but onselectedValue event will not be sent.
			@param Number year the year to be displayed
		-->
		<method name="changeDisplayedYear" args="year"><![CDATA[
			if (this['selectedValue']) {
				this.selectedValue.value = year;
				this.selectedValue.displayName = year;
			}
			this.updateSelectedValue();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="_applystyle" args="s">
			if (this.style != null) {
				this.selectedValueText.setAttribute("fgcolor", s.datepickeryeartextcolor);
				this.selectedValueText.setAttribute("fontsize", s.datepickeryeartextsize);
			}
		</method>

	</class>
	
	<!---
		@keywords private
		This class represents a week in the @{link wcfDatePicker}. A week contains seven
		days, each of which represented by {@link wcfDatePickerDay}. It also knows which
		date picker panel it is in. A date picker panel is represented by {@link wcfDatePickerPopupWindow}.
	-->
	<class name="wcfDatePickerWeek">
		<simplelayout axis="x"/>
		<wcfDatePickerDay name="day0"/>
		<wcfDatePickerDay name="day1"/>
		<wcfDatePickerDay name="day2"/>
		<wcfDatePickerDay name="day3"/>
		<wcfDatePickerDay name="day4"/>
		<wcfDatePickerDay name="day5"/>
		<wcfDatePickerDay name="day6"/>	
	</class>

	<!---
		@keywords private
		
		This class represents a day interally used by {@link wcfDatePicker}. Users clicks on a day
		to select it in a date picker panel. A day can be deactivated if it is displayed in a month
		that it does not belong to. By default, a day is represented as a square box.
	-->
	<class name="wcfDatePickerDay" resource="datePickerDayCellBackground" extends="basecomponent" focusable="false" >
		<!---
			The value of this day. It is a Javascript Date object. The Date instance's getDay() method
		-->
		<attribute name="value" value="${null}"/>
		
		<!---
			True if this instance is active. False otherwise. Only an active instance be manipulated by user.
		-->
		<attribute name="active" type="boolean" value="true"/>
		
		<!---  Added two pixels because text itself is not center aligned -->
		<text name="dayName" fgcolor="${(parent.active) ? classroot.style.datepickeractivefontcolor : classroot.style.datepickerinactivefontcolor}"
				x="${(classroot.width - this.width)/2+1}" y="${(classroot.height - this.height)/2-1}">
			<method name="init">
				<![CDATA[
				super.init();
				this.setAttribute("text", classroot.value == null ? "" : classroot.value.getDate());
				]]>
			</method>
			<handler name="onvalue" reference="classroot">
				<![CDATA[
				this.setAttribute("text", classroot.value == null ? "" : classroot.value.getDate());
				]]>
			</handler>
		</text>

		<!---
			@keywords private
		-->
		<method name="init">
			<![CDATA[
			super.init();
			this.resetStyleDel = new lz.Delegate(this,"resetStyle");
			this.resetStyleDel.register(wcfDatePickerPopupWindow, "popupDateChangedEvent");
			this.resetStyle();
			]]>
		</method>

		<!---
			@keywords private
		-->
		<method name="destroy">
			<![CDATA[
			this.resetStyleDel.unregisterAll();
			delete this.resetStyleDel;
			super.destroy();
			]]>
		</method>

		<!---
			@keywords private
			Sets the year this day is in.
			@param Number year the year to be set
			@event onvalue
		-->
		<method name="setYear" args="year">
			<![CDATA[
			this.value = this.value || wcfDateUtil.getCurrentDate();
			this.value.setFullYear(year);
			if(this["onvalue"]){
				this.onvalue.sendEvent();
			}
			]]>
		</method>

		<!---
			@keywords private
			Sets the month this day is in
			@param Number month the month this day should be in
			@event onvalue
		-->
		<method name="setMonth" args="month">
			<![CDATA[
			this.value = this.value || wcfDateUtil.getCurrentDate();
			this.value.setMonth(month);
			if(this["onvalue"]){
				this.onvalue.sendEvent();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the date of this day represent in a month
			@param Number date the date to be set
		 -->
		<method name="setDate" args="date"><![CDATA[
			this.value = this.value || wcfDateUtil.getCurrentDate();
			this.value.setDate(date);
			if(this["onvalue"]){
				this.onvalue.sendEvent();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Sets this day with a given date.
			@param Date dateObj the new date this day should represent
		-->
		<method name="setValue" args="dateObj"><![CDATA[
			this.value = this.value || wcfDateUtil.getCurrentDate();
			with(this.value){
				setDate(1);
				setFullYear(dateObj.getFullYear());
				setMonth(dateObj.getMonth());
				setDate(dateObj.getDate());
			}
			if(this["onvalue"]){
				this.onvalue.sendEvent();
			}
			]]>
		</method>

		<!---
			@keywords private
		-->
		<handler name="onmouseover">
			<![CDATA[
			this.setHoverStyle();
			]]>
		</handler>

		<!---
			@keywords private
			Sets the cell with mouse hover look and feel for cells that are active.
		 -->
		<method name="setHoverStyle">
			<![CDATA[
			if(this.active){
				this.setAttribute('frame', 3);
				this.dayName.setAttribute("fgcolor", this.style.datepickeractivefonthovercolor);
			}
			]]>
		</method>

		<!---
			@keywords private
		-->
		<handler name="onmousedown">
			<![CDATA[
			this.setSelectedStyle();
			]]>
		</handler>

		<!---
			@keywords private
			Sets the cell with selected date look and feel for cells that are active.
		 -->
		<method name="setSelectedStyle">
			<![CDATA[
			if(this.active){
				this.setAttribute('frame', 4);
				this.dayName.setAttribute("fgcolor", this.style.datepickeractivefontcolor);
			}
			]]>
		</method>

		<!---
			@keywords private
		-->
		<handler name="onactive">
			<![CDATA[
			this.setNormalStyle();
			]]>
		</handler>

		<!--
			@keywords private
			Sets the cell with normal look and feel of the cell. Sets different look and feel for cells from current month and cells from other months.
		 -->
		<method name="setNormalStyle">
			<![CDATA[
			if (this.isinited) {
				if(this.active){
					this.setAttribute('frame', 2);
					this.dayName.setAttribute("fgcolor", this.style.datepickeractivefontcolor);
				}else{
					this.setAttribute('frame', 1);
					this.dayName.setAttribute("fgcolor", this.style.datepickerinactivefontcolor);
				}
			}
			]]>
		</method>

		<!---
			@keywords private
		-->
		<handler name="onmouseout">
			<![CDATA[
			this.resetStyle();
			]]>
		</handler>

		<!---
			@keywords private
			Resets the cell style.
		 -->
		<method name="resetStyle" args="e=null">
			<![CDATA[
			if(wcfDateUtil.compareDate(wcfDatePickerPopupWindow.popupDate, this.value)){ // if it is popupDate
				this.setHoverStyle();
				this.setAttribute("focusable",true);
			}else if(wcfDateUtil.compareDate(wcfDatePickerPopupWindow.selectedDate, this.value)){ // if it is selectedDate
				this.setSelectedStyle();
				this.setAttribute("focusable",false);
			}else{
				this.setNormalStyle();
				this.setAttribute("focusable",false);
			}
			]]>
		</method>

		<!---
			@keywords private
			Updates the selected date with this day when this day is clicked on.
		 -->
		<handler name="onclick"><![CDATA[
			var now = wcfDateUtil.getCurrentDate();
			with(now){
				setDate(1);
				setFullYear(this.value.getFullYear());
				setMonth(this.value.getMonth());
				setDate(this.value.getDate());
			}
			wcfDatePickerPopupWindow.setAttribute("popupDate", now);
			wcfDatePickerPopupWindow.dateSelected();
			]]>
		</handler>
		
		<!--- @keywords private -->
		<handler name="onfocus" >
			<![CDATA[
			if(!this["indicator"]){
				new lz.wcfFocusIndicator(this, {
					name: "indicator",
					focusableView: this,
					indicatorView: this,
					offset: 2,
					x: 1,
					y: -1
				});
			}
			]]>
		</handler>

		<!--- @keywords private -->
		<handler name="onkeydown" args="code">
			if (code == 37) { // left arrow
				wcfDatePickerPopupWindow.movePopupDate("left");
			}else if (code == 38) { // up arrow
				wcfDatePickerPopupWindow.movePopupDate("above");
			}else if (code == 39) { // right arrow
				wcfDatePickerPopupWindow.movePopupDate("right");
			}else if (code == 40) { // down arrow
				wcfDatePickerPopupWindow.movePopupDate("below");
			}else if (code == 13 || code == 32) { // enter or spacebar
				this.onclick.sendEvent();
			}
		</handler>

	</class>
	
	<!---
		@keywords private
		The text used for date picker header
	 -->
	<class name="wcfDatePickerHeaderText" extends="text" width="23" resize="false"/>
	
	<!---
		@keywords private
		Button used in a date picker.
	 -->
	<class name="wcfDatePickerButton" extends="basecomponent" width="${this.text.width + 15}"  focusable="true" >
		<stableborderlayout axis="x"/>
		<view name="left" resource="datePickerButtonLeft"/>
		<view name="center" stretches="width" resource="datePickerButtonCenter"/>
		<view name="right" resource="datePickerButtonRight"/>
		
		<text name="text" text="${foundationResources.datePickerToday.string}" x="${(parent.width - this.width) / 2}" y="${((parent.height - this.height) / 2) - 1}"/>

		<!--- @keywords private -->
		<handler name="onfocus" >
		    <![CDATA[
		    if(!this["indicator"]){
			    new lz.wcfFocusIndicator(this, {
			    	name: "indicator",
			    	focusableView: this,
			    	indicatorView: this,
			    	offset: 1,
			    	x: 1,
			    	y: -1
			    });
		    }
			]]>
		</handler>

		<!---
			@keywords private
			Sets the background of this button correspondingly
		 -->
		<handler name="onmouseover"><![CDATA[
			this.left.setAttribute('frame', 2);
			this.center.setAttribute('frame', 2);
			this.right.setAttribute('frame', 2);
			]]>
		</handler>

		<!---
			@keywords private
			Sets the background of this button correspondingly
		 -->
		<handler name="onmousepressed"><![CDATA[
			this.left.setAttribute('frame', 3);
			this.center.setAttribute('frame', 3);
			this.right.setAttribute('frame', 3);
			]]>
		</handler>
	
		<!---
			@keywords private
			Sets the background of this button correspondingly
		 -->
		<handler name="onmouseout"><![CDATA[
			this.left.setAttribute('frame', 1);
			this.center.setAttribute('frame', 1);
			this.right.setAttribute('frame', 1);
			]]>
		</handler>
	</class>
	
	<!---
		@keywords private
		The main panel of a date picker popup. It hosts selectors for users to pick year, month, and
		day. At any moment, an instance of this class displays all the weeks a month occupies.
		If the month is not selected by a user, the month in the current system time will be
		used.
	 -->
	<basewindow id="wcfDatePickerPopupWindow"
		allowdrag ="true"
		focustrap="true"
		onmousedown="this.dragger.setAttribute('applied', true)"
		onmouseup="this.dragger.setAttribute('applied', false)"
		visible="false"
		initstage="defer">
		<!---
			@keywords private
			The date selected by a user
		 -->
		<attribute name="selectedDate" value="${null}"/>
		
		<!---
			@keywords private
			The date currently displayed on this window. This value will be
			set to the selectedDate when this panel is closed.
		 -->
		<attribute name="popupDate" value="${wcfDateUtil.getCurrentDate()}" when="once"/>
		
		<!---
			@keywords private
			Event that notifies listeners that the popupDate has been changed.
		 -->
		<event name="popupDateChangedEvent"/>

		<!---
			@keywords private
			An object whose method dateSelected() will be called when a user selects a date
			from this panel.
		 -->
		<attribute name="callback" value="null"/>
		
		<dragstate name="dragger"
				drag_min_x="0"
				drag_max_x="$once{parent.width - this.width}"
				drag_min_y="0"
				drag_max_y="$once{parent.height - this.height}"
				drag_axis="both"/>
		
					
		<resizelayout axis="y"/>
		<view name="top">
			<simplelayout axis="x"/>
			<view name="left" resource="datePickerTopLeft"/>
			<view name="middle" resource="datePickerTop" stretches="width" width="${wcfDatePickerPopupWindow.middle.border.width}"/>
			<view name="right" resource="datePickerTopRight"/>
		</view>
		
		<view name="middle">
			<view name="left" x="0" height="${parent.border.height}" stretches="height" resource="datePickerLeft"/>
			<!---  The x position of this arrow is calculated backwards to avoid mis-alignment caused by border shadow, whose width is unknown. -->
			<basecomponent name="leftMonArrow" x="${parent.left.x + parent.left.width - this.width}" y="${(parent.left.height - this.height)/2}"
					resource="datePickerMonthLeftArrow" onmouseover="this.setAttribute('frame', 2)" onmouseout="this.setAttribute('frame', 1)" focusable="true">
				<handler name="onclick"><![CDATA[
					wcfDatePickerPopupWindow.advanceMonth(-1);
					]]>
				</handler>
				<handler name="onkeydown" args="code">
					if (code == 13 || code == 32) { // enter or spacebar
						this.onclick.sendEvent();
					}
				</handler>
				<!--- @keywords private -->
				<handler name="onfocus" >
				    <![CDATA[
				    if(!this["indicator"]){
					    new lz.wcfFocusIndicator(this, {
					    	name: "indicator",
					    	focusableView: this,
					    	indicatorView: this
					    });
				    }
					]]>
				</handler>
			</basecomponent>
			<view name="border" x="${parent.left.x + parent.left.width}" width="${this.background.width + 2}" height="${this.background.height + 2}" bgcolor="${wcfDatePickerPopupWindow.style.datepickerbordercolor}">
				<view name="background" x="1" y="1" width="${this.content.width + (this.content.padding * 2)}" height="${this.content.height + (this.content.padding * 2)}" bgcolor="${wcfDatePickerPopupWindow.style.datepickerbackgroundcolor}">
					<view name="content" x="${this.padding}" y="${this.padding}">
						<attribute name="padding" value="6"/>
						<simplelayout axis="y" spacing="${parent.padding}"/>
						<view name="toolbarView">
							<simplelayout name="dateFormatLayout" axis="x"/>
							<wcfMonthSelector name="month" width="92">
								<handler name="onselectedMonth"><![CDATA[
									wcfDatePickerPopupWindow.setMonth(this.getSelectedMonth());
									]]>
								</handler>
								<handler name="onkeydown" args="code" reference="monthDropDown"><![CDATA[
									if (code == 13) { // enter
										wcfDatePickerPopupWindow.dateSelected();
									}
									]]>
								</handler>
							</wcfMonthSelector>
		              		<wcfYearSelector name="year" width="78">
		              			<handler name="onselectedYear"><![CDATA[
		              				wcfDatePickerPopupWindow.setYear(this.getSelectedYear());
		              				]]>
		              			</handler>
		              			<handler name="onkeydown" args="code" reference="yearDropDown"><![CDATA[
									if (code == 13) { // enter
										wcfDatePickerPopupWindow.dateSelected();
									}
									]]>
								</handler>
		              		</wcfYearSelector>
				        </view>
						<wcfDatePickerButton x="${(parent.width - this.width)/ 2}">
							<handler name="onclick"><![CDATA[
								wcfDatePickerPopupWindow.setAttribute("popupDate", wcfDateUtil.getCurrentDate());
								]]>
							</handler>
							<handler name="onkeydown" args="code"><![CDATA[
								if (code == 32) { //spacebar
									wcfDatePickerPopupWindow.setAttribute("popupDate", wcfDateUtil.getCurrentDate());
								}else if(code == 13){  // enter
									wcfDatePickerPopupWindow.setAttribute("popupDate", wcfDateUtil.getCurrentDate());
									wcfDatePickerPopupWindow.dateSelected();
								}
								]]>
							</handler>
						</wcfDatePickerButton>
				        <view name="weeks" yoffset="4">
				        	<simplelayout axis="y" spacing="1"/>
							<view name="header">
								<simplelayout name="headerLayout" axis="x" spacing="1">
									<method name="update" args="e=null"><![CDATA[
										var firstDay = preferenceManager.getPreference("CMCFirstDayOfWeek");
										if(!this.locked && firstDay){
											this.lock();
											var length = this.subviews.length-1;
											while(this.subviews[0].name != firstDay) // shift the subviews to reflect first day of week preference
												this.setLayoutOrder('first',this.subviews[length]);
										 	this.locked = false;
										 }
										super.update();
										]]>
									</method>
								</simplelayout>
								<wcfDatePickerHeaderText name="SUN" text="${foundationResources.datePickerSun.string}"/>
								<wcfDatePickerHeaderText name="MON" text="${foundationResources.datePickerMon.string}"/>
								<wcfDatePickerHeaderText name="TUE" text="${foundationResources.datePickerTue.string}"/>
								<wcfDatePickerHeaderText name="WED" text="${foundationResources.datePickerWed.string}"/>
								<wcfDatePickerHeaderText name="THU" text="${foundationResources.datePickerThu.string}"/>
								<wcfDatePickerHeaderText name="FRI" text="${foundationResources.datePickerFri.string}"/>
								<wcfDatePickerHeaderText name="SAT" text="${foundationResources.datePickerSat.string}"/>
							</view>
							<wcfDatePickerWeek name="week0"/>
							<wcfDatePickerWeek name="week1"/>
							<wcfDatePickerWeek name="week2"/>
							<wcfDatePickerWeek name="week3"/>
							<wcfDatePickerWeek name="week4"/>
							<wcfDatePickerWeek name="week5"/>
				        </view>
			        </view>
		        </view>
	        </view>
			<view name="right" x="${parent.left.x + parent.left.width + parent.border.width}" height="${parent.border.height}" stretches="height" resource="datePickerRight"/>
			<basecomponent name="rightMonArrow" x="${parent.right.x}" y="${(parent.right.height - this.height)/2}" resource="datePickerMonthRightArrow" onmouseover="this.setAttribute('frame', 2)" onmouseout="this.setAttribute('frame', 1)" focusable="true">
				<handler name="onclick"><![CDATA[
					wcfDatePickerPopupWindow.advanceMonth(1);
					]]>
				</handler>
				<handler name="onkeydown" args="code">
					if (code == 13 || code == 32) { // enter or spacebar
						this.onclick.sendEvent();
					}
				</handler>
				<!--- @keywords private -->
				<handler name="onfocus" >
				    <![CDATA[
				    if(!this["indicator"]){
					    new lz.wcfFocusIndicator(this, {
					    	name: "indicator",
					    	focusableView: this,
					    	indicatorView: this
					    });
				    }
					]]>
				</handler>
			</basecomponent>
		</view>
		
		<view name="bottom" y="${parent.middle.x + parent.middle.height}">
			<simplelayout axis="x"/>
			<view name="left" resource="datePickerBottomLeft"/>
			<view name="middle" resource="datePickerBottom" stretches="width" width="${wcfDatePickerPopupWindow.width - parent.left.width - parent.right.width}"/>
			<view name="right" resource="datePickerBottomRight"/>
		</view>
		
		<!---
			@keywords private
			Returns the first day off set value depending on the firstDayOfWeek preference set by the business user.
			@return number
		 -->		
		<method name="getFirstDayOffSet">
			<![CDATA[
			var firstDay = preferenceManager.getPreference("CMCFirstDayOfWeek");
			var offset = 0;
			if (firstDay == 'SUN')
				offset = 0;
			else if (firstDay == 'MON')
				offset = 1;
			else if (firstDay == 'TUE')
				offset = 2;
			else if (firstDay == 'WED')
				offset = 3;
			else if (firstDay == 'THU')
				offset = 4;
			else if (firstDay == 'FRI')
				offset = 5;
			else if (firstDay == 'SAT')
				offset = 6;
				
			return offset;
			]]>
		</method>
		
		
		<!---
			@keywords private
			@return lz.view the view that represents the toolbar of this panel
		 -->
		<method name="getToolbar"><![CDATA[
			return this.middle.border.background.content.toolbarView;
			]]>
		</method>
		
		<!---
			@keywords private
			@return true if the mouse cursor is contained in this panel, including the dropdown of
				 the year selector or the month selector. False otherwise.
		 -->
		<method name="containsMouse"><![CDATA[
			if(this.containsPt(this.getMouse("x"), this.getMouse("y"))){
				return true;
			}
			
			var toolbar = this.getToolbar();
			return toolbar.month.containsMouse() || toolbar.year.containsMouse();
			]]>
		</method>
		
		<!---
			@keywords private
			Calculates which day in a week at which the month of the given
			date starts. For example, if the given date is 2007-11-01,
			this function will return 6, because 2007-Nov-01 is Saturday.
			@param Date date the date to be used for calculation
			@return Number the day in a week at which the month of the given
			date starts.
		-->
		<method name="getStartDayOfMonth" args="date"><![CDATA[
			// Assumeing the first day in the first week is the first day of month, (date.getDate() - 1) % 7
			// finds the hypothetical days before date.getDays(). Substract this day by the actual days in a week,
			// we will get the days shifted from this hypothetical arrangement.
			var day = this.popupDate.getDay() - ((this.popupDate.getDate()-1) % 7);
			//firstday offset is applied from business user preference
			day = (day < 0? day + 7: day) - this.getFirstDayOffSet();
			//there are cases when the day is negative, which means a week must be added to the calander to show the days from previous month
			if(day < 0)
				day = day + 7;
			return day;
			]]>
		</method>
		
		<!---
			@keywords private
			@return lz.view the area that contains all the works for a particular month
		 -->
		<method name="getWeeksArea"><![CDATA[
			return this.middle.border.background.content.weeks;
			]]>
		</method>
		
		<!---
			@keywords private
			Searches for a cell in the current month for a given date.
			@param Date currentDate the given date in the current month.
			@param Number dayOffset a signed integer denoting the number of days to add to the given date.
			@param Number weekOffset a signed integer denoting the number of weeks to add to the given date.
			@return wcfDatePickerDay the resultant cell. Returns null if the cell is not found.
		-->
		<method name="findCell" args="currentDate, dayOffset, weekOffset">
			<![CDATA[
			var cell = null;
			var weeks = this.getWeeksArea();
			var startDay = this.getStartDayOfMonth(currentDate);
			var cellCount = currentDate.getDate() + startDay - 1 + dayOffset;
			var weekIndex = Math.floor(cellCount / 7) + weekOffset;
			var dayIndex = cellCount % 7;
			if(0 <= weekIndex && weekIndex <= 5
			&& 0 <= dayIndex && dayIndex <= 6){
				cell = weeks["week"+weekIndex]["day"+dayIndex];
			}
			return cell;
			]]>
		</method>

		<!---
			@keywords private
			If the first week displayed in this panel contains days from the previous month, populates these
			days to the first week.
		-->
		<method name="populateDaysFromPreviousMonth"><![CDATA[
			var date = wcfDateUtil.getCurrentDate();
			with(date){
				setDate(1);
				setFullYear(this.popupDate.getFullYear());
				setMonth(this.popupDate.getMonth() - 1);
			}
			// Populate days from previous month
			var startDay = this.getStartDayOfMonth(this.popupDate);
			var daysInPrevMonth = wcfDateUtil.daysinmonth(date);
			var weeks = this.getWeeksArea();
			for(var day = 0; day < startDay; ++day){
				date.setDate(daysInPrevMonth + 1 - startDay + day);
				weeks["week0"]["day"+day].setValue(date);
				weeks["week0"]["day"+day].setAttribute("active", false);
			}
			]]>
		</method>
		
		
		<!---
			@keywords private
			Populates all the days in the current displayed month to this panel.
		-->
		<method name="populateDaysForThisMonth"><![CDATA[
			var weeks = this.getWeeksArea();
			var numberOfDays = wcfDateUtil.daysinmonth(this.popupDate);
			var startDay = this.getStartDayOfMonth(this.popupDate);
			var date = wcfDateUtil.getCurrentDate();
			with(date){
				setDate(1);
				setFullYear(this.popupDate.getFullYear());
				setMonth(this.popupDate.getMonth());
			}
						
			var cellCount = startDay
			for(var day = 1; day <= numberOfDays; ++day){
				var weekIndex = Math.floor(cellCount / 7);
				var dayIndex = cellCount % 7;
				date.setDate(day);
				weeks["week"+weekIndex]["day"+dayIndex].setValue(date);
				weeks["week"+weekIndex]["day"+dayIndex].setAttribute("active", true);
				cellCount++;
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Hides all the unused weeks in this panel. There will be unused weeks
			because the panel holds as many as 6 weeks, but not every month uses
			6 weeks.
		-->
		<method name="hideUnusedWeeks"><![CDATA[
			var startDay = this.getStartDayOfMonth(this.popupDate);
			var numberOfDays = wcfDateUtil.daysinmonth(this.popupDate);
			var lastWeek = Math.floor((numberOfDays + startDay - 1)/ 7);
			
			var weeks = this.getWeeksArea();
			for(var week = lastWeek + 1; weeks["week"+week]; ++week){
				weeks["week"+week].setAttribute("visible", false);
				for(var i=0; i < 7; i++){
					weeks["week"+week]["day"+i].value = null;
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			If the last week contains days for the month next to the currently displayed one, populates
			those days to the last week.
		-->
		<method name="populateDaysForNextMonth"><![CDATA[
			var startDay = this.getStartDayOfMonth(this.popupDate);
			var numberOfDays = wcfDateUtil.daysinmonth(this.popupDate);
			
			var weeks = this.getWeeksArea();
			var lastWeek = Math.floor((numberOfDays + startDay - 1)/ 7);
			weeks["week"+lastWeek].setAttribute("visible", true);
			
			var date = wcfDateUtil.getCurrentDate();
			with(date){
				setDate(1);
				setFullYear(this.popupDate.getFullYear());
				setMonth(this.popupDate.getMonth()+1);
			}
				
			
			var daysForNextMonth = (lastWeek + 1) * 7 - numberOfDays - startDay;
			for(var day = 0; day < daysForNextMonth; ++day){
				date.setDate(daysForNextMonth - day);
				var dayOffset = 6 - day;
				weeks["week"+lastWeek]["day"+dayOffset].setValue(date);
				weeks["week"+lastWeek]["day"+dayOffset].setAttribute("active", false);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Populates days and update the headers that should be displayed for the currently selected month in this
			panel.
		-->
		<method name="populateDays"><![CDATA[
			this.middle.border.background.content.weeks.header.headerLayout.update();
			this.populateDaysFromPreviousMonth();
			this.populateDaysForThisMonth();
			this.populateDaysForNextMonth();
			this.hideUnusedWeeks();
			]]>
		</method>

		<!---
			@keywords private
			Sets the displayed month and year on the toolbar view.
		-->
		<method name="setToolbarValues"><![CDATA[
			this.middle.border.background.content.toolbarView.month.changeDisplayedMonth(this.popupDate.getMonth());
			this.middle.border.background.content.toolbarView.year.changeDisplayedYear(this.popupDate.getFullYear());
		
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<handler name="onpopupDate">
			<![CDATA[
			this.updateDisplay();
			]]>
		</handler>
		
		<!---
			@keyword private
			Updates the displayed values when the currently selected date is changed.
		 -->
		<method name="updateDisplay">
			<![CDATA[
			this.setToolbarValues();
			this.populateDays();
			this.popupDateChangedEvent.sendEvent();
			]]>
		</method>
		
		<!---
			@keyword private
			Updates the toolbar view to reflect the user date format preference
		 -->
		<method name="setToolbarView">
			<![CDATA[
			var toolbarView = this.middle.border.background.content.toolbarView;
			var monthPos = toolbarView.subviews.indexOf(toolbarView.month);
			var yearPos = toolbarView.subviews.indexOf(toolbarView.year);
			if(wcfDateUtil.isMonthBeforeYear()){
				if (monthPos > yearPos) {
					toolbarView.subviews.splice(monthPos, 1);
					toolbarView.subviews.splice(yearPos, 0, toolbarView.month);
				}
				toolbarView.dateFormatLayout.setLayoutOrder(toolbarView.month, toolbarView.year);
				toolbarView.month.monthDropDown.setAttribute("dropDownButtonAtLeft", true);
				toolbarView.year.leftArrow.setAttribute("resource", "datePickerYearLeftArrow");
				toolbarView.year.rightArrow.setAttribute("resource", "datePickerYearRightArrow");				
			}else{
				if (yearPos > monthPos) {
					toolbarView.subviews.splice(yearPos, 1);
					toolbarView.subviews.splice(monthPos, 0, toolbarView.year);
				}
				toolbarView.dateFormatLayout.setLayoutOrder(toolbarView.year, toolbarView.month);
				toolbarView.month.monthDropDown.setAttribute("dropDownButtonAtLeft", false);
				toolbarView.year.leftArrow.setAttribute("resource", "datePickerYearLeftArrowInvert");
				toolbarView.year.rightArrow.setAttribute("resource", "datePickerYearRightArrowInvert");
			}
			toolbarView.month.monthDropDown.backgroundLayout.update();
			]]>
		</method>
		
		<!---
			@keyword private
			Sets the correct date values when this panel's visibility changes
		 -->
		<handler name="onvisible">
			<![CDATA[
			if (this.visible) {
				this.popupDate = (this.selectedDate ?  new Date(this.selectedDate) : wcfDateUtil.getCurrentDate());
				this.updateDisplay();
				lz.Focus.setFocus(this.findCell(this.popupDate, 0, 0), false);
			}else{
				// If this window becomes invisible, remove the association of
				// this window and its date picker.
				this.callback = null;
			}
			]]>
		</handler>
		
		<!---
			@keywords private
			Changes the selected month by the given difference.
			@param Number diff the number of months to be changed. Negative value means substraction. Positive means addition.
		 -->
		<method name="advanceMonth" args="diff">
			<![CDATA[
				this.setMonth(this.popupDate.getMonth() + diff);
			]]>
		</method>

		<!---
			@keywords private
			Changes the selected year by the given difference.
			@param Number diff the number years to be changed. Negative value means substraction. Positive means addition.
		 -->
		<method name="advanceYear" args="diff">
			<![CDATA[
				this.setYear(this.popupDate.getFullYear() + diff);
			]]>
		</method>

		<!---
			@keywords private
			Sets the selected year to the given year.
			@param Number year the year to be changed to
		 -->
		<method name="setYear" args="year"><![CDATA[
			this.popupDate.setFullYear(year);
			this.onpopupDate.sendEvent();
			]]>
		</method>
				
		<!---
			@keywords private
			Sets the selected month to the given month
			@param Number month the month to set
		 -->
		<method name="setMonth" args="month"><![CDATA[
			
			var tempDate = wcfDateUtil.copydate(this.popupDate);
			tempDate.setDate(1);
			tempDate.setMonth(month);
			if (this.popupDate.getDate() > wcfDateUtil.daysinmonth(tempDate))
			{
				this.popupDate.setDate(wcfDateUtil.daysinmonth(tempDate));
			}						
			this.popupDate.setMonth(month);
			this.onpopupDate.sendEvent();
			]]>
		</method>
		
		
		<!---
			@keywords private
			Sets the selected day to the given day
			@param Number day the day to be set to			
		 -->
		<method name="setDay" args="day"><![CDATA[
			this.popupDate.setDate(day);
			this.onpopupDate.sendEvent();
			]]>
		</method>
		
		<!---
			Notifies that a user finally selects a date, and syncrhonizes the selectedDate with the popupDate.
		 -->
		<method name="dateSelected">
			<![CDATA[
				this.setAttribute("selectedDate", this.popupDate);
				this['callback'] && this.callback['dateSelected'] && this.callback.dateSelected();
			]]>
		</method>
		
		<!---
			@keywords private
			Moves the popup date in the given direction. Also highlites the new cell.
			@param String direction the direction in which the current popup date has to be moved to.
		 -->
		<method name="movePopupDate" args="direction">
			<![CDATA[
			var dayOffset = 0;
			var weekOffset = 0;
			if(direction == "left"){
				dayOffset = -1;
				weekOffset = 0;
			}else if(direction == "above"){
				dayOffset = 0;
				weekOffset = -1;
			}else if(direction == "right"){
				dayOffset = 1;
				weekOffset = 0;
			}else if(direction == "below"){
				dayOffset = 0;
				weekOffset = 1;
			}
			var nextCell = this.findCell(this.popupDate, dayOffset, weekOffset);
			if(nextCell && wcfDateUtil.datemonthsdiff(nextCell.value, this.popupDate) == 0){
				this.popupDate = nextCell.value;// do not send event here
				this.popupDateChangedEvent.sendEvent();
				lz.Focus.setFocus(nextCell, false);
			}
			]]>
		</method>
	</basewindow>
	
	<!---
		@keywords private
		
		The class represents a date picker that allows users to select a date. The selected date will be stored in
		a property bound to this date picker. The selected date can be retrieved by calling {@link wcfDatePicker#getDate}.
	-->
	<class name="wcfDatePicker" extends="basecomponent" focusable="false">
		<!--- Reference to wcfModelProperty object that is being edited. -->
		<attribute name="property" value="null" setter="setProperty(property)"/>
		<!--- Whether or not to ignore the time when saving the date string value. Default value is <code>false</code>. -->
		<attribute name="dateOnly" type="boolean" value="false"/>
		<!---
			When true, the time of day for this date picker will be saved to the server as the end of the day 23:59:59:999
			otherwise start of day is used 00:00:00:001. This attribute is ignored if {@link wcfDatePicker#dateOnly} is <code>true</code>.
		-->
		<attribute name="endOfDay" type="boolean" value="false"/>

		<!---
			The pattern used to format the date for display. This value should not be
			set directly. It is taken from the current user preference.
		-->
		<attribute name="displayFormat" value="$once{wcfDateUtil.getDatePreferenceFormat()}"/>
		<!---
			The prompt text displayed when no date has been entered. This value should not be
			set directly. It is taken from the current user preference.
		-->
		<attribute name="promptText" value="$once{wcfDateUtil.getDatePreferenceFormatDisplayKey().string}"/>

		<!---
			@keywords private
		-->
		<method name="destroy">
			if (this["updateValueDel"]) {
				this.updateValueDel.unregisterAll();
				delete this.updateValueDel;
			}
			if(this["updatePromptDel"]){
				this.updatePromptDel.unregisterAll();
				delete this.updatePromptDel;
			}
			super.destroy();
		</method>

		<!---
			@keywords private
		-->
		<handler name="oninit">
			<![CDATA[
			if (this["property"]) {
				this.updateValue();
			}
			this.updatePrompt();
			]]>
		</handler>

		<!---
			Closes the date picker panel when mouse clicks outside of the date picker panel;
		-->
		<method name="checkMouse" args="e=null">
			<![CDATA[
			if(!wcfDatePickerPopupWindow.containsMouse()){
				this.shrinkToIcon();
			}
			]]>
		</method>
		
		<!---
			Opens the date picker panel when user clicks on the date picker button
		 -->
        <method name="expandFromIcon">
            <![CDATA[      
            wcfDatePickerPopupWindow.completeInstantiation();
            wcfDatePickerPopupWindow.setToolbarView();  
            wcfDatePickerPopupWindow.setAttribute("selectedDate", this.getDate() || wcfDateUtil.getCurrentDate());
            wcfDatePickerPopupWindow.setAttribute("callback", this);
            wcfDatePickerPopupWindow.setAttribute("x", this.getAttributeRelative("x",canvas) + this.width);

            var popupY = this.getAttributeRelative("y",canvas);
            if ((popupY + wcfDatePickerPopupWindow.height) > (canvas.height - 10)) {
            	popupY = canvas.height - wcfDatePickerPopupWindow.height - 10;
            }
            wcfDatePickerPopupWindow.setAttribute("y", popupY);

            var popupX = this.getAttributeRelative("x", canvas);
            if((popupX + wcfDatePickerPopupWindow.width) > (canvas.width - 10)){
            	popupX = canvas.height - wcfDatePickerPopupWindow.width - 10;
            }
            wcfDatePickerPopupWindow.setAttribute("x", popupX);

			wcfDatePickerPopupWindow.setAttribute("visible", true);
            wcfDatePickerPopupWindow.bringToFront();

            if(!this["checkMouseDel"]){
            	this.checkMouseDel = new lz.Delegate(this,"checkMouse");
            }

            if(!this["shrinkToIconDel"]){
            	this.shrinkToIconDel = new lz.Delegate(this,"shrinkToIcon");
            }

            this.checkMouseDel.register(lz.GlobalMouse,"onmousedown");
            lz.Keys.callOnKeyCombo(this.shrinkToIconDel, ['esc']);
            lz.ModeManager.makeModal(wcfDatePickerPopupWindow);
            ]]>
        </method>

		<!---
			@keywords private
			Closes the date picker panel.
		 -->
		<method name="shrinkToIcon" args="e=null">
			<![CDATA[
				lz.ModeManager.release(wcfDatePickerPopupWindow);				
				wcfDatePickerPopupWindow.setAttribute("callback", null);
				wcfDatePickerPopupWindow.setAttribute("visible", false);
				this.checkMouseDel.unregisterAll();
				lz.Keys.removeKeyComboCall(this.shrinkToIconDel, ['esc']);
				lz.Focus.setFocus(this.normal_view.icon, false);
			]]>
		</method>

		<!---
			@keywords private
			Sets the date with the value in date picker panel and closes the panel.
		 -->
		<method name="dateSelected">
			<![CDATA[
				// Handling selected date only if this picker is associated with the date picker popup.
				if(this == wcfDatePickerPopupWindow.callback){
					this.setDate(wcfDatePickerPopupWindow.selectedDate);
					this.storeValue();
					this.shrinkToIcon();	
				}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the displayed prompt text in the date picker's text box
		 -->
		<method name="updatePrompt" args="e=null">
			<![CDATA[
			if(this["updatePromptDel"]){
				this.updatePromptDel.unregisterAll();
			}
			else {
				this.updatePromptDel = new lz.Delegate(this, "updatePrompt");
			}
			this.updatePromptDel.register(wcfDateUtil.getDatePreferenceFormatDisplayKey(), "onstring");
			var dateString = this.getDateString();
			this.promptText = wcfDateUtil.getDatePreferenceFormatDisplayKey().string;
			if (this.enabled && dateString == "" && !wcfViewUtil.containsView(this.normal_view.dateview.datestr, lz.Focus.getFocus())) {
				this.normal_view.dateview.datestr.setText(this.promptText);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This handler will update the date field if the user changes their date format preference
		-->
		<handler name="preferenceChanged" reference="preferenceManager" args="preference">
			<![CDATA[
			//if this event is for the CMCDateFormat preference
			if (preference == "CMCDateFormat") {
				var date = this.getDate();
				this.displayFormat = wcfDateUtil.getDatePreferenceFormat();
				if (date != null) {
					this.setDate(date);
				}
				this.updatePrompt();
			}
			]]>
		</handler>
		
		<!---
			@keywords private
			Sets the selected date with the given new date.
			@param Date newDate the given new date
		-->
		<method name="setDate" args="newDate">
			<![CDATA[
			var dateString = "";
			if (newDate != null) {
				dateString = wcfDateUtil.format(newDate, this.displayFormat);
			}
			this.setDateString(dateString);
			]]>
		</method>
		
		<!---
			@keywords private
			Gets the selected date
			@return Date the selected date of this date picker
		-->
		<method name="getDate">
			<![CDATA[
			var dateString = this.getDateString();
			return wcfDateUtil.parse(dateString, this.displayFormat);
			]]>
		</method>
		
		<!---
			@keywords private
			Gets the selected date as a string.
			@return string the selected date as a string
		-->
		<method name="getDateString">
			<![CDATA[
			var dateString = this.normal_view.dateview.datestr.getText();
			if (dateString == this.promptText) {
				dateString = "";
			}
			return dateString;
			]]>
		</method>
		
		<!---
			Set the date to the specified string.
			@keywords private
		-->
		<method name="setDateString" args="dateString">
			<![CDATA[
			this.normal_view.dateview.datestr.setText(dateString);
			this.updatePrompt();
			]]>
		</method>
		
		<!---
			@keywords private
			Sets a new property object.
			@param wcfModelProperty newProperty the new model property associated with this date picker
		-->
		<method name="setProperty" args="newProperty">
			<![CDATA[
			if (newProperty != this["property"]) {
				if (typeof(this.updateValueDel) == "undefined") {
					this.updateValueDel = new lz.Delegate(this, "updateValue");
				}
				this.updateValueDel.unregisterAll();
				this.property = newProperty;
				if (this.property) {
					this.updateValueDel.register(this.property, "onvalue");
					this.updateValue();
				}
				else if (this.isinited) {
					this.setDateString("");
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the date picker with a new property value.
		-->
		<method name="updateValue" args="e=null">
			<![CDATA[
			if (this.isinited) {
				var value = this.property.value;
				var newDate = wcfDateUtil.parse(value, wcfDateUtil.DATE_FORMAT);
				if (newDate != null) {
					this.setDate(newDate);
				}
				else {
					this.setDateString(value);
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Stores the property value with the selected date
		-->
		<method name="storeValue">
			<![CDATA[
			var newDate = this.getDate();
			if (newDate != null) {
				this.setDate(newDate);
				if (this["property"]) {
					var currentDate = wcfDateUtil.parse(this.property.value, wcfDateUtil.DATE_FORMAT);
					if (wcfDateUtil.normalizeToMilliseconds(newDate) != wcfDateUtil.normalizeToMilliseconds(currentDate)) {		
						var newValue = null;
						if(this.dateOnly) {
							newValue = wcfDateUtil.format(newDate, wcfDateUtil.DATE_ONLY_FORMAT);
						}
						else {
							newValue = (this.endOfDay) ? wcfDateUtil.format(newDate, wcfDateUtil.DATE_FORMAT_END) : wcfDateUtil.format(newDate, wcfDateUtil.DATE_FORMAT);
						}
						this.property.change(newValue);
						if (wcfLogger.enabled) {
							wcfLogger.log("com.ibm.commerce.lobtools.foundation.view", "INFO", "wcfDatePicker", "storeValue", "updates the model property " + this.property.propertyName + " with new value " + newValue + this.property.o.logString());
						}
					}
				}
			}
			else if (this["property"]) {
				this.property.change(this.getDateString());
				if(wcfLogger.enabled){
					wcfLogger.log("com.ibm.commerce.lobtools.foundation.view", "INFO", "wcfDatePicker", "storeValue", "updates the model property " + this.property.propertyName + " with new value " + this.getDateString() + this.property.o.logString());
				}
			}
			]]>
		</method>
		
        <simplelayout axis="y" placement="content" spacing="1"/>
		<view name="normal_view" focusable="false" clickable="${!classroot.enabled}" >
			<simplelayout axis="x" spacing="5"/>
			<view name="dateview" >
				<simplelayout axis="x"/>
				<wcfInputText name="datestr" enabled="${classroot.enabled}" width="${classroot.style.formshortinputwidth}" height="${classroot.style.forminputheight}">
					<handler name="onfocus">
						<![CDATA[
						if (this.enabled && this.getText() == classroot.promptText) {
							this.setText("");
						}
						]]>
					</handler>
					
					<handler name="onblur">
						<![CDATA[
						if(this.enabled){
							classroot.storeValue();
							if (this.getText() == "") {
								this.setText(classroot.promptText);
							}
						}
						]]>
					</handler>
					
					<handler name="onkeydown" args="key">
						<![CDATA[
						if (key == 13) {
							classroot.storeValue();
						}
						]]>
					</handler>
					
					<handler name="onenabled">
						<![CDATA[
						if (!this.enabled && this.getText() == classroot.promptText) {
							this.setText("");
						}else if (this.enabled && this.getText() == "") {
							this.setText(classroot.promptText);
						}
						]]>
					</handler>
				</wcfInputText>
		    </view>
	        <wcfFocusableBaseButton name="icon" enabled="${classroot.enabled}" resource="calendarButton">	
	            <wcfTooltip text="${foundationResources.datePickerTip.string}"/>	
	            <handler name="onclick">
	            	if (classroot.enabled){
	                	classroot.expandFromIcon();
	                }
	            </handler>			
	        </wcfFocusableBaseButton>
        </view>
    </class>
</library>
