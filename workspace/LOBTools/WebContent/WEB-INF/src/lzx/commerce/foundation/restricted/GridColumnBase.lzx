<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2007, 2011 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<library>

	<!---
		@keywords private
		This class defines a grid column dragger which is used to drag and drop inside of a grid.
	-->
	<view id="wcfGridColumnDragger" visible="false" opacity="0.25" options="ignorelayout">
		<!---
			Background color.
		-->
		<attribute name="bgcolor" value="white"/>
		<!---
			A reference to the column that is being dragged.
		-->
		<attribute name="dragColumn" value="null"/>
		<!---
			An array of the columns that are visible when the dragging takes place.
		-->
		<attribute name="visibleColumns" value="${[]}"/>
		<!---
			The column that the dragColumn is dropped on. The value of dropColumn is updated while the dragging takes place.
		-->
		<attribute name="dropColumn" value="null"/>

		<view name="background" width="${parent.width}" height="${parent.height}" resource="listHeaderBackground" stretches="both" frame="3"/>
		<view name="title" clip="true" width="${parent.width}" height="${parent.height}">
			<wcfCenterLayout/>
			<simplelayout axis="x"/>
			<view name="leftPadding" x="${parent.x}" height="${parent.height}" width="3" bgcolor="${parent.bgcolor}"/>
			<text name="requiredIndicator" text="*" resize="true"/>
			<text name="titleText" resize="true"/>
		</view>

		<dragstate name="dragger" drag_axis="x"/>

		<!---
			This method is called by a wcfGridColumn when it starts being dragged.

			@param wcfGridColumn column The column to start dragging.
		-->
		<method name="startDrag" args="column">
			<![CDATA[
			this.dragColumn = column;
			this.visibleColumns = [];
			var l = this.dragColumn.parent.columns.length;
			for(var i = 0; i < l; i++){
				var c = this.dragColumn.parent.columns[i];
				if(c.visible){
					this.visibleColumns.push(c);
				}
			}
			visibleColumns
			this.title.titleText.setAttribute("text", column.displayText);
			this.setAttribute("fgcolor", column.style.gridheadertextcolor);
			this.title.titleText.setAttribute("visible", column.titleVisible);
			this.title.requiredIndicator.setAttribute("visible", column.required);
			var x = column.title.getAttributeRelative("x", canvas);
			var y = column.title.getAttributeRelative("y", canvas);
			this.setAttribute('width', column.title.width);
			this.setAttribute('height', column.title.height);
			this.setAttribute('x', x);
			this.setAttribute('y', y);
			this.bringToFront();
			this.setAttribute("visible", true);
			this.dragger.setAttribute('applied', true);
			]]>
		</method>

		<!---
			This method is called by the wcfGridColumn when the dragging is completed.
		-->
		<method name="stopDrag" args="e=null">
			<![CDATA[
			this.dragger.setAttribute('applied', false);
			this.setAttribute("visible", false);
			if (this.dragColumn) {
				var columns = this.dragColumn.parent.columns;
				for (var i = 0; i < columns.length; i++) {
					columns[i].resizer.divider.setAttribute('frame', 1);
				}
				if(this.dropColumn){
				 	var position = this.dragColumn.parent.getColumnPosition(this.dropColumn);
					this.dragColumn.parent.setColumnPosition(this.dragColumn, position);
					this.dragColumn.parent.savePreferences();
					this.dragColumn = null;
					this.dropColumn = null;
				}
			}
			]]>
		</method>

		<!---
			This method is called while a column is dragged in order to calculate the dropColumn and
			highlight the appropriate columns of the grid. It is called by the wcfGridColumn being dragged.
		-->
		<method name="whileDrag">
			<![CDATA[
			this.dropPosition=null;
			if (this.dragColumn) {
				//var columns = this.dragColumn.parent.columns;
				var columns = this.visibleColumns;
				var mouseX = this.dragColumn.parent.getMouse(('x')) - this.dragColumn.parent.clippedContent.gridContent.x;
				var l = columns.length;
				var dragRight = false;
				for (var i = 0; i < l; i++) {
					var c = columns[i];
					var cBefore = columns[i+1];
					var cAfter = columns[i-1];
					if(this.dragColumn == c){
						dragRight = true;
					}
					c.resizer.divider.setAttribute('frame', 3);
					if (c != this.dragColumn) {
						var leftX = c.x;
						var middleX = leftX + (c.width/2);
						var rightX = leftX + c.width;
						if (mouseX >= leftX && mouseX < middleX) {
							//if this is the first column, and it's not draggable, then you don't want to put something before it
							if (i != 0 || c.draggable){
								if(dragRight){
									this.dropColumn = cAfter;
								}else{
									this.dropColumn = c;
								}
								if(cAfter){
									cAfter.resizer.divider.setAttribute('frame', 2);
								}
							}
						}else if(mouseX >= middleX && mouseX < rightX) {
							if (i != l){
								if(dragRight){
									this.dropColumn = c;
								}else{
									this.dropColumn = cBefore;
								}
								c.resizer.divider.setAttribute('frame', 2);
							}
						}
					}
				}
			}
			]]>
		</method>
	</view>

	<!---
		@keywords abstract
		<p>
		wcfGridColumn is the base class for all columns that appear in a {@link wcfObjectGrid}. This is an abstract class and must
		be extended in order to define new grid widgets that can appear as columns in a wcfObjectGrid. These new grid widgets
		should have their own cellEditors and cellViewers defined in column.
		</p><p>
		This class provides the functionality for sorting columns, dragging, filtering and setting visibility of the column.
		The base class also contains the logic for determining whether or not a particular wcfGridColumn is editable and
		the alignment of the column.
		</p><p>
		Placing a wcfGridColumn as a child of a wcfObjectGrid will create a new column in the grid. The columns will appear
		in the order that they are defined as children of the parent grid in the source code. The column order can be changed
		by the user by dragging and dropping the column headers in the grid.
		</p><p>
		wcfGridColumn is responsible for defining which widget to use for viewing the uneditable version of the data, and
		also the widget for editing the data. The wcfGridColumn class binds the specified objectProperty to the
		provided editor and viewer classes.
		</p>
	-->
	<class name="wcfGridColumn" extends="basecomponent" focusable="false">
		<!---
			Indicates that this column can be sorted. The default value for this attribute is "true".
		-->
		<attribute name="sortable" type="boolean" value="true"/>
		<!---
			@keywords private
			Indicates that find and replace can be performed on this column. The default value for this attribute is "false".
		-->
		<attribute name="findable" type="boolean" value="false"/>
		<!---
			Indicates that this column can be dragged to change the order of the column in the grid.
			The default value for this attribute is "true".
		-->
		<attribute name="draggable" value="true" type="boolean"/>
		<!---
			@keywords private
			Indicates that this column is currently being dragged.
		-->
		<attribute name="dragging" value="false" type="boolean"/>
		<!---
			@keywords private
			Initial dragging position of this column.
		-->
		<attribute name="startDragX" value="null"/>
		<!---
			Indicates that this is a required column. The default value for this attribute is "false".
			Required columns cannot be hidden by the user.
		-->
		<attribute name="required" type="boolean" value="false"/>
		<!---
			Indicates that this column will attempt to implicitly create the object described by {@link objectPath} if
			no matching object is found.  This attribute will be ignored if multiple cell descriptors are declared.
		-->
		<attribute name="implicitCreate" type="boolean" value="true"/>
		<!---
			Indicates that this column will invoke the {@link wcfGetChildrenService} services associated with the primary
			object referenced on the row.  The object definitions used for the request are those described by {@link objectPath},
			and all the cell descriptors object paths.  If the object referenced on the row is not a primary object,
			then no service requests are invoked.
		-->
		<attribute name="loadChildren" type="boolean" value="false"/>
		<!---
			This text is displayed if no objects can be found that match {@link objectPath} or any of the cell descriptors
			object paths.
		-->
		<attribute name="noMatchText" type="string" value=""/>
		<!---
			This text is displayed if multiple objects are found that match {@link objectPath} or any of the cell descriptors
			object paths.
		-->
		<attribute name="multipleMatchText" type="string" value=""/>
		<!---
			<p>
			This attribute is used to specify the path that is used to locate the property specified under the
			propertyName attribute. In other words objectPath is used to find a child Management Center object
			relative to the current object. If the property applies to the current object, then you do not need
			to specify an objectPath.
			</p><p>
			When trying to retrieve a property in the properties view, the current object refers to the open object
			which is typically the primary object.
			</p><p>
			When trying to retrieve a property in a list view, the current object refers to an object that is displayed in a row.
			If the list view results from search results, then the current object in the row is always a primary object.
			If the list view is a child list, then the current object is typically a reference object or a child object. For
			the case where the child list is for reference objects, the objectPath is the path required to navigate
			from the reference object  to its child object.
			</p>
		-->
		<attribute name="objectPath" type="string" value="${null}" setter="this.setObjectPath(objectPath)"/>
		<!---
			The name of the object property that is being displayed in this column. This is a required attribute.
		-->
		<attribute name="propertyName" type="string" value="${null}" setter="this.setPropertyName(propertyName)"/>
		<!---
			The column's data type. Valid data types are "string", "datetime" and "number". The default value is "string".
			The column's datatype will affect what value is returned by the {@link wcfGridColumnBase#getCompareValue} method
			when it extracts the value to use for sorting.
		-->
		<attribute name="datatype" type="string" value="string"/>
		<!---
			Indicates that this column supports edit in place. The default value is "true."
		-->
		<attribute name="editable" type="boolean" value="true"/>
		<!---
			This flag indicates if this column is visible when the table is initally loaded for a user. This flag will only affect the visibility of the
			column to the user before saved preferences for this grid exist. If a column is added to the grid after there are saved preferences for this grid,
			and the column is not {@link wcfGridColumn#required required}, then this column will be hidden regardless of the value of the visible flag.
			Users will need to use the configuration screen to show	the new column. The column will be shown/hidden to new users for whom saved preferences do
			not exist according to the visible flag.
		-->
		<attribute name="visible" value="true"/>
		<!---
			This attribute specifies the name of the view class used to create cell viewer instances for cells in this column.
			Classes which extend wcfGridColumn must provide a value for this attribute. This class is instantiated from the
			createViewer method to display an uneditable representation of the object property as a cell in the grid.
			The view class must have a setProperty() method.
			@type string
		-->
		<attribute name="cellViewerClass" type="string" value="${null}"/>
		<!---
			This attribute specifies the name of the view class used to create editor instances for cells in this column.
			Classes which extend wcfGridColumn and allow editing in place must provide this value. This class is
			instantiated from the createEditor method to create an editor for the object property as a cell in the grid.
			The view class must have a setProperty() method.
			@type string
		-->
		<attribute name="cellEditorClass" type="string" value="${null}"/>
		<!--- 
			This attribute specifies the name of the view class used to create the column editor for this column. 
			The column editor is used in the Edit Column dialog to update multiple cells in this column. Classes which 
			extend wcfGridColumn and allow column editing must provide this value. The class must be prepared to accept 
			two attributes: "column" and "selectedObjects". The "column" attribute is the wcfGridColumn instance. 
			The "selectedObjects" attribute is the array of {@link wcfModelObject model objects} that are currently 
			selected in the {@link wcfObjectGrid grid}.
		 -->
		<attribute name="columnEditorClass" type="string" value="${null}"/>
		<!---
			@keywords private
			Indicates where the column should be attached to the parent grid.
		-->
		<attribute name="placement" value="columns"/>
		<!---
			@keywords private
			Indicates that the column is currently sort in ascending order. The sort will be reversed if
			sort is requested twice.
		-->
		<attribute name="sortAscending" value="false" type="boolean"/>
		<!---
			The minimum width for this column.
		-->
		<attribute name="minwidth" value="$once{40 + (enableFilter==true ? this.title.filterButton.width : 0)}" type="number"/>
		<!---
			The text to display as the header of this column.
		-->
		<attribute name="text" type="string" value=""/>
		<!---
			Indicates if the header text of this column is visible. Default value for this attribute is "true".
		-->
		<attribute name="titleVisible" type="boolean" value="true"/>
		<!---
			The alignment for this column. Valid values are "left", "center" and "right".
			The default is "left".
		-->
		<attribute name="alignment" value="left" type="string"/>
		<!---
			@keywords private
			Array of language columns created as clones of this column.
		-->
		<attribute name="languageColumns" value="${[]}"/>
		<!---
			@keywords private
			Array of language columns created as clones of this column that are pooled
		-->
		<attribute name="languageColumnsPool" value="${[]}"/>
		<!---
			@keywords private
			Indicates that this column is pooled.
		-->
		<attribute name="pooled" type="boolean" value="false"/>
		<!---
			@keywords private
			Display text for this column. The "text" attribute will be appended with the language description if this is a language-sensitive property.
			This attribute is modified by the updateDisplayText method.
		-->
		<attribute name="displayText" type="string" value="${null}"/>
		<!---
			Indicates that this column is language-sensitive. language-sensitive columns will be replicated for each selected language.
			The default for this attribute is false.
		-->
		<attribute name="languageSensitive" type="boolean" value="false"/>
		<!---
			@keywords private
			The input language associated with this column. This is an instance of {@link wcfStoreLanguage}. If the input language is
			specified, then the column title will be qualified with the language description.
		-->
		<attribute name="language" value="null"/>
		<!---
			@keywords private
			Indicates whether to use language id while finding the model object for the given object path. This attribute is used only
			when there is a value for the language attribute. The default for this attribute is false.
		-->
		<attribute name="useLanguageSelector" type="boolean" value="false"/>
		<!---
			Indicates that the column filter is enabled. The list of possible filter values is created automatically based on the current values
			that are displayed in the column cells. If the column filter is enabled, a column filter button will be created
			for this column and placed in the bottom right hand corner of the column header.

			The default value for this attribute is "false".
		-->
		<attribute name="enableFilter" type="boolean" value="false"/>
		<!---
			@keywords private
			The text used to truncate the column header when the width of a column is smaller than the header text.
			The default string used is retrieved from a {@link wcfResourceBundle} class.
		-->
		<attribute name="truncationText" value="${foundationResources.gridTruncationText.string}" type="string"/>
		<!---
			@keywords private
			A boolean variable which indicates whether or not the header text currently is truncated.
		 -->
		<attribute name="truncated" value="${title.txtView.txt.getTextWidth() &gt; title.txtView.txt.width}" type="boolean"/>
		<!---
			@keywords private
			This attribute specifies the name of the class used that defines the context menu when you right click
			on the column header.
			The default value is {@link wcfGridColumnMenu}.
		-->
		<attribute name="columnHeaderMenuClass" type="string" value="wcfGridColumnMenu"/>
		<!---
			@keywords private
		-->
		<attribute name="cellDescriptorMap" value="null"/>
		<!---
			@keywords private
			The position of this column in the parent list of columns.
		-->
		<attribute name="savedColumnPos" type="number"/>
		<!---
			@keywords private
			The visible state of this column when it was disabled.
		-->
		<attribute name="savedVisible" type="boolean"/>
		<!---
			@keywords private
			Indicates that the column displays text with the HTML tags removed. The default value is false.
		-->
		<attribute name="tagsRemoved" value="false" type="boolean"/>
		<!---
			A comma separated string of {@link wcfValidator#validatorType} values.
			When there is a validator error in the cell object
			this column will check which {@link wcfValidator} it was created by.
			The error will be displayed in this column
			if the error is created by a validator whose {@link wcfValidator#validatorType} appears in the list.
		-->
		<attribute name="validatorTypes" type="string" value=""/>

		<!---
			The column filter. The filters will only appear on the column (and update) if enableFilter is set to true.
		-->
		<wcfGridColumnFilter name="columnFilter" column="${classroot}"/>

		<!--- @keywords private
			  Initialization method for the class.
		-->
		<method name="init">
			<![CDATA[
				super.init();
				if (!this["definitionNode"]) {
					this.postCreateDefinitionChildren();
				}
			]]>
		</method>

		<!--- @keywords private -->
		<method name="postCreateDefinitionChildren">
			<![CDATA[
			if (this.required && !this.visible) {
				this.setAttribute("visible", true);
			}
			if (this.draggable) {
				this.startDragDel = new lz.Delegate(this, "startDrag", this.title, "onmousedown");
				this.stopDragDel = new lz.Delegate(this, "stopDrag", this.title, "onmouseup");
				this.trackMouseDel = new lz.Delegate(this, "trackMouse");
			}
			var columns = parent["columns"];
			if (!columns) {
				columns = [];
				parent.columns = columns;
			}
			columns.push(this);
			this.updateVisibility();
			
			if (this["columnHeaderMenuClass"]) {
				new lz[this.columnHeaderMenuClass](this, {
					name: "menu",
					column: this
				});
				this.menu.addView(this);
			}
			this.updateResourceDel = new lz.Delegate(this, "updateResource");
			this.updateResourceDel.register(this.parent, "onactivated");

			if (this.languageSensitive) {
				this.updateLanguageSensitiveColumn();
				this.useLanguageSelector = true;
			}
			this.updateDisplayText();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="updateLanguageSensitiveColumn" args="e=null">
			<![CDATA[
			if (!this["updateLanguageSensitiveColumnDel"]) {
				this.updateLanguageSensitiveColumnDel = new lz.Delegate(this, "updateLanguageSensitiveColumn");
			}
			this.updateLanguageSensitiveColumnDel.unregisterAll();
			if (typeof(this["oView"]) == "undefined") {
				this.oView = wcfModelUtil.findObjectView(this);
			}
			var storeConfig = null;
			if(this.oView) {
				this.updateLanguageSensitiveColumnDel.register(this.oView, "ono");
				var o = this.oView.o;
				if (o != null) {
					storeConfig = wcfContextUtil.findStoreConfig(o, this.updateLanguageSensitiveColumnDel);
				}
			}
			else {
				storeConfig = wcfContextUtil.findStoreConfig(this.parent.model.oEditor, this.updateLanguageSensitiveColumnDel);
			}
			if(storeConfig != null){
				this.setAttribute("language", storeConfig.defaultLanguage);
			}
			]]>
		</method>

		<!--- @keywords private -->
		<method name="setPropertyName" args="newPropertyName">
			<![CDATA[
			this.propertyName = newPropertyName;
			this.getCellDescriptorMap().setDefaultPropertyName(this.propertyName);
			]]>
		</method>

		<!--- @keywords private -->
		<method name="setObjectPath" args="newObjectPath">
			<![CDATA[
			this.objectPath = newObjectPath;
			this.getCellDescriptorMap().setDefaultObjectPath(this.objectPath);
			]]>
		</method>

		<!--- @keywords private -->
		<method name="getCellDescriptorMap">
			<![CDATA[
			if (this.cellDescriptorMap == null) {
				this.cellDescriptorMap = new lz.wcfGridCellDescriptorMap(this);
				new lz.wcfGridCellDescriptor(this, {_default: true, objectType: null, objectPath: this["objectPath"], propertyName: this["propertyName"]});
			}
			return this.cellDescriptorMap;
			]]>
		</method>

		<!--- @keywords private -->
		<method name="getObjectPath" args="object,cellDescriptor">
			<![CDATA[
			var objectPath = null;
			var childObjectDefinition = null;
			var model = wcfModelUtil.findModelForView(this);
			if (cellDescriptor.objectPath) {
				childObjectDefinition = model.getObjectDefinition(object, cellDescriptor.objectPath);
			}

			if (childObjectDefinition != null && childObjectDefinition.languageSensitive) {
				if (this.language != null && this.useLanguageSelector) {
					objectPath = cellDescriptor.objectPath + "[languageId=" + this.language.languageId + "]";
				}
				else {
					var storeConfig = wcfContextUtil.findStoreConfig(object);
					if (storeConfig != null && storeConfig.defaultLanguage != null) {
						var defaultLanguage = storeConfig.defaultLanguage;
						objectPath = cellDescriptor.objectPath + "[languageId=" + defaultLanguage.languageId + "]";
					}
				}
			}
			else {
				objectPath = cellDescriptor.objectPath;
			}
			return objectPath;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="isMultipleMatch" args="object,delegate=null">
			<![CDATA[
			var multipleMatch = false;
			if (!this.pooled) {
				var cellDescriptor = null;
				var cellDescriptors = this.getCellDescriptorMap().getCellDescriptors(object, delegate);
				for (var i = 0; i < cellDescriptors.length; i++) {
					var objects = object.getObjects(this.getObjectPath(object, cellDescriptors[i]), null, null, true);
					if (objects.length > 1) {
						cellDescriptor = null;
						multipleMatch = true;
						break;
					}
					if (!multipleMatch && objects.length == 1) {
						if (cellDescriptor) {
							cellDescriptor = null;
							multipleMatch = true;
							break;
						}
						else {
							cellDescriptor = cellDescriptors[i];
						}
					}
				}
			}
			return multipleMatch;
			]]>
		</method>

		<!--- @keywords private -->
		<method name="getCellDescriptor" args="object,delegate=null">
			<![CDATA[
			var cellDescriptor = null;
			if (!this.pooled) {
				var multipleMatch = false;
				var cellDescriptors = this.getCellDescriptorMap().getCellDescriptors(object, delegate);
				for (var i = 0; i < cellDescriptors.length; i++) {
					var objects = object.getObjects(this.getObjectPath(object, cellDescriptors[i]), (this.implicitCreate && cellDescriptors.length == 1 ? null : delegate), null, true);
					if (objects.length > 1) {
						cellDescriptor = null;
						multipleMatch = true;
					}
					if (!multipleMatch && objects.length == 1) {
						if (cellDescriptor) {
							cellDescriptor = null;
							multipleMatch = true;
						}
						else {
							cellDescriptor = cellDescriptors[i];
						}
					}
				}
				if (cellDescriptor == null && !multipleMatch && cellDescriptors.length == 1 && this.implicitCreate) {
					cellDescriptor = cellDescriptors[0];
				}
			}
			return cellDescriptor;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getObject" args="object,updateObjectDel=null">
			<![CDATA[
			if (this.pooled) {
				return null;
			}

			var cellDescriptor = this.getCellDescriptor(object, updateObjectDel);
			if (cellDescriptor != null && !cellDescriptor.disabled) {
				return object.getObject(this.getObjectPath(object, cellDescriptor), true);
			}
			else {
				if (updateObjectDel != null && cellDescriptor != null) {
					updateObjectDel.register(cellDescriptor, "ondisabled");
				}
				return null;
			}
			]]>
		</method>

		<!--- @keywords private -->
		<method name="getPropertyName" args="object,delegate=null">
			<![CDATA[
			if (this.pooled) {
				return "";
			}

			var cellDescriptor = this.getCellDescriptor(object,delegate);
			if (cellDescriptor != null) {
				return cellDescriptor.propertyName;
			}
			else {
				return "";
			}
			]]>
		</method>

		<!--- @keywords private -->
		<method name="getColumnEditorClass" args="selectedObjects">
			<![CDATA[
			return this.columnEditorClass;
			]]>
		</method>
		
		<!---
			@keywords private
			This method will return true only if all of the following conditions are met:
			<ul>
				<li>The column is defined as editable</li>
				<li>A cellEditorClass is defined for the column; alternatively, a cellEditorClass not defined but 
					the cellEditorClass of the cell descriptor of this column is defined and editable</li>
				<li>The resolved property of the row object passed into the method exists</li>
				<li>The resolved property of the row object passed into the method is not readOnly</li>
			</ul>
			@param wcfModelObject object Row object
			@return boolean The method returns true if the cell is editable, false if it is not.
		-->
		<method name="isEditable" args="object">
			<![CDATA[
			var isEditable = false;
			if (object != null && object.objectDefinition != null) {
				var o = this.getObject(object);
				if (o != null) {
					var propertyName = this.getPropertyName(object);
					var property = null;
					if (propertyName) {
						property = o.getProperty(propertyName);
					}
					isEditable = this.editable
							&& property
							&& !property.readOnly;
					if (isEditable) {
						var cellDescriptor = this.getCellDescriptor(object);
						if (this.cellEditorClass == null) {
							isEditable = false;
							if (cellDescriptor != null && cellDescriptor.cellEditorClass != null && cellDescriptor.editable) {
								isEditable = true;
							}
						}
						else {
							if (cellDescriptor != null && !cellDescriptor.editable) {
								isEditable = false;
							}
						}
					}
				}
			}
			return isEditable;
			]]>
		</method>

		<!--- @keywords private -->
		<method name="isDisabled" args="object, delegate=null">
			<![CDATA[
			if (this.pooled) {
				return true;
			}

			var cellDescriptor = this.getCellDescriptor(object,delegate);
			return cellDescriptor != null && cellDescriptor.disabled;
			]]>
		</method>

		<!--- @keywords private
			  The destroy method for wcfGridColumn.
		-->
		<method name="destroy">
			<![CDATA[
			if (this["updateVisibilityDel"]) {
				this.updateVisibilityDel.unregisterAll();
				delete this.updateVisibilityDel;
			}
			if (this["startDragDel"]) {
				this.startDragDel.unregisterAll();
				delete this.startDragDel;
			}
			if (this["stopDragDel"]) {
			this.stopDragDel.unregisterAll();
			delete this.stopDragDel;
			}
			if (this["trackMouseDel"]) {
				this.trackMouseDel.unregisterAll();
				delete this.trackMouseDel;
			}
			var columns = parent["columns"];
			if (columns) {
				for (var i=0; i < columns.length; i++) {
					if (columns[i] == this) {
						columns.splice(i, 1);
						break;
					}
				}
			}
			this.updateResourceDel.unregisterAll();
			delete this.updateResourceDel;
			if (this["updateDisplayTextDel"]) {
				this.updateDisplayTextDel.unregisterAll();
				delete this.updateDisplayTextDel;
			}
			if (this["updateLanguageSensitiveColumnDel"]) {
				this.updateLanguageSensitiveColumnDel.unregisterAll();
				delete this.updateLanguageSensitiveColumnDel;
			}
			super.destroy();
			]]>
		</method>

		<!---
			@keywords private
			This method will update the background's resource when the parent view containing the column becomes active
			or inactive.
		-->
		<method name="updateResource" args="e=null">
			<![CDATA[
			if(this.parent.activated) {
				this.background.setAttribute('frame', 3);
			}
			else {
				this.background.setAttribute('frame', 1);
			}
			]]>
		</method>

		<!---
			@keywords private

			This method is used for performing filtering and sorting on the columns.

			@param wcfModelObject o The model object.
			@return string The displayed value for the property of the model object.
		-->
		<method name="getColumnFilterDisplayValue" args="o">
			<![CDATA[
			var displayValue = null;
			var cellDescriptor = this.getCellDescriptor(o);
			if (cellDescriptor) {
				if (cellDescriptor["getColumnFilterDisplayValue"]) {
					displayValue = cellDescriptor.getColumnFilterDisplayValue(o);
				}
				else if (cellDescriptor.propertyName) {
					var property = o.getProperty(cellDescriptor.propertyName, cellDescriptor.objectPath);
					displayValue = property.value;
					if (property.propertyDefinition != null) {
						var propertyValues = property.propertyDefinition.getPropertyValues(property.o)
						for (var i = 0; i < propertyValues.length; i++) {
							var propertyValue = propertyValues[i];
							if (propertyValue.value == property.value) {
								displayValue = propertyValue.displayName;
							}
						}
					}
				}
			}
			return displayValue;
			]]>
		</method>
		
		<!---
			@keywords private
			Register a delegate to be executed when the resolved value changes
			for the specified model object.
			@param wcfModelObject o: the model object
			@param lz.Delegate del: the delegate
		-->
		<method name="registerDelegate" args="o, del">
			<![CDATA[
			var cellDescriptor = this.getCellDescriptor(o,del);
			if (cellDescriptor && cellDescriptor.propertyName) {
				var property = o.getProperty(cellDescriptor.propertyName, cellDescriptor.objectPath);
				if (property) {
					del.register(property, "onvalue");
				}
			}
			]]>
		</method>

		<!---
			@keywords private

			This method checks that the specified object matches the filter object. It is invoked by {@link wcfGridColumnFilter}.
			@param wcfModelObject o The object to test
			@param String displayValue The display value to be compared against
		-->
		<method name="matchesFilter" args="o, displayValue">
			<![CDATA[
			return this.getColumnFilterDisplayValue(o) == displayValue;
			]]>
		</method>

		<!---
			This method creates an instance of a cell viewer specified in the cellViewer property to display the
			object's property in the grid. This method will be called automatically by the grid column.
			The following parameters are passed to the constructor:
			<ul>
				<li>property: {@link wcfModelProperty}
				<li>o: {@link wcfModelObject}
				<li>name: "viewer"
			</ul>

			@param view parent The parent view.
			@param wcfModelProperty property The model object property instance that this cell will display.
			@param wcfModelObject o The model object instance this cell represents.
			@return view: The newly created instance of cellViewerClass. If there is no cellViewerClass defined, this method will return null.
		-->
		<method name="createViewer" args="parent, property, o">
			<![CDATA[
			var viewer = null;
			var cellDescriptor = this.getCellDescriptor(parent.row.o);
			if (cellDescriptor == null) {
				cellDescriptor = this.getCellDescriptorMap()._defaultCellDescriptor;
			}
			return cellDescriptor.createViewer(parent, property, o);
			]]>
		</method>

		<!---
			@keywords private
			Override this method to return additional initialization arguments for that will be used to create the viewer.
			@return object additional initialization arguments
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return null;
			]]>
		</method>

		<!---
			This method creates an instance of an editor specified in the cellEditor property to edit the
			object's property in the grid.  This method will be called automatically by the grid column.

			The following parameters are passed to the cellEditorClass:
			<ul>
				<li>property: {@link wcfModelProperty}
				<li>name: "editor"
			</ul>
			If the grid cell already has an editor, this method will unhide the editor and set its
			property atttribute.

			@param view parent The parent view.
			@param wcfModelProperty property The model object property instance that this cell will edit.
			@param wcfModelProperty o The model object instance that this cell will edit.
			@return view: The newly created instance of cellEditorClass. If there is no cellEditorClass defined, this method returns null.
		-->
		<method name="createEditor" args="parent, property, o">
			<![CDATA[
			var editor = null;			
			var cellDescriptor = this.getCellDescriptor(parent.row.o);
			if(cellDescriptor != null && cellDescriptor.editable){
				editor = cellDescriptor.createEditor(parent, property, o);
			} else {
				this.releaseEditor(parent);
			}
			return editor;
			]]>
		</method>
		
		<!---
			@keywords private
			Override this method to return additional initialization arguments for that will be used to create the editor.
			@return object additional initialization arguments
		-->
		<method name="getEditorInitArgs">
			<![CDATA[
			return null;
			]]>
		</method>
		
		<!---
			@keywords private
			Override this method to return validation errors to be associated with this column for the specified object.
			@param wcfGridCell grid cell
			@param lz.Delegate optional delegate
			@return array array of validation errors
		-->
		<method name="getValidationErrors" args="cell,del=null">
			<![CDATA[
			var validationErrors = null;
			var object = cell.row.o;
			if (object != null && object.objectDefinition != null) {
				var cellDescriptor = this.getCellDescriptor(object);
				if (cellDescriptor != null) {
					validationErrors = cellDescriptor.getValidationErrors(cell,del);
				}
			}
			return validationErrors;
			]]>
		</method>
		
		<!---
			@keywords private
			This method is called by find and replace when it finds the searched for text in a cell in this column
			to apply the visual treatment to said cell. 
			This method must be implemented by those wcfGridColumns who have their {@link wcfGridColumn#findable}
			flag set to true. 
			@param cell wcfGridCell The cell that contains the match.
			@param number index The index of the match in the cell.
			@param number length The length of the match in the cell. 
		-->
		<method name="highlightWordInCell" args="cell,index,length">
			<![CDATA[
			]]>
		</method>
		
		<!---
			@keywords private
			This method is called by find and replace when it wants to undo the visual treatment it did for find and 
			replace.
			This method must be implemented by those wcfGridColumns who have their {@link wcfGridColumn#findable}
			flag set to true. 
			@param cell wcfGridCell The cell to remove the formatting from.			
		-->
		<method name="unhighlightCell" args="cell">
			<![CDATA[
			]]>
		</method>
		
		<!---
			@keywords private
			This method releases the editor instance associated with a grid cell by hiding the editor
			and unsetting its property attribute.
			@param view parent The parent view.
		-->
		<method name="releaseEditor" args="parent">
			<![CDATA[
			if (parent["editor"] && parent.editor.visible) {
				parent.editor.setAttribute("visible", false);
				parent.editor.setAttribute("o", null);
				parent.editor.setAttribute("property", null);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method releases the viewer instance associated with a grid cell by hiding the viewer
			and unsetting its property and object attributes.
			@param view parent The parent view.
		-->
		<method name="releaseViewer" args="parent">
			<![CDATA[
			if (parent["viewer"] && parent.viewer.visible) {
				parent.viewer.setAttribute("o", null);
				parent.viewer.setAttribute("property", null);
				parent.viewer.setAttribute("visible", false);
			}
			]]>
		</method>

		<!---
			@keywords private
			This handler handles changes to the column's header text.
		-->
		<handler name="ontext">
			<![CDATA[
			this.updateDisplayText();
			]]>
		</handler>

		<!---
			@keywords private
			This handler handles changes to the column's header language.
		-->
		<handler name="onlanguage">
			<![CDATA[
			this.updateDisplayText();
			]]>
		</handler>

		<!---
			@keywords private
			This method update the column's header display text.
		-->
		<method name="updateDisplayText" args="e=null">
			<![CDATA[
			if (typeof(this["updateDisplayTextDel"] == "undefined")) {
				this.updateDisplayTextDel = new lz.Delegate(this, "updateDisplayText");
			} else {
				this.updateDisplayTextDel.unregisterAll();
			}
			if (this.language != null) {
				this.updateDisplayTextDel.register(this.language, "onlanguageDescription");
				this.setAttribute("displayText", this.text + " (" + this.language.languageDescription + ")");
			}
			else {
				this.setAttribute("displayText", this.text);
			}
			]]>
		</method>

		<!---
			@keywords private
		-->
		<handler name="onvisible" args="isVisible">
			<![CDATA[
			this.handleOnVisible(isVisible);
			]]>
		</handler>

		<!---
			@keywords private

			This handler is invoked when the column's visibility changes. Column visibility is changed when the user decides
			to hide or display a column.

			@param boolean isVisible When true, this column will be set to visible. If it is false, the column will be made invisible.
		-->
		<method name="handleOnVisible" args="isVisible">
			<![CDATA[
			if (isVisible) {
				if (this["restoreWidth"]) {
					this.setAttribute('width', this.restoreWidth);
					delete this.restoreWidth;
				}
				this.parent.refresh();
			}
			else {
				if (this.width > 0) {
					this.restoreWidth = this.width;
					this.setAttribute('width', 0);
					if (wcfViewUtil.containsView(this, lz.Focus.getFocus())) {	
						this.parent.restoreFocus();
					}
				}
			}
			]]>
		</method>

		<!---
			@keywords private
		-->
		<method name="updateVisibility" args="e=null">
			<![CDATA[
			if(this["enablementCondition"]){
				if (typeof(this.updateVisibilityDel) == "undefined") {
					this.updateVisibilityDel = new lz.Delegate(this, "updateVisibility");
				}
				this.updateVisibilityDel.unregisterAll();
				
				if (typeof(this["oView"]) == "undefined") {
					this.oView = wcfModelUtil.findObjectView(this);
				}
				var o = null;				
				if(this.oView) {
					this.updateVisibilityDel.register(this.oView, "ono");
					o = this.oView.o;
				}
				this.enablementCondition.registerDelegate(o, this.updateVisibilityDel);
				if(!this.enablementCondition.isEnabled(o)) {
					if(!this.pooled){
						this.savedColumnPos = parent.columns.indexOf(this);
						this.savedVisible = this.visible;
						parent.disabledColumns.push(this);
						parent.releaseColumn(this);
						parent.refresh();
					}
				}
				else {
					if(this.pooled) {
						for (var i=0; i<parent.disabledColumns.length; i++) {
							if (parent.disabledColumns[i] == this) {
								parent.disabledColumns.splice(i, 1);
								break;
							}
						}
						parent.addColumn(this, this.savedVisible);
						parent.setColumnPosition(this, this.savedColumnPos , true);
						parent.refresh();
					}
				}
			}
			]]>
		</method>

		<!---
			@keywords private

			Handler for changes to the column width.
			@param number newWidth The new width for the column. The value will be ignored if it is less than or equal to zero.
		-->
		<handler name="onwidth" args="newWidth">
			<![CDATA[
			if (!this.visible && newWidth > 0) {
				this.restoreWidth = newWidth;
				this.setAttribute('width', 0);
			}
			]]>
		</handler>

		<!---
			@keywords private
			This method is called when a column is being dragged.
		-->
		<method name="startDrag" args="e=null">
			this.startDragX = this.getMouse('x');
			this.trackMouseDel.register(lz.Idle, "onidle");
		</method>

		<!---
			@keywords private
			This method is called when a column is stopped being dragged.
		-->
		<method name="stopDrag" args="e=null">
			this.trackMouseDel.unregisterAll();
			this.dragging = false;
			wcfGridColumnDragger.stopDrag(this);
		</method>

		<!---
			@keywords private
			This method tracks the mouse movements while a column is being dragged.
		-->
		<method name="trackMouse" args="e=null">
			<![CDATA[
			if (!this.dragging && this.startDragX != this.getMouse('x')) {
				this.dragging = true;
				wcfGridColumnDragger.startDrag(this);
			}else{
				wcfGridColumnDragger.whileDrag();
			}
			]]>
		</method>

		<!---
			@keywords private

			This method is called in order to sort by the columns' values. It will have no affect if the column is not sortable.
		-->
		<method name="doSort">
			<![CDATA[
			if (this.sortable) {
				var oList = wcfModelUtil.findObjectListForView(this);
				oList.doSort(this);
				this.setAttribute("sortAscending", oList.sortAscending);
			}
			]]>
		</method>

		<!---
			@keywords private
			This method returns the sort compare value for the given object. String compare values are returned in lowercase.

			@param wcfModelObject o The {@link wcfModelObject} that contains the property that is being sorted.
			@return string/Number The value of the property of this object to be compared for sorting purposes.
								  This will be a Number if the datatype of the column is defined as "number", and a
								  string otherwise.
		-->
		<method name="getCompareValue" args="o">
			<![CDATA[
			var value = null;
			var cellDescriptor = this.getCellDescriptor(o);
			if (cellDescriptor && cellDescriptor["getCompareValue"]) {
				value = cellDescriptor.getCompareValue(o);
			}
			else {
				var datatype = this.datatype;
				if (cellDescriptor && cellDescriptor.datatype != null) {
					datatype = cellDescriptor.datatype;
				}
	
				if (datatype == "number") {
					value = o.getPropertyValue(cellDescriptor.propertyName, cellDescriptor.objectPath);
					value = Number(value);
					if (isNaN(value)) {
						value = null;
					}
				}
				else {
					value = this.getColumnFilterDisplayValue(o);
					if (value == null || value == "") {
						value = " ";
					}else {
						value = value.toLowerCase();
					}
				}
			}
			return value;
			]]>
		</method>


		<!---
			@keywords private
			The compare function used to sort the grid.

			@param wcfModelObject o1 The first model object to compare.
			@param wcfModelObject o2 The second model object to compare.
			@param boolean sortAscending A boolean indicator of whether the required sort is into ascending order.
			@return number If sortAscending is true, this method will return 1 when the value of o1 is greater than
					       the value of o2 and -1 otherwise. If sortAscending is false, the comparison will return 1 if
					       the value of o1 is less than the value of o2 and -1 otherwise. If the value of o1 is equal to the
					       value of o2, this method will return 0.
		-->
		<method name="compare" args="o1,o2, sortAscending">
			<![CDATA[
			var result = 0;

			var v1 = null;
			if (o1["_compareValue"] != null) {
				v1 = o1["_compareValue"];
			}
			else {
				v1 = this.getCompareValue(o1);
				o1["_compareValue"] = v1;
			}

			var v2 = null;
			if (o2["_compareValue"] != null) {
				v2 = o2["_compareValue"];
			}
			else {
				v2 = this.getCompareValue(o2);
				o2["_compareValue"] = v2;
			}

			if (v1 > v2) {
				result = sortAscending ? 1 : -1;
			}
			else if (v1 < v2) {
				result = sortAscending ? -1 : 1;
			}
			return result;
			]]>
		</method>

		<!---
			@keywords private

			This method will clone the column for each selected language if this is a language-sensitive column.
			This method creates an instance of {@link wcfGridColumnClone} for each language selected.
		-->
		<method name="updateLanguageColumns">
			<![CDATA[
			if (this.languageSensitive) {
				while (this.languageColumns.length > 0) {
					var languageColumn = this.languageColumns.shift();
					languageColumn.setAttribute("language", null);
					this.parent.releaseColumn(languageColumn);
					this.languageColumnsPool.push(languageColumn);
				}
				var context = null;
				if(this.parent.oView) {
					var o = this.parent.oView.o;
					if (o != null) {
						context = wcfContextUtil.findContext(o);
					}
				}
				else {
					context = wcfContextUtil.findContext(this.parent.model.oEditor);
				}
				var inputLanguages = [];
				if (context != null && context.storeConfig != null) {
					inputLanguages = context.storeConfig.getLanguagesById(context.getContextValue("inputLanguageIds").value);
				}
				var columnPos = parent.columns.indexOf(this);
				for (var i = 1; i < inputLanguages.length; i++) {

					var languageColumn = null;
					if (this.languageColumnsPool.length > 0) {
						languageColumn = this.languageColumnsPool.pop();
						languageColumn.setAttribute("language", inputLanguages[i]);
						languageColumn.setAttribute('width', this.width);
						this.parent.addColumn(languageColumn, this.visible);
					}
					else {
						languageColumn = new lz.wcfGridColumnClone(this.parent, {
							originalColumn: this,
							language: inputLanguages[i],
							width: this.width,
							visible: this.visible
						});
					}

					this.languageColumns.push(languageColumn);
					parent.setColumnPosition(languageColumn, columnPos + this.languageColumns.length, false);
				}
			}
			]]>
		</method>
		
		<!---
			This method returns the value to be displayed in the cell.
			
			@param wcfModelObject o The model object instance this cell represents.
			@param wcfModelProperty property The model object property instance that this cell will display.
			@return string The value to be displayed by the cell.
		-->
		<method name="getCellText" args="o,property">
			<![CDATA[
			return property.value;
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method name="getAlignment" args="o, delegate=null">
			<![CDATA[
			var alignment = this.alignment;
			if (o != null && o.objectDefinition != null) {
				var cellDescriptor = this.getCellDescriptor(o, delegate);
				if (cellDescriptor) {
					alignment = cellDescriptor.alignment;
				}
			}
			return alignment;
			]]>
		</method>

		<!---
			Scroll horizontally to ensure that this column is visible.
		-->
		<method name="show">
			<![CDATA[
			var borderView = this.parent.borderView;
			var left = -borderView.clippedContent.gridContent.x;
			var right = left + borderView.clippedContent.width;
			var scroll = 0;
			var rx = this.x;
			if (rx < left) {
				scroll = rx - left;
			}
			else if (rx + this.width > right) {
				scroll = rx + this.width - right;
			}
			if (scroll != 0) {
				borderView.horizontalScroll.setPosRelative(scroll);
			}
			]]>
		</method>		
		
		<view name="background" width="${parent.width - parent.resizer.divider.width}" height="${parent.height}" resource="listHeaderBackground" stretches="both"/>
		
		<view name="title"
				clip="true"
				focusable="${parent.visible}"
				onclick="parent.doSort()"
				width="${parent.width - parent.resizer.width - classroot.parent.listBorderSize}"
				height="21">
			<view width="${parent.width - (classroot.enableFilter ? parent.filterButton.width : 0 ) - 4}"
			   height="${parent.height}" clip="true" name="txtView">
				<wcfCenterLayout/>
				<simplelayout axis="x"/>
				<view name="leftPadding" x="${parent.x}" height="${parent.height}" width="4" />
				<text name="requiredText" visible="${classroot.titleVisible &amp;&amp; classroot.required}" text="*" fgcolor="${classroot.style.gridheadertextcolor}" resize="true"/>
				<text name="txt" visible="${classroot.titleVisible}" width="${parent.width - (parent.requiredText.visible ? parent.requiredText.width : 0) - (classroot.truncated ? parent.truncationText.width : parent.leftPadding.width)}" text="${classroot.displayText}" fgcolor="${classroot.style.gridheadertextcolor}" resize="true"/>
				<text name="truncationText" text="${classroot.truncationText}" visible="${classroot.truncated}" x="${parent.x + parent.width - this.width}" width="${this.getTextWidth() + parent.leftPadding.width}" xoffset="3"/>
			</view>
			<wcfColumnFilterButton name="filterButton" visible="${classroot.enableFilter}" column="${classroot}" align="right">
				<handler name="onfocus">
					<![CDATA[
					classroot.show();
					]]>
				</handler>
			</wcfColumnFilterButton>

			<!--- keywords private -->
			<handler name="onmouseover">
				<![CDATA[
				parent.background.setAttribute('frame', 2);
				]]>
			</handler>

			<handler name="onmouseout">
				<![CDATA[
				if(classroot.parent.activated) {
					parent.background.setAttribute('frame', 3);
				}
				else {
					parent.background.setAttribute('frame', 1);
				}
				]]>
			</handler>
			
			<!--- @keywords private -->
			<handler name="onfocus">
				<![CDATA[
				classroot.parent.model.setAttribute("activeSelectionView", classroot.parent);
				classroot.show();
				if (this.parent["menu"]) {
					wcfContextMenuUtil.setAsDefault(this.parent.menu);
				}
				if(!parent["indicator"]){
			    	new lz.wcfFocusIndicator(parent, {
				    	name: "indicator",
				    	focusableView: this,
				    	indicatorView: parent.background
				    });
			    }
				]]>
			</handler>
			
			<!--- @keywords private -->
			<handler name="onblur">
				<![CDATA[
				if (this.parent["menu"]) {
					wcfContextMenuUtil.resetDefault(this.parent.menu);
				}
				]]>
			</handler>

			<!---
				@keywords private

				Handle key down events.
			-->
			<handler name="onkeydown" args="code">
				<![CDATA[

				// sort the column when space is pressed
				if (code == 32) { // space
					parent.doSort();

				// open filter list when down key is pressed
				} else if (code == 40) {
					if (classroot.enableFilter) {
						this.filterButton.openList();
					}
				}
				]]>
			</handler>
		</view>

		<view name="resizer"
				x="${parent.title.width}"
				y="${parent.title.y}"
				clickable="true"
				width="3">
			<!---
				Indicates that the resizer is currently being dragged.
			-->
			<attribute name="resizing" type="boolean" value="false"/>
			<!---
				Indicates that the mouse is hovering over the resizer.
			-->
			<attribute name="hover" type="boolean" value="false"/>
			<!---
				The selected color for the resizer
			-->
			<attribute name="selectedColor" type="color" value="${classroot.parent.headerSelectedColor}"/>

			<handler name="onmouseover">
				<![CDATA[
				this.hover = true;
				lz.Cursor.setCursorGlobal("horizontalResizeCursor");
				]]>
			</handler>

			<handler name="onmouseout">
				<![CDATA[
				this.hover = false;
				lz.Cursor.restoreCursor();
				]]>
			</handler>

			<handler name="onmousedown">
				<![CDATA[
				if(classroot.parent.panel){
					classroot.parent.panel.lockAvailableCalcs();
				}
				this.setAttribute("resizing", true);
				lz.Cursor.lock();
				parent.rs.setAttribute('applied', true);
				]]>
			</handler>

			<handler name="onmouseup">
				<![CDATA[
				this.setAttribute("resizing", false);
				lz.Cursor.unlock();
				if (this.hover) {
					lz.Cursor.setCursorGlobal("horizontalResizeCursor");
				}
				else {
					lz.Cursor.restoreCursor();
				}
				parent.rs.setAttribute('applied', false);
				classroot.parent.savePreferences();
				if(classroot.parent.panel){
					classroot.parent.panel.unlockAvailableCalcs();
				}
				]]>
			</handler>
			<view x="2" name="divider" resource="listHeaderDivider" frame="1"/>
		</view>

		<state name="rs">
			<attribute name="xroffset" value="$once{this.x - this.width + this.getMouse('x')}"/>
			<attribute name="width" value="${Math.max(minwidth, this.immediateparent.getMouse('x')-xroffset)}"/>
		</state>
		
	</class>

	<!---
		@keywords private
		@keywords final

		This class represents a cloned grid column created for columns that support multiple languages. Instances of this class
		are created by the method {@link wcfGridColumn#updateLanguageColumns()}.

		Many of the attributes of the cloned grid column are constrained to the original grid column.
	-->
	<class name="wcfGridColumnClone" extends="wcfGridColumn">
		<!---
			A reference to the original column. This is a required attribute.
		-->
		<attribute name="originalColumn"/>
		<!---
			Indicates that this column can be sorted. The default is "true". This is constrained to the value of the original
			grid column.
		-->
		<attribute name="sortable" value="${originalColumn.sortable}"/>
		<!---
			Indicates that this is a required column. Required columns cannot be hidden. This is constrained to the value of
			the original grid column.
		-->
		<attribute name="required" value="${originalColumn.required}"/>
		<!---
			@keywords private
			Indicates that find and replace can be performed on this column. The default value for this attribute is "false". This is 
			constrained to the value of the original grid column.
		-->
		<attribute name="findable" type="boolean" value="${originalColumn.findable}"/>
		<!---
			Indicates whether to use language id while finding the model object for the given object path. This is constrained to the
			value of the original grid column.
		-->
		<attribute name="useLanguageSelector" type="boolean" value="${originalColumn.useLanguageSelector}"/>
		<!---
			Column data type. Valid data types are "string", "datetime" and "number". The default is "string". This is constrained
			to the value of the original grid column.
		-->
		<attribute name="datatype" value="${originalColumn.datatype}"/>
		<!---
			Indicates that this column supports edit in place. This is constrained to the value of the original grid column.
		-->
		<attribute name="editable" value="${originalColumn.editable}"/>
		<!---
			The minimum width for this column.
		-->
		<attribute name="minwidth" value="${originalColumn.minwidth}"/>
		<!---
			Display text for this column. This is constrained to the value of the original grid column.
		-->
		<attribute name="text" value="${originalColumn.text}"/>
		<!---
			Indicates that the title is visible. This is constrained to the value of the original grid column.
		-->
		<attribute name="titleVisible" value="${originalColumn.titleVisible}"/>
		<!---
			Alignment for this column. Valid values are "left", "center" and "right".
			The default is "left". This is constrained to the value of the original grid column.
		-->
		<attribute name="alignment" value="${originalColumn.alignment}"/>
		<!---
			Indicates that the column filter is enabled. This is constrained to the value of the original grid column.
		-->
		<attribute name="enableFilter" value="${originalColumn.enableFilter}"/>
		<!--- 
			This attribute specifies the name of the view class used to create the column editor for this column. 
			The column editor is used in the Edit Column dialog to update multiple cells in this column. Classes which 
			extend wcfGridColumn and allow column editing must provide this value. The class must be prepared to accept 
			two attributes: "column" and "selectedObjects". The "column" attribute is the wcfGridColumn instance. 
			The "selectedObjects" attribute is the array of {@link wcfModelObject model objects} that are currently 
			selected in the {@link wcfObjectGrid grid}. This is constrained to the value of the original grid column.
		 -->
		<attribute name="columnEditorClass" value="${originalColumn.columnEditorClass}"/>
		<!---
			A comma separated string of {@link wcfValidator#validatorType} values.
			When there is a validator error in the cell object
			this column will check which {@link wcfValidator} it was created by.
			The error will be displayed in this column
			if the error is created by a validator whose {@link wcfValidator#validatorType} appears in the list.
		-->
		<attribute name="validatorTypes" type="string" value="${originalColumn.validatorTypes}"/>

		<!---
			This method creates an instance of a cell viewer to display the object's property in the grid.
			It calls the createViewer method of the original grid column.

			@param view parent The parent view.
			@param wcfModelProperty property The model object property instance that this cell will display.
			@param wcfModelObject o The model object instance this cell represents.
			@return The newly created instance of cellViewerClass. If there is no cellViewerClass defined, this method will return null.
		-->
		<method name="createViewer" args="parent, property, obj">
			<![CDATA[
			return this.originalColumn.createViewer(parent, property, obj);
			]]>
		</method>

		<!---
			This method creates an instance of the cell editor so that the property can be edited in the grid.
			It calls the createEditor method of the original grid column.

			@param view parent The parent view.
			@param wcfModelProperty property The model object property instance that this cell will edit.
			@param wcfModelProperty o The model object instance that this cell will edit.
			@return The newly created instance of cellEditorClass. If there is no cellEditorClass defined, this method returns null.
		-->
		<method name="createEditor" args="parent, property, o">
			<![CDATA[
			return this.originalColumn.createEditor(parent, property, o);
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getCellDescriptorMap">
			<![CDATA[
			return this.originalColumn.getCellDescriptorMap();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getColumnEditorClass" args="selectedObjects">
			<![CDATA[
			return this.originalColumn.getColumnEditorClass(selectedObjects);
			]]>
		</method>
		
		<!---
			@keywords private
			This method calls the isEditable method of the original grid column.

			@param wcfModelObject object Row object.
			@return boolean The method returns true if the cell is editable, false if it is not.
		-->
		<method name="isEditable" args="object">
			<![CDATA[
			return this.originalColumn.isEditable(object);
			]]>
		</method>
		
		<!---
			@keywords private
			This method calls the getValidatoinErrors method of the original grid column.
			@param wcfGridCell grid cell
			@param lz.Delegate optional delegate
			@return array array of validation errors
		-->
		<method name="getValidationErrors" args="cell,del=null">
			<![CDATA[
			return this.originalColumn.getValidationErrors(cell,del);
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="setPropertyName" args="newPropertyName"/>

		<!--- @keywords private -->
		<method name="setObjectPath" args="newObjectPath"/>
		
		<!---
			This method returns the value to be displayed in the cell.
			
			@param wcfModelObject o The model object instance this cell represents.
			@param wcfModelProperty property The model object property instance that this cell will display.
			@return string The value to be displayed by the cell.
		-->
		<method name="getCellText" args="o,property">
			<![CDATA[
			return this.originalColumn.getCellText(o,property);
			]]>
		</method>
		
		<!---
			@keywords private

			This handler is invoked when the column's visibility changes. Column visibility is changed when the user decides
			to hide or display a column.

			@param boolean isVisible When true, this column will be set to visible. If it is false, the column will be made invisible.
		-->
		<method name="handleOnVisible" args="isVisible">
			<![CDATA[
			if (isVisible) {
				this.setAttribute('width', this.originalColumn["restoreWidth"] ? this.originalColumn.restoreWidth : this.originalColumn.width);
				this.parent.refresh();
			}
			else {
				this.setAttribute('width', 0);
			}
			]]>
		</method>
	</class>

	<!---
		@keywords private

		This class defines a map that stores wcfGridCellDescriptor objects for the grid.
	-->
	<class name="wcfGridCellDescriptorMap" extends="node">
		<!---
			@keywords private
			An array that contains wcfGridCellDescriptor types that resolves by objectType.
		-->
		<attribute name="_cellDescriptors" value="null"/>
		<!---
			@keywords private
			The default cell descriptor.
		-->
		<attribute name="_defaultCellDescriptor" value="null"/>

		<!---
			@keywords private
			The destructor method for this class.
		-->
		<method name="destroy">
			super.destroy();
			delete this._cellDescriptors;
		</method>

		<!---
			@keywords private
			This method will return the cellDescriptor for a given objectDefinition
			@param wcfModelObject object The row object whose cell descriptor is being sought.
			@param lz.Delegate delegate: the delegate
			@return wcfGridCellDescriptor The wcfGridCellDescriptor for the specified wcfObjectDefinition.
		-->
		<method name="getCellDescriptors" args="object, delegate=null">
			<![CDATA[
			var objectDefinition = object.objectDefinition;
			var cellDescriptors = [];

			if (this._cellDescriptors) {
				for (var i = 0; i < this._cellDescriptors.length; i++) {
					var descriptor = this._cellDescriptors[i];
					if ((descriptor.enablementCondition == null || descriptor.enablementCondition.isEnabled(object)) &&
						(!descriptor.objectType || (objectDefinition && objectDefinition.matchesType(descriptor.objectType)))) {
						cellDescriptors.push(this._cellDescriptors[i]);
					}
					if (delegate && descriptor.enablementCondition != null) {
						descriptor.enablementCondition.registerDelegate(object, delegate);
					}
				}
			}
			
			if (cellDescriptors.length == 0) {
				cellDescriptors.push(this._defaultCellDescriptor);
			}
			
			return cellDescriptors;
			]]>
		</method>

		<!--- @keywords private -->
		<method name="add" args="cellDescriptor">
			<![CDATA[
			if (!this._cellDescriptors) {
				this._cellDescriptors = [];
			}
			this._cellDescriptors.push(cellDescriptor);
			]]>
		</method>

		<!--- @keywords private -->
		<method name="setDefaultPropertyName" args="propertyName">
			<![CDATA[
			_defaultCellDescriptor.propertyName = propertyName;
			]]>
		</method>

		<!--- @keywords private -->
		<method name="setDefaultObjectPath" args="objectPath">
			<![CDATA[
			_defaultCellDescriptor.setAttribute('objectPath', objectPath);
			]]>
		</method>

		<!--- @keywords private -->
		<method name="setDefaultDisabled" args="disabled">
			<![CDATA[
			if (_defaultCellDescriptor.disabled !== disabled) {
				_defaultCellDescriptor.setAttribute("disabled", disabled);
			}
			]]>
		</method>
	</class>

	<!---
		Use this class to define alternate behaviors for grid cells found within the
		same grid column. Multiple instances of this class can be declared as children of an instance
		of {@link wcfGridColumn}. For example, in the case where you have a grid that displays a heterogenous list
		of object types, cell descriptors can be used to display a different property for each object type.
		<p>The following example demonstrates the declaration of a grid column that will display the "fullPath" property of the "ManagedFileGroup"
		child object if the row object's object type is "AttachmentAssetWithFileTypeGroup" and will display the "path" property if the row object's object type
		is "AttachmentAssetWithURLType".
		@START_CODE
		<GridText name="assetPath" text="${attachmentResources.attachmentAsset_path}"  editable="true" width="264" required="true">
			<GridCellDescriptor name="fileCell" objectType="AttachmentAssetWithFileTypeGroup" objectPath="ManagedFileGroup"  propertyName="fullPath"/>
			<GridCellDescriptor name="urlCell" objectType="AttachmentAssetWithURLType"  propertyName="path" />
		</GridText>
		@END_CODE
		<p>A single instance of {@link wcfEnablementCondition} can be declared as a child of a cell descriptor. If
		the enablement condition evaluates to false for a cell descriptor, then the cell descriptor will not be available.
		The enablement condition is evaluated against the row object.</p>
	-->
	<class name="wcfGridCellDescriptor" extends="node">
		<!---
			This attribute will be matched against the row object's object type and used to select the right cell descriptor.
			If no object type is specified, then all row object's will match this cell descriptor. If there are multiple
			cell descriptors with the same object type (or no object type), then the "objectPath" will be used to pick
			the right cell descriptor. If the row object has a child object that matches the specified "objectPath"
			then this cell descriptor will be selected. If no matches are found, then the cell will display the text
			specified by the {@link wcfGridColumn#multipleMatchText} attribute. If more than one matching object is found, then
			the cell will display the text specified by the {@link wcfGridColumn#noMatchText} attribute.
		-->
		<attribute name="objectType" type="string" value="${null}"/>
		<!---
			This attribute is used to specify the path from the row object to the object that contains the
			property specified by the "propertyName" attribute. Do not specify an object path if the property
			is in the row object.
		-->
		<attribute name="objectPath" type="string" value="${null}"/>
		<!---
			This attribute is used to specify the name of the property whose value will be displayed in the grid cell.
		-->
		<attribute name="propertyName" type="string" value="${null}"/>
		<!---
			Set this attribute to "true" if you want to disable this grid cell when
			this is the matching cell descriptor. A disabled grid cell will be blank and not editable.
		-->
		<attribute name="disabled" type="boolean" value="false"/>
		<!---
			The column's data type. Valid data types are "string", "datetime" and "number".
			The column's data type will affect what value is returned by the {@link wcfGridColumn#getCompareValue} method
			when it extracts the value to use for sorting.
		-->
		<attribute name="datatype" type="string" value="${null}"/>
		<!---
			Indicates that this column supports edit in place. The default value is "true."
		-->
		<attribute name="editable" type="boolean" value="true"/>
		
		<!---
			@keywords private
		-->
		<attribute name="_default" type="boolean" value="false"/>
		<!---
			@keywords private
			The enablement condition for this cell descriptor.
		-->
		<attribute name="enablementCondition" value="${null}"/>
		<!---
			@keywords private
			This attribute specifies the name of the view class used to create cell viewer instances for cells that match this
			cell descriptor.
			@type string
		-->
		<attribute name="cellViewerClass" type="string" value="${this.parent.cellViewerClass}"/>
		<!---
			@keywords private
			This attribute specifies the name of the view class used to create editor instances for cells that match this cell descriptor.
			@type string
		-->
		<attribute name="cellEditorClass" type="string" value="${this.parent.cellEditorClass}"/>
		<!---
			The alignment for this cell descriptor. Valid values are "left", "center" and "right".
		-->
		<attribute name="alignment" type="string" value="${this.parent.alignment}"/>

		<!---
			@keywords private
		-->
		<method name="init">
			<![CDATA[
			super.init();
			if (this._default) {
				this.parent.getCellDescriptorMap()._defaultCellDescriptor = this;
			}
			else {
				this.parent.getCellDescriptorMap().add(this);
			}
			]]>
		</method>
		
		<!---
			This method creates an instance of a cell viewer specified in the cellViewer property to display the
			object's property in the grid. This method will be called automatically by the grid column.
			The following parameters are passed to the constructor:
			<ul>
				<li>property: {@link wcfModelProperty}
				<li>o: {@link wcfModelObject}
			</ul>

			@param view parent The parent view.
			@param wcfModelProperty property The model object property instance that this cell will display.
			@param wcfModelObject o The model object instance this cell represents.
			@return view: The newly created instance of cellViewerClass. If there is no cellViewerClass defined, this method will return null.
		-->
		<method name="createViewer" args="parent, property, o">
			<![CDATA[
			var viewer = null;
			if(this.cellViewerClass != null) {
				var initArgs = this.getViewerInitArgs();
				if (parent[this.cellViewerClass]) {
					viewer = parent[this.cellViewerClass];
					if (initArgs != null) {
						for (var i in initArgs) {
							if (initArgs[i] != viewer[i]) {
								viewer.setAttribute(i, initArgs[i]);
							}
						}
					}
					if (o != viewer.o) {
						viewer.setAttribute("o", o);
					}
					if (property != viewer.property) {
						viewer.setAttribute("property", property);
					}
					if (!viewer.visible) {
						viewer.setAttribute("visible", true);
					}
				}
				else {
					var args = {
						name: this.cellViewerClass,
						property: property,
						o: o
					};
					if (initArgs != null) {
						for (var i in initArgs) {
							args[i] = initArgs[i];
						}
					}
					viewer = new lz[this.cellViewerClass](parent, args);
					if (parent["menu"]) {
						parent.menu.addView(viewer);
					}
					else if (parent.grid["menu"]) {
						parent.grid.menu.addView(viewer);
					}
				}
			}
			if (parent["viewer"] && parent.viewer != viewer && parent.viewer.visible) {
				parent.viewer.setAttribute("o", null);
				parent.viewer.setAttribute("property", null);
				parent.viewer.setAttribute("visible", false);
			}
			parent.viewer = viewer;
			return viewer;
			]]>
		</method>
		
		<!---
			@keywords private
			Override this method to return additional initialization arguments for that will be used to create the viewer.
			@return object additional initialization arguments
		-->
		<method name="getViewerInitArgs">
			<![CDATA[
			return this.parent.getViewerInitArgs();
			]]>
		</method>

		<!---
			@keywords private
			This method creates an instance of an editor specified in the cellEditor property to edit the
			object's property in the grid.  This method will be called automatically by the grid column.

			The following parameters are passed to the cellEditorClass:
			<ul>
				<li>property: {@link wcfModelProperty}
			</ul>
			If the grid cell already has an editor, this method will unhide the editor and set its
			property atttribute.

			@param view parent The parent view.
			@param wcfModelProperty property The model object property instance that this cell will edit.
			@param wcfModelProperty o The model object property instance that this cell will edit.
			@return view: The newly created instance of cellEditorClass. If there is no cellEditorClass defined, this method returns null.
		-->
		<method name="createEditor" args="parent, property, o">
			<![CDATA[
			var editor = null;
			if (this.cellEditorClass != null) {
				var initArgs = this.getEditorInitArgs();
				if (parent[this.cellEditorClass]) {
					editor = parent[this.cellEditorClass];
					if (initArgs != null) {
						for (var i in initArgs) {
							if (initArgs[i] != editor[i]) {
								editor.setAttribute(i, initArgs[i]);
							}
						}
					}
					if (o != editor.o) {
						editor.setAttribute("o", o);
					}
					if (property != editor.property) {
						editor.setAttribute("property", property);
					}
					if (!editor.visible) {
						editor.setAttribute("visible", true);
					}
				}
				else {
					var args = {
						name: this.cellEditorClass,
						property: property,
						o: o
					};
					if (initArgs != null) {
						for (var i in initArgs) {
							args[i] = initArgs[i];
						}
					}
					editor = new lz[this.cellEditorClass](parent, args);
				}
			}
			if (parent["editor"] && parent.editor != editor && parent.editor.visible) {
				parent.editor.setAttribute("visible", false);
				parent.editor.setAttribute("o", null);
				parent.editor.setAttribute("property", null);
			}
			parent.editor = editor;
			return editor;
			]]>
		</method>

		<!---
			@keywords private
			Override this method to return additional initialization arguments for that will be used to create the editor.
			@return object additional initialization arguments
		-->
		<method name="getEditorInitArgs">
			<![CDATA[
			return this.parent.getEditorInitArgs();
			]]>
		</method>
		
		<!---
			@keywords private
			Override this method to return validation errors to be associated with this column for the specified object.
			@param wcfGridCell the grid cell
			@param lz.Delegate optional delegate
			@return array array of validation errors
		-->
		<method name="getValidationErrors" args="cell,del=null">
			<![CDATA[
			var validationErrors = null;
			if (cell["editor"] && cell.editor["getValidationErrors"]) {
				validationErrors = cell.editor.getValidationErrors(del);
			}
			return validationErrors;
			]]>
		</method>
	</class>

</library>
